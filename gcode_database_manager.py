import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import sqlite3
import os
import re
from datetime import datetime, timedelta
from dataclasses import dataclass
from typing import List, Optional, Tuple, Set, Dict
import json
import sys
import shutil
import logging
from logging.handlers import RotatingFileHandler
import hashlib
import secrets
import threading
import queue

# Import the improved parser
from improved_gcode_parser import ImprovedGCodeParser, GCodeParseResult

# Import 2PC ring/hub OD lookup table for pair-matching
from validators.twopc_ring_size_validator import TWOPC_RING_TABLE

# Import Phase 1 modules
from utils.gcode_file_scanner import FileScanner
from utils.gcode_auto_fixer import AutoFixer
from utils.database_safety import DatabaseSafetyChecker
try:
    from utils.database_watcher import DatabaseWatcher, WATCHDOG_AVAILABLE
except ImportError:
    WATCHDOG_AVAILABLE = False
    DatabaseWatcher = None

# Import enhanced modules (commented out - modules not yet implemented)
# from modules.fuzzy_search import FuzzySearchManager
# from modules.clipboard_manager import ClipboardManager
# from modules.progress_tracker import GUIProgressTracker, NestedProgressTracker


# ============================================================================
# USER PERMISSIONS SYSTEM
# ============================================================================

# Permission definitions for each role
ROLE_PERMISSIONS = {
    'admin': {
        'view_files': True,
        'add_files': True,
        'edit_files': True,
        'delete_files': True,
        'move_files': True,
        'export_data': True,
        'clear_database': True,
        'manage_users': True,
        'backup_restore': True,
        'batch_operations': True,
        'manage_duplicates': True,
        'copy_files': True,
    },
    'editor': {
        'view_files': True,
        'add_files': True,
        'edit_files': True,
        'delete_files': False,
        'move_files': True,
        'export_data': True,
        'clear_database': False,
        'manage_users': False,
        'backup_restore': True,
        'batch_operations': True,
        'manage_duplicates': True,
        'copy_files': True,
    },
    'operator': {
        'view_files': True,
        'add_files': True,
        'edit_files': False,
        'delete_files': False,
        'move_files': False,
        'export_data': True,
        'clear_database': False,
        'manage_users': False,
        'backup_restore': False,
        'batch_operations': False,
        'manage_duplicates': False,
        'copy_files': True,
    },
    'viewer': {
        'view_files': True,
        'add_files': False,
        'edit_files': False,
        'delete_files': False,
        'move_files': False,
        'export_data': True,
        'clear_database': False,
        'manage_users': False,
        'backup_restore': False,
        'batch_operations': False,
        'manage_duplicates': False,
    }
}

ROLE_DESCRIPTIONS = {
    'admin': 'Full access - Can manage users and all operations',
    'editor': 'Can add, edit, move files - Cannot delete or manage users',
    'operator': 'Can view and add files - Cannot edit or delete',
    'viewer': 'Read-only access - Can only view and export'
}

# Theme definitions
THEMES = {
    'dark': {
        'bg_color': '#2b2b2b',
        'fg_color': '#ffffff',
        'input_bg': '#3c3c3c',
        'button_bg': '#4a4a4a',
        'accent_color': '#4a90e2',
        'success_color': '#4CAF50',
        'warning_color': '#FF9800',
        'error_color': '#D32F2F',
        'tree_bg': '#2b2b2b',
        'tree_fg': '#ffffff',
        'tree_selected': '#4a90e2',
        'header_bg': '#3c3c3c',
    },
    'light': {
        'bg_color': '#f5f5f5',
        'fg_color': '#212121',
        'input_bg': '#ffffff',
        'button_bg': '#e0e0e0',
        'accent_color': '#1976D2',
        'success_color': '#388E3C',
        'warning_color': '#F57C00',
        'error_color': '#C62828',
        'tree_bg': '#ffffff',
        'tree_fg': '#212121',
        'tree_selected': '#1976D2',
        'header_bg': '#e0e0e0',
    }
}


def hash_password(password: str, salt: str = None) -> Tuple[str, str]:
    """Hash a password with salt using SHA256"""
    if salt is None:
        salt = secrets.token_hex(16)
    password_hash = hashlib.sha256((password + salt).encode()).hexdigest()
    return password_hash, salt


def verify_password(password: str, stored_hash: str, salt: str) -> bool:
    """Verify a password against stored hash"""
    password_hash, _ = hash_password(password, salt)
    return password_hash == stored_hash

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================
def setup_logging():
    """
    Configure application-wide logging with file rotation.
    Creates logs in a 'logs' subdirectory with automatic rotation.
    """
    # Create logs directory if it doesn't exist
    log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")
    os.makedirs(log_dir, exist_ok=True)

    log_file = os.path.join(log_dir, "gcode_database.log")

    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s | %(levelname)-8s | %(funcName)s:%(lineno)d | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # File handler with rotation (5 MB max, keep 5 backups)
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=5*1024*1024,  # 5 MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)

    # Console handler for warnings and above
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.WARNING)
    console_handler.setFormatter(formatter)

    # Configure root logger
    logger = logging.getLogger('GCodeDB')
    logger.setLevel(logging.DEBUG)
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger

# Initialize global logger
logger = setup_logging()


# ============================================================================
# DATABASE RETRY HELPER - Handles Google Drive sync interference
# ============================================================================

import time

def commit_with_retry(connection, max_retries=5, initial_delay=0.1):
    """
    Commit database changes with exponential backoff retry logic.

    This handles "disk I/O error" issues that occur when the database is on
    Google Drive or other cloud storage that syncs files in the background.

    Args:
        connection: SQLite connection object
        max_retries: Maximum number of retry attempts (default: 5)
        initial_delay: Initial delay in seconds before retry (default: 0.1)

    Returns:
        True if commit succeeded, False if all retries failed

    Raises:
        sqlite3.OperationalError: If all retries exhausted
    """
    delay = initial_delay
    last_error = None

    for attempt in range(max_retries):
        try:
            connection.commit()
            if attempt > 0:
                logger.info(f"Commit succeeded on attempt {attempt + 1}")
            return True
        except sqlite3.OperationalError as e:
            last_error = e
            error_msg = str(e).lower()

            # Only retry on I/O errors or locked database
            if 'disk i/o error' in error_msg or 'database is locked' in error_msg:
                if attempt < max_retries - 1:
                    logger.warning(f"Commit failed (attempt {attempt + 1}/{max_retries}): {e}")
                    logger.info(f"Retrying in {delay:.2f} seconds...")
                    time.sleep(delay)
                    delay *= 2  # Exponential backoff
                else:
                    logger.error(f"Commit failed after {max_retries} attempts: {e}")
                    raise
            else:
                # Different error - don't retry
                raise

    # Should never reach here, but just in case
    if last_error:
        raise last_error
    return False


class MultiSelectCombobox(ttk.Frame):
    """Custom multi-select combobox widget"""
    def __init__(self, parent, values, bg_color, fg_color, input_bg, button_bg, width=15):
        super().__init__(parent, style='Dark.TFrame')
        self.values = values
        self.selected = set()
        self.bg_color = bg_color
        self.fg_color = fg_color
        self.input_bg = input_bg
        self.button_bg = button_bg

        # Display label showing selected count
        self.display_label = tk.Label(self, text="All", bg=input_bg, fg=fg_color,
                                     width=width, anchor='w', relief='sunken', cursor='hand2')
        self.display_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.display_label.bind('<Button-1>', self.show_popup)

        self.popup = None

    def show_popup(self, event=None):
        """Show multi-select popup"""
        if self.popup:
            self.popup.destroy()
            self.popup = None
            return

        # Create popup window
        self.popup = tk.Toplevel(self.master)
        self.popup.title("Select Items")
        self.popup.geometry("320x400")
        self.popup.configure(bg=self.bg_color)

        # Position below the button
        x = self.display_label.winfo_rootx()
        y = self.display_label.winfo_rooty() + self.display_label.winfo_height()
        self.popup.geometry(f"+{x}+{y}")

        # Make it a transient window
        self.popup.transient(self.master)
        self.popup.grab_set()

        # Frame for checkboxes
        frame = tk.Frame(self.popup, bg=self.bg_color)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Add scrollbar
        canvas = tk.Canvas(frame, bg=self.bg_color, highlightthickness=0)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg=self.bg_color)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        # Checkboxes for each value
        self.check_vars = {}
        for value in self.values:
            var = tk.BooleanVar(value=value in self.selected)
            self.check_vars[value] = var

            cb = tk.Checkbutton(scrollable_frame, text=value, variable=var,
                              bg=self.bg_color, fg=self.fg_color,
                              selectcolor=self.input_bg, activebackground=self.bg_color,
                              activeforeground=self.fg_color,
                              font=('Arial', 10), pady=5, padx=5,
                              cursor='hand2')
            cb.pack(anchor='w', pady=3, padx=5, fill=tk.X)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Buttons
        button_frame = tk.Frame(self.popup, bg=self.bg_color)
        button_frame.pack(fill=tk.X, padx=10, pady=10)

        btn_all = tk.Button(button_frame, text="Select All", command=self.select_all,
                          bg=self.button_bg, fg=self.fg_color,
                          font=('Arial', 10, 'bold'), width=12, height=2)
        btn_all.pack(side=tk.LEFT, padx=3, fill=tk.X, expand=True)

        btn_none = tk.Button(button_frame, text="Clear All", command=self.select_none,
                           bg=self.button_bg, fg=self.fg_color,
                           font=('Arial', 10, 'bold'), width=12, height=2)
        btn_none.pack(side=tk.LEFT, padx=3, fill=tk.X, expand=True)

        btn_apply = tk.Button(button_frame, text="✓ Apply", command=self.apply_selection,
                            bg='#4a90e2', fg=self.fg_color,
                            font=('Arial', 11, 'bold'), width=12, height=2)
        btn_apply.pack(side=tk.LEFT, padx=3, fill=tk.X, expand=True)

        # Close on click outside (bind to popup destroy)
        self.popup.bind('<FocusOut>', lambda e: self.close_popup())

    def select_all(self):
        """Select all items"""
        for var in self.check_vars.values():
            var.set(True)

    def select_none(self):
        """Clear all selections"""
        for var in self.check_vars.values():
            var.set(False)

    def apply_selection(self):
        """Apply the selection and close popup"""
        self.selected = {value for value, var in self.check_vars.items() if var.get()}
        self.update_display()
        self.close_popup()

    def close_popup(self):
        """Close the popup"""
        if self.popup:
            self.popup.destroy()
            self.popup = None

    def update_display(self):
        """Update the display label"""
        if not self.selected or len(self.selected) == len(self.values):
            self.display_label.config(text="All")
        elif len(self.selected) == 1:
            self.display_label.config(text=list(self.selected)[0])
        else:
            self.display_label.config(text=f"{len(self.selected)} selected")

    def get_selected(self) -> Set[str]:
        """Get selected values"""
        return self.selected if self.selected else set(self.values)

    def clear(self):
        """Clear all selections"""
        self.selected = set()
        self.update_display()


@dataclass
class ProgramRecord:
    """Represents a gcode program record"""
    program_number: str
    title: Optional[str]  # Raw title from G-code (content in parentheses)
    spacer_type: str
    outer_diameter: Optional[float]
    thickness: Optional[float]
    thickness_display: Optional[str]  # Display format: "10MM" or "0.75"
    center_bore: Optional[float]
    hub_height: Optional[float]
    hub_diameter: Optional[float]
    counter_bore_diameter: Optional[float]
    counter_bore_depth: Optional[float]
    paired_program: Optional[str]
    material: Optional[str]
    notes: Optional[str]
    date_created: Optional[str]
    last_modified: Optional[str]
    file_path: str
    # Validation fields
    detection_confidence: Optional[str] = None
    detection_method: Optional[str] = None
    validation_status: Optional[str] = None  # 'CRITICAL', 'DIMENSIONAL', 'BORE_WARNING', 'WARNING', 'PASS'
    validation_issues: Optional[str] = None  # JSON list - CRITICAL errors (RED)
    validation_warnings: Optional[str] = None  # JSON list - General warnings (YELLOW)
    bore_warnings: Optional[str] = None  # JSON list - Bore warnings (ORANGE)
    dimensional_issues: Optional[str] = None  # JSON list - P-code/thickness issues (PURPLE)
    cb_from_gcode: Optional[float] = None
    ob_from_gcode: Optional[float] = None
    lathe: Optional[str] = None  # 'L1', 'L2', 'L3', 'L2/L3'
    # Tool home position validation
    tool_home_status: Optional[str] = None  # 'PASS', 'WARNING', 'CRITICAL', 'N/A', 'UNKNOWN'
    tool_home_issues: Optional[List[str]] = None  # List of G53 Z position issues
    # Crash prevention fields
    crash_issues: Optional[List[str]] = None  # CRASH RISK issues (machine damage)
    crash_warnings: Optional[List[str]] = None  # Crash warnings (potential issues)
    # Feasibility fields
    feasibility_status: Optional[str] = None
    feasibility_issues: Optional[List[str]] = None
    feasibility_warnings: Optional[List[str]] = None
    # Tool tracking
    tools_used: Optional[List[str]] = None
    tool_sequence: Optional[List[str]] = None
    # Import tracking
    date_imported: Optional[str] = None  # ISO timestamp when file was imported to database

class GCodeDatabaseGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("G-Code Database Manager - Wheel Spacer Programs")
        self.root.geometry("1600x900")

        logger.info("=" * 60)
        logger.info("APPLICATION STARTUP")
        logger.info("=" * 60)

        try:
            # Theme system - load preference or default to dark
            logger.debug("Initializing colors and theme...")
            self.current_theme = 'dark'  # Will be updated from config
            self._apply_theme_colors()

            self.root.configure(bg=self.bg_color)

            # Database setup
            logger.info("Initializing database...")
            self.db_path = "gcode_database.db"
            self.init_database()
            logger.info("Database initialized successfully")

            # User session - will be set after login
            self.current_user = None
            self.current_user_id = None
            self.current_username = None
            self.current_user_role = None
            self.user_permissions = {}

            # Configuration
            logger.debug("Loading configuration...")
            self.config_file = "gcode_manager_config.json"
            self.load_config()

            # Initialize repository system
            logger.info("Initializing repository system...")
            self.init_repository()
            logger.info("Repository system initialized")

            # Initialize improved parser
            logger.debug("Initializing G-code parser...")
            self.parser = ImprovedGCodeParser()

            # Initialize Phase 1 modules
            logger.debug("Initializing Phase 1 safety features...")
            self.file_scanner = FileScanner()
            self.safety_checker = DatabaseSafetyChecker(self.db_path)
            self.safety_checker.record_access()
            logger.debug("Phase 1 modules initialized")

            # Initialize enhanced modules (commented out - modules not yet implemented)
            # logger.debug("Initializing enhanced modules...")
            # self.fuzzy_search = FuzzySearchManager(threshold=70)
            # self.clipboard = ClipboardManager()
            # logger.debug("Enhanced modules initialized")

            # Configure ttk theme — prefer sv_ttk dark for modern look
            try:
                import sv_ttk
                sv_ttk.set_theme("dark")
                style = ttk.Style()
            except ImportError:
                style = ttk.Style()
                style.theme_use('clam')
            self._update_ttk_styles()

            # Show login dialog - must succeed before continuing
            logger.info("Showing login dialog...")
            if not self.show_login_dialog():
                logger.info("Login cancelled or failed")
                self.root.destroy()
                return
            logger.info(f"Login successful for user: {self.current_username}")

            # Get available values from database for filters
            logger.debug("Loading filter values...")
            self.available_types = self.get_available_values("spacer_type")
            self.available_materials = self.get_available_values("material")
            self.available_statuses = self.get_available_values("validation_status")

            # Build GUI
            logger.info("Building GUI...")
            self.setup_gui()
            logger.info("GUI built successfully")

            # Enable drag and drop
            logger.debug("Setting up drag and drop...")
            self.setup_drag_drop()

            logger.info("Refreshing results...")
            self.refresh_results()
            logger.info("Results refreshed")

            # Update error filter dropdown with DB hit counts
            self.root.after(200, self._update_error_filter_counts)

            # Set up clean shutdown handler
            self.root.protocol("WM_DELETE_WINDOW", self._on_closing)

            # Run startup integrity check in background (after UI is shown)
            logger.info("Scheduling startup integrity check...")
            self.root.after(500, self._run_startup_integrity_check_background)
            logger.info("Startup complete - integrity check running in background")

            # Initialize database monitoring (Phase 1.2) if enabled and available
            if WATCHDOG_AVAILABLE and self.config.get('db_monitor_enabled', False):
                logger.info("Starting database file monitor...")
                self._init_database_monitor()

        except Exception as e:
            logger.critical(f"STARTUP FAILED: {e}", exc_info=True)
            import traceback
            traceback.print_exc()
            raise

    def _on_closing(self):
        """Handle window close - ensure clean shutdown"""
        logger.info("Application closing...")

        # Stop database monitoring if active (Phase 1.2)
        if hasattr(self, 'db_observer') and self.db_observer:
            try:
                self.db_observer.stop()
                self.db_observer.join(timeout=2)
                logger.info("Database monitoring stopped")
            except:
                pass

        try:
            self.root.destroy()
        except:
            pass
        import sys
        sys.exit(0)

    def _run_startup_integrity_check_background(self):
        """Run integrity check in background thread to not block UI"""
        import threading

        def run_check():
            try:
                logger.info("Running startup integrity check (background)...")
                self.run_startup_integrity_check()
                logger.info("Startup integrity check completed")
            except Exception as e:
                logger.error(f"Background integrity check failed: {e}", exc_info=True)

        thread = threading.Thread(target=run_check, daemon=True)
        thread.start()

    def _init_database_monitor(self):
        """Initialize database file monitoring system (Phase 1.2)"""
        try:
            from watchdog.observers import Observer

            # Create watcher with callback
            self.db_watcher = DatabaseWatcher(
                db_path=self.db_path,
                callback=self._on_database_modified_externally
            )

            # Set up observer
            self.db_observer = Observer()
            db_dir = os.path.dirname(self.db_path)
            self.db_observer.schedule(self.db_watcher, db_dir, recursive=False)
            self.db_observer.start()

            logger.info("Database monitoring active")
        except Exception as e:
            logger.error(f"Failed to start database monitor: {e}")
            self.db_observer = None

    def _on_database_modified_externally(self):
        """Called when database file is modified by external process (Phase 1.2)"""
        logger.warning("Database modified externally - changes detected")

        # Show notification to user (use root.after for thread safety)
        self.root.after(0, self._show_database_change_notification)

    def _show_database_change_notification(self):
        """Show user notification about external database changes (Phase 1.2)"""
        if not self.config.get('db_monitor_notify', True):
            # Notifications disabled, just auto-refresh if enabled
            if self.config.get('db_monitor_auto_refresh', True):
                self.refresh_results()
            return

        response = messagebox.askyesno(
            "Database Modified",
            "The database has been modified by another process or computer.\n\n"
            "Would you like to refresh the view to see the changes?\n\n"
            "Note: Any unsaved filters will be reset.",
            icon='warning'
        )

        if response:
            self.refresh_results()
            logger.info("Database refreshed after external modification")

    # ========================================================================
    # USER AUTHENTICATION & PERMISSIONS
    # ========================================================================

    def show_login_dialog(self) -> bool:
        """Show login dialog. Returns True if login successful."""
        login_window = tk.Toplevel(self.root)
        login_window.title("Login - G-Code Database Manager")
        login_window.geometry("400x350")
        login_window.configure(bg=self.bg_color)
        login_window.transient(self.root)
        login_window.grab_set()

        # Center the window
        login_window.update_idletasks()
        x = (login_window.winfo_screenwidth() - 400) // 2
        y = (login_window.winfo_screenheight() - 350) // 2
        login_window.geometry(f"+{x}+{y}")

        # Prevent closing without login
        login_window.protocol("WM_DELETE_WINDOW", lambda: self._cancel_login(login_window))

        self.login_success = False

        # Title
        tk.Label(login_window, text="G-Code Database Manager",
                font=("Arial", 16, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(20, 5))
        tk.Label(login_window, text="Please login to continue",
                font=("Arial", 10), bg=self.bg_color, fg="#888888").pack(pady=(0, 20))

        # Username
        tk.Label(login_window, text="Username:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(anchor="w", padx=50)
        username_entry = tk.Entry(login_window, bg=self.input_bg, fg=self.fg_color,
                                 font=("Arial", 11), width=30)
        username_entry.pack(pady=(5, 15), padx=50)
        username_entry.focus_set()

        # Password
        tk.Label(login_window, text="Password:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(anchor="w", padx=50)
        password_entry = tk.Entry(login_window, bg=self.input_bg, fg=self.fg_color,
                                 font=("Arial", 11), width=30, show="*")
        password_entry.pack(pady=(5, 10), padx=50)

        # Error message label
        error_label = tk.Label(login_window, text="", bg=self.bg_color, fg="#ff6b6b",
                              font=("Arial", 9))
        error_label.pack(pady=5)

        def attempt_login(event=None):
            username = username_entry.get().strip()
            password = password_entry.get()

            if not username or not password:
                error_label.config(text="Please enter username and password")
                return

            result = self._authenticate_user(username, password)

            if result['success']:
                self.login_success = True
                self.current_user_id = result['user_id']
                self.current_username = result['username']
                self.current_user_role = result['role']
                self.user_permissions = ROLE_PERMISSIONS.get(result['role'], {})

                # Update last login time
                self._update_last_login(result['user_id'])

                # Check if password change required
                if result.get('must_change_password'):
                    login_window.destroy()
                    self._force_password_change()
                else:
                    login_window.destroy()
            else:
                error_label.config(text=result['message'])
                password_entry.delete(0, tk.END)

        # Bind Enter key
        username_entry.bind('<Return>', lambda e: password_entry.focus_set())
        password_entry.bind('<Return>', attempt_login)

        # Buttons
        btn_frame = tk.Frame(login_window, bg=self.bg_color)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="Login", command=attempt_login,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 11, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="Exit", command=lambda: self._cancel_login(login_window),
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 11),
                 width=12, height=2).pack(side=tk.LEFT, padx=10)

        # Default credentials hint (remove in production)
        tk.Label(login_window, text="Default: admin / admin123",
                font=("Arial", 8, "italic"), bg=self.bg_color, fg="#666666").pack(pady=(10, 0))

        self.root.wait_window(login_window)
        return self.login_success

    def _cancel_login(self, window):
        """Cancel login and exit"""
        self.login_success = False
        window.destroy()

    def _authenticate_user(self, username: str, password: str) -> Dict:
        """Authenticate user credentials"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT user_id, username, password_hash, password_salt, role,
                       is_active, must_change_password, failed_login_attempts, locked_until
                FROM users WHERE username = ?
            """, (username,))

            user = cursor.fetchone()

            if not user:
                conn.close()
                return {'success': False, 'message': 'Invalid username or password'}

            user_id, db_username, pw_hash, pw_salt, role, is_active, must_change, failed_attempts, locked_until = user

            # Check if account is locked
            if locked_until:
                lock_time = datetime.fromisoformat(locked_until)
                if datetime.now() < lock_time:
                    mins_left = int((lock_time - datetime.now()).total_seconds() / 60) + 1
                    conn.close()
                    return {'success': False, 'message': f'Account locked. Try again in {mins_left} minutes'}
                else:
                    # Unlock the account
                    cursor.execute("UPDATE users SET locked_until = NULL, failed_login_attempts = 0 WHERE user_id = ?", (user_id,))
                    conn.commit()

            # Check if account is active
            if not is_active:
                conn.close()
                return {'success': False, 'message': 'Account is disabled. Contact administrator.'}

            # Verify password
            if not pw_hash or not pw_salt:
                # No password set yet (shouldn't happen with new setup)
                conn.close()
                return {'success': False, 'message': 'Account not properly configured'}

            if verify_password(password, pw_hash, pw_salt):
                # Reset failed attempts on success
                cursor.execute("UPDATE users SET failed_login_attempts = 0 WHERE user_id = ?", (user_id,))
                conn.commit()
                conn.close()

                return {
                    'success': True,
                    'user_id': user_id,
                    'username': db_username,
                    'role': role,
                    'must_change_password': bool(must_change)
                }
            else:
                # Increment failed attempts
                new_attempts = (failed_attempts or 0) + 1
                if new_attempts >= 5:
                    # Lock account for 15 minutes
                    lock_until = (datetime.now() + timedelta(minutes=15)).isoformat()
                    cursor.execute("UPDATE users SET failed_login_attempts = ?, locked_until = ? WHERE user_id = ?",
                                 (new_attempts, lock_until, user_id))
                    conn.commit()
                    conn.close()
                    return {'success': False, 'message': 'Too many failed attempts. Account locked for 15 minutes.'}
                else:
                    cursor.execute("UPDATE users SET failed_login_attempts = ? WHERE user_id = ?", (new_attempts, user_id))
                    conn.commit()
                    conn.close()
                    return {'success': False, 'message': f'Invalid username or password ({5 - new_attempts} attempts remaining)'}

        except Exception as e:
            logger.error(f"Authentication error: {e}", exc_info=True)
            return {'success': False, 'message': 'Login error. Please try again.'}

    def _update_last_login(self, user_id: int):
        """Update user's last login timestamp"""
        from datetime import datetime
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("UPDATE users SET last_login = ? WHERE user_id = ?",
                         (datetime.now().isoformat(), user_id))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f"Error updating last login: {e}")

    def _force_password_change(self):
        """Force user to change password on first login"""
        change_window = tk.Toplevel(self.root)
        change_window.title("Change Password Required")
        change_window.geometry("400x300")
        change_window.configure(bg=self.bg_color)
        change_window.transient(self.root)
        change_window.grab_set()

        # Center
        change_window.update_idletasks()
        x = (change_window.winfo_screenwidth() - 400) // 2
        y = (change_window.winfo_screenheight() - 300) // 2
        change_window.geometry(f"+{x}+{y}")

        tk.Label(change_window, text="Password Change Required",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(20, 5))
        tk.Label(change_window, text="Please set a new password to continue",
                font=("Arial", 10), bg=self.bg_color, fg="#888888").pack(pady=(0, 20))

        tk.Label(change_window, text="New Password:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w", padx=50)
        new_pw_entry = tk.Entry(change_window, bg=self.input_bg, fg=self.fg_color, width=30, show="*")
        new_pw_entry.pack(pady=(5, 10), padx=50)
        new_pw_entry.focus_set()

        tk.Label(change_window, text="Confirm Password:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w", padx=50)
        confirm_pw_entry = tk.Entry(change_window, bg=self.input_bg, fg=self.fg_color, width=30, show="*")
        confirm_pw_entry.pack(pady=(5, 10), padx=50)

        error_label = tk.Label(change_window, text="", bg=self.bg_color, fg="#ff6b6b")
        error_label.pack(pady=5)

        def save_new_password():
            new_pw = new_pw_entry.get()
            confirm_pw = confirm_pw_entry.get()

            if len(new_pw) < 6:
                error_label.config(text="Password must be at least 6 characters")
                return
            if new_pw != confirm_pw:
                error_label.config(text="Passwords do not match")
                return

            # Update password
            pw_hash, pw_salt = hash_password(new_pw)
            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET password_hash = ?, password_salt = ?, must_change_password = 0
                    WHERE user_id = ?
                """, (pw_hash, pw_salt, self.current_user_id))
                conn.commit()
                conn.close()
                messagebox.showinfo("Success", "Password changed successfully!")
                change_window.destroy()
            except Exception as e:
                error_label.config(text="Error saving password")
                logger.error(f"Password change error: {e}")

        tk.Button(change_window, text="Save Password", command=save_new_password,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 11, "bold"),
                 width=15, height=2).pack(pady=20)

        change_window.wait_window()

    def has_permission(self, permission: str) -> bool:
        """Check if current user has a specific permission"""
        return self.user_permissions.get(permission, False)

    def require_permission(self, permission: str, action_name: str = "this action") -> bool:
        """Check permission and show error if denied. Returns True if allowed."""
        if self.has_permission(permission):
            return True
        messagebox.showerror("Permission Denied",
                           f"You don't have permission to perform {action_name}.\n\n"
                           f"Required permission: {permission}\n"
                           f"Your role: {self.current_user_role}")
        return False

    def logout_user(self):
        """Logout current user and show login dialog"""
        if messagebox.askyesno("Logout", "Are you sure you want to logout?"):
            # Clear current session
            self.current_user = None
            self.current_user_id = None
            self.current_username = None
            self.current_user_role = None
            self.user_permissions = {}

            # Destroy main window and restart
            self.root.destroy()

            # Create new root and re-initialize
            new_root = tk.Tk()
            app = GCodeDatabaseGUI(new_root)
            new_root.mainloop()

    def show_change_password(self):
        """Show dialog to change current user's password"""
        change_window = tk.Toplevel(self.root)
        change_window.title("Change Password")
        change_window.geometry("400x350")
        change_window.configure(bg=self.bg_color)
        change_window.transient(self.root)
        change_window.grab_set()

        # Center
        change_window.update_idletasks()
        x = (change_window.winfo_screenwidth() - 400) // 2
        y = (change_window.winfo_screenheight() - 350) // 2
        change_window.geometry(f"+{x}+{y}")

        tk.Label(change_window, text="Change Password",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(20, 20))

        tk.Label(change_window, text="Current Password:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w", padx=50)
        current_pw = tk.Entry(change_window, bg=self.input_bg, fg=self.fg_color, width=30, show="*")
        current_pw.pack(pady=(5, 10), padx=50)
        current_pw.focus_set()

        tk.Label(change_window, text="New Password:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w", padx=50)
        new_pw = tk.Entry(change_window, bg=self.input_bg, fg=self.fg_color, width=30, show="*")
        new_pw.pack(pady=(5, 10), padx=50)

        tk.Label(change_window, text="Confirm New Password:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w", padx=50)
        confirm_pw = tk.Entry(change_window, bg=self.input_bg, fg=self.fg_color, width=30, show="*")
        confirm_pw.pack(pady=(5, 10), padx=50)

        error_label = tk.Label(change_window, text="", bg=self.bg_color, fg="#ff6b6b")
        error_label.pack(pady=5)

        def save_password():
            curr = current_pw.get()
            new = new_pw.get()
            conf = confirm_pw.get()

            # Verify current password
            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("SELECT password_hash, password_salt FROM users WHERE user_id = ?",
                             (self.current_user_id,))
                row = cursor.fetchone()
                conn.close()

                if not row or not verify_password(curr, row[0], row[1]):
                    error_label.config(text="Current password is incorrect")
                    return
            except Exception as e:
                error_label.config(text="Error verifying password")
                return

            if len(new) < 6:
                error_label.config(text="New password must be at least 6 characters")
                return
            if new != conf:
                error_label.config(text="New passwords do not match")
                return

            # Update password
            pw_hash, pw_salt = hash_password(new)
            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("UPDATE users SET password_hash = ?, password_salt = ? WHERE user_id = ?",
                             (pw_hash, pw_salt, self.current_user_id))
                conn.commit()
                conn.close()
                messagebox.showinfo("Success", "Password changed successfully!")
                change_window.destroy()
            except Exception as e:
                error_label.config(text="Error saving password")

        btn_frame = tk.Frame(change_window, bg=self.bg_color)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="Save", command=save_password,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="Cancel", command=change_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=12).pack(side=tk.LEFT, padx=10)

    def show_user_management(self):
        """Show user management interface (admin only)"""
        if not self.require_permission('manage_users', 'manage users'):
            return

        self.user_mgmt_window = tk.Toplevel(self.root)
        self.user_mgmt_window.title("User Management")
        self.user_mgmt_window.geometry("900x600")
        self.user_mgmt_window.configure(bg=self.bg_color)
        self.user_mgmt_window.transient(self.root)

        # Title
        tk.Label(self.user_mgmt_window, text="User Management",
                font=("Arial", 16, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(15, 10))

        # Button bar
        btn_bar = tk.Frame(self.user_mgmt_window, bg=self.bg_color)
        btn_bar.pack(fill=tk.X, padx=20, pady=10)

        tk.Button(btn_bar, text="+ Add User", command=self._add_user_dialog,
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_bar, text="Edit User", command=self._edit_user_dialog,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_bar, text="Reset Password", command=self._reset_user_password,
                 bg="#FF9800", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_bar, text="Disable/Enable", command=self._toggle_user_active,
                 bg="#9C27B0", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_bar, text="Delete User", command=self._delete_user,
                 bg="#D32F2F", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_bar, text="Refresh", command=self._refresh_user_list,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=10).pack(side=tk.RIGHT, padx=5)

        # User list
        list_frame = tk.Frame(self.user_mgmt_window, bg=self.bg_color)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        columns = ('username', 'full_name', 'role', 'email', 'status', 'last_login')
        self.user_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=15)

        self.user_tree.heading('username', text='Username')
        self.user_tree.heading('full_name', text='Full Name')
        self.user_tree.heading('role', text='Role')
        self.user_tree.heading('email', text='Email')
        self.user_tree.heading('status', text='Status')
        self.user_tree.heading('last_login', text='Last Login')

        self.user_tree.column('username', width=120)
        self.user_tree.column('full_name', width=150)
        self.user_tree.column('role', width=100)
        self.user_tree.column('email', width=180)
        self.user_tree.column('status', width=80)
        self.user_tree.column('last_login', width=150)

        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.user_tree.yview)
        self.user_tree.configure(yscrollcommand=scrollbar.set)

        self.user_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Role legend
        legend_frame = tk.Frame(self.user_mgmt_window, bg=self.bg_color)
        legend_frame.pack(fill=tk.X, padx=20, pady=10)

        tk.Label(legend_frame, text="Roles:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=5)

        for role, desc in ROLE_DESCRIPTIONS.items():
            tk.Label(legend_frame, text=f"{role}: {desc}",
                    bg=self.bg_color, fg="#888888", font=("Arial", 8)).pack(side=tk.LEFT, padx=10)

        # Load users
        self._refresh_user_list()

    def _refresh_user_list(self):
        """Refresh the user list in management window"""
        if not hasattr(self, 'user_tree'):
            return

        # Clear existing
        for item in self.user_tree.get_children():
            self.user_tree.delete(item)

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT user_id, username, full_name, role, email, is_active, last_login
                FROM users ORDER BY username
            """)
            users = cursor.fetchall()
            conn.close()

            for user in users:
                user_id, username, full_name, role, email, is_active, last_login = user
                status = "Active" if is_active else "Disabled"
                last_login_display = last_login[:16] if last_login else "Never"

                self.user_tree.insert('', tk.END, values=(
                    username, full_name or '', role, email or '', status, last_login_display
                ), tags=(str(user_id),))

        except Exception as e:
            logger.error(f"Error loading users: {e}")

    def _add_user_dialog(self):
        """Show dialog to add a new user"""
        dialog = tk.Toplevel(self.user_mgmt_window)
        dialog.title("Add New User")
        dialog.geometry("400x450")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.user_mgmt_window)
        dialog.grab_set()

        tk.Label(dialog, text="Add New User",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(15, 15))

        # Form fields
        fields_frame = tk.Frame(dialog, bg=self.bg_color)
        fields_frame.pack(fill=tk.X, padx=30)

        tk.Label(fields_frame, text="Username*:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        username_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35)
        username_entry.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Full Name:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        fullname_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35)
        fullname_entry.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Email:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        email_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35)
        email_entry.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Role*:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        role_var = tk.StringVar(value="viewer")
        role_combo = ttk.Combobox(fields_frame, textvariable=role_var,
                                 values=list(ROLE_PERMISSIONS.keys()), state="readonly", width=32)
        role_combo.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Initial Password*:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        password_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35, show="*")
        password_entry.pack(pady=(2, 10))

        # Require password change checkbox
        require_change_var = tk.BooleanVar(value=True)
        tk.Checkbutton(fields_frame, text="Require password change on first login",
                      variable=require_change_var, bg=self.bg_color, fg=self.fg_color,
                      selectcolor=self.input_bg).pack(anchor="w", pady=5)

        error_label = tk.Label(dialog, text="", bg=self.bg_color, fg="#ff6b6b")
        error_label.pack(pady=5)

        def save_user():
            from datetime import datetime
            username = username_entry.get().strip()
            fullname = fullname_entry.get().strip()
            email = email_entry.get().strip()
            role = role_var.get()
            password = password_entry.get()

            if not username:
                error_label.config(text="Username is required")
                return
            if len(password) < 6:
                error_label.config(text="Password must be at least 6 characters")
                return

            pw_hash, pw_salt = hash_password(password)

            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO users (username, password_hash, password_salt, full_name, email, role,
                                      date_created, is_active, must_change_password)
                    VALUES (?, ?, ?, ?, ?, ?, ?, 1, ?)
                """, (username, pw_hash, pw_salt, fullname or None, email or None, role,
                     datetime.now().isoformat(), 1 if require_change_var.get() else 0))
                conn.commit()
                conn.close()

                self.log_activity('USER_CREATED', None, f"Created user: {username} with role: {role}")
                messagebox.showinfo("Success", f"User '{username}' created successfully!")
                dialog.destroy()
                self._refresh_user_list()

            except sqlite3.IntegrityError:
                error_label.config(text="Username already exists")
            except Exception as e:
                error_label.config(text=f"Error creating user: {str(e)[:30]}")
                logger.error(f"Error creating user: {e}")

        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="Create User", command=save_user,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="Cancel", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=12).pack(side=tk.LEFT, padx=10)

    def _edit_user_dialog(self):
        """Edit selected user"""
        selected = self.user_tree.selection()
        if not selected:
            messagebox.showwarning("Select User", "Please select a user to edit")
            return

        item = self.user_tree.item(selected[0])
        username = item['values'][0]

        # Get user details
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("SELECT user_id, username, full_name, email, role FROM users WHERE username = ?",
                         (username,))
            user = cursor.fetchone()
            conn.close()
        except Exception as e:
            messagebox.showerror("Error", f"Error loading user: {e}")
            return

        if not user:
            return

        user_id, db_username, full_name, email, role = user

        dialog = tk.Toplevel(self.user_mgmt_window)
        dialog.title(f"Edit User: {username}")
        dialog.geometry("400x350")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.user_mgmt_window)
        dialog.grab_set()

        tk.Label(dialog, text=f"Edit User: {username}",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=(15, 15))

        fields_frame = tk.Frame(dialog, bg=self.bg_color)
        fields_frame.pack(fill=tk.X, padx=30)

        tk.Label(fields_frame, text="Full Name:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        fullname_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35)
        fullname_entry.insert(0, full_name or '')
        fullname_entry.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Email:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        email_entry = tk.Entry(fields_frame, bg=self.input_bg, fg=self.fg_color, width=35)
        email_entry.insert(0, email or '')
        email_entry.pack(pady=(2, 10))

        tk.Label(fields_frame, text="Role:", bg=self.bg_color, fg=self.fg_color).pack(anchor="w")
        role_var = tk.StringVar(value=role)
        role_combo = ttk.Combobox(fields_frame, textvariable=role_var,
                                 values=list(ROLE_PERMISSIONS.keys()), state="readonly", width=32)
        role_combo.pack(pady=(2, 10))

        # Prevent changing own role from admin
        if username == self.current_username and role == 'admin':
            role_combo.config(state="disabled")
            tk.Label(fields_frame, text="(Cannot change your own admin role)",
                    bg=self.bg_color, fg="#ff6b6b", font=("Arial", 8)).pack(anchor="w")

        error_label = tk.Label(dialog, text="", bg=self.bg_color, fg="#ff6b6b")
        error_label.pack(pady=5)

        def save_changes():
            new_fullname = fullname_entry.get().strip()
            new_email = email_entry.get().strip()
            new_role = role_var.get()

            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET full_name = ?, email = ?, role = ?
                    WHERE user_id = ?
                """, (new_fullname or None, new_email or None, new_role, user_id))
                conn.commit()
                conn.close()

                self.log_activity('USER_UPDATED', None, f"Updated user: {username}")
                messagebox.showinfo("Success", "User updated successfully!")
                dialog.destroy()
                self._refresh_user_list()

            except Exception as e:
                error_label.config(text=f"Error: {str(e)[:30]}")

        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="Save Changes", command=save_changes,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="Cancel", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=12).pack(side=tk.LEFT, padx=10)

    def _reset_user_password(self):
        """Reset selected user's password"""
        selected = self.user_tree.selection()
        if not selected:
            messagebox.showwarning("Select User", "Please select a user to reset password")
            return

        item = self.user_tree.item(selected[0])
        username = item['values'][0]

        # Generate temporary password
        temp_password = secrets.token_urlsafe(8)

        if messagebox.askyesno("Reset Password",
                              f"Reset password for user '{username}'?\n\n"
                              f"New temporary password: {temp_password}\n\n"
                              "Make sure to share this with the user!"):
            try:
                pw_hash, pw_salt = hash_password(temp_password)
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE users SET password_hash = ?, password_salt = ?,
                                    must_change_password = 1, failed_login_attempts = 0, locked_until = NULL
                    WHERE username = ?
                """, (pw_hash, pw_salt, username))
                conn.commit()
                conn.close()

                self.log_activity('PASSWORD_RESET', None, f"Reset password for user: {username}")

                messagebox.showinfo("Password Reset",
                                  f"Password reset successfully!\n\n"
                                  f"Username: {username}\n"
                                  f"Temporary Password: {temp_password}\n\n"
                                  "User will be required to change password on next login.")

            except Exception as e:
                messagebox.showerror("Error", f"Error resetting password: {e}")

    def _toggle_user_active(self):
        """Enable or disable selected user"""
        selected = self.user_tree.selection()
        if not selected:
            messagebox.showwarning("Select User", "Please select a user")
            return

        item = self.user_tree.item(selected[0])
        username = item['values'][0]
        current_status = item['values'][4]

        if username == self.current_username:
            messagebox.showwarning("Cannot Disable", "You cannot disable your own account!")
            return

        new_status = 0 if current_status == "Active" else 1
        action = "disable" if new_status == 0 else "enable"

        if messagebox.askyesno("Confirm",
                              f"Are you sure you want to {action} user '{username}'?"):
            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("UPDATE users SET is_active = ? WHERE username = ?",
                             (new_status, username))
                conn.commit()
                conn.close()

                self.log_activity('USER_STATUS_CHANGED', None,
                                f"{'Enabled' if new_status else 'Disabled'} user: {username}")
                self._refresh_user_list()

            except Exception as e:
                messagebox.showerror("Error", f"Error updating user: {e}")

    def _delete_user(self):
        """Delete selected user"""
        selected = self.user_tree.selection()
        if not selected:
            messagebox.showwarning("Select User", "Please select a user to delete")
            return

        item = self.user_tree.item(selected[0])
        username = item['values'][0]

        if username == self.current_username:
            messagebox.showwarning("Cannot Delete", "You cannot delete your own account!")
            return

        if username == 'admin':
            messagebox.showwarning("Cannot Delete", "The admin account cannot be deleted!")
            return

        if messagebox.askyesno("Confirm Delete",
                              f"Are you sure you want to permanently delete user '{username}'?\n\n"
                              "This action cannot be undone!"):
            try:
                conn = sqlite3.connect(self.db_path, timeout=30.0)
                cursor = conn.cursor()
                cursor.execute("DELETE FROM users WHERE username = ?", (username,))
                conn.commit()
                conn.close()

                self.log_activity('USER_DELETED', None, f"Deleted user: {username}")
                messagebox.showinfo("Deleted", f"User '{username}' has been deleted.")
                self._refresh_user_list()

            except Exception as e:
                messagebox.showerror("Error", f"Error deleting user: {e}")

    def run_startup_integrity_check(self):
        """
        Run integrity check on startup to detect untracked files and orphaned records.
        Automatically fixes issues found and populates missing content hashes.
        """
        try:
            # Run integrity check
            result = self.verify_repository_integrity(fix_issues=True)

            # Report findings
            total_issues = (
                len(result['untracked_files']) +
                len(result['orphaned_records']) +
                len(result['registry_stale'])
            )

            if total_issues > 0:
                fixed = result['fixed']
                message = f"Startup integrity check completed:\n"

                if result['untracked_files']:
                    message += f"  - {fixed['files_added']} untracked files added to database\n"
                if result['orphaned_records']:
                    message += f"  - {fixed['records_removed']} orphaned records removed\n"
                if result['registry_stale']:
                    message += f"  - {fixed['registry_updated']} stale registry entries fixed\n"

                logger.info(message.replace('\n', ' | '))

                # Refresh the UI to show new files (must be done on main thread)
                if fixed['files_added'] > 0 or fixed['records_removed'] > 0:
                    self.root.after(0, lambda: self.cascade_refresh('startup_integrity'))

            # Populate content hashes for files that don't have them (runs in background)
            self.root.after(1000, self._populate_hashes_background)

        except Exception as e:
            logger.error(f"Startup integrity check error: {e}", exc_info=True)

    def _populate_hashes_background(self):
        """Background task to populate content hashes."""
        conn = None
        try:
            # Check how many files need hashes
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM programs WHERE content_hash IS NULL AND file_path IS NOT NULL")
            count = cursor.fetchone()[0]
            conn.close()
            conn = None

            if count > 0:
                logger.info(f"Populating content hashes for {count} files...")
                result = self.populate_content_hashes()
                logger.info(f"Hash population complete - Hashed: {result['updated']}, Skipped: {result['skipped']}, Errors: {result['errors']}")
        except Exception as e:
            logger.error(f"Background hash population error: {e}", exc_info=True)
        finally:
            if conn:
                conn.close()

    def init_database(self):
        """Initialize SQLite database with schema

        ================================================================================
        PROGRAMS TABLE COLUMN REFERENCE (57 columns total)
        ================================================================================
        ⚠️  CRITICAL: Before adding new columns, read docs/DATABASE_SCHEMA_MAINTENANCE.md

        This file contains a complete registry of ALL INSERT statement locations that
        must be updated when adding columns. Failure to update all locations causes:
        "table has X columns but got Y values" errors.

        When adding new columns, you MUST update ALL of the following locations:

        1. CREATE TABLE statement (below) - add column definition
        2. ALTER TABLE section (below) - add migration for existing databases
        3. ProgramRecord dataclass (around line 300) - add field
        4. Documentation comment column list (below) - update count and list

        INSERT statements using VALUES (positional - MUST have all 57 values):
        5. Line ~8676: scan_folder() -> scan_thread() INSERT
        6. Line ~9026: process_new_files_workflow() -> import thread INSERT
        7. Line ~24480: ManualEntryDialog.save_entry() INSERT

        INSERT statements using named columns (MUST add column name + value):
        8. Line ~5195: process_new_file() INSERT (35 columns - check if needed)
        9. Line ~7944: import_files_batch() INSERT OR REPLACE (57 columns)
        10. Line ~8025: _import_single_file() INSERT OR REPLACE (57 columns)
        11. Line ~9458: scan_new_files() INSERT (57 columns)

        📖 SEE: docs/DATABASE_SCHEMA_MAINTENANCE.md for complete reference

        Column order (for VALUES inserts):
        1. program_number          2. title                   3. spacer_type
        4. outer_diameter          5. thickness               6. thickness_display
        7. center_bore             8. hub_height              9. hub_diameter
        10. counter_bore_diameter  11. counter_bore_depth     12. paired_program
        13. material               14. notes                  15. date_created
        16. last_modified          17. file_path              18. detection_confidence
        19. detection_method       20. validation_status      21. validation_issues
        22. validation_warnings    23. cb_from_gcode          24. ob_from_gcode
        25. bore_warnings          26. dimensional_issues     27. lathe
        28. duplicate_type         29. parent_file            30. duplicate_group
        31. current_version        32. modified_by            33. is_managed
        34. round_size             35. round_size_confidence  36. round_size_source
        37. in_correct_range       38. legacy_names           39. last_renamed_date
        40. rename_reason          41. tools_used             42. tool_sequence
        43. tool_validation_status 44. tool_validation_issues 45. safety_blocks_status
        46. safety_blocks_issues   47. content_hash           48. tool_home_status
        49. tool_home_issues       50. hub_height_display     51. counter_bore_depth_display
        52. feasibility_status     53. feasibility_issues     54. feasibility_warnings
        55. crash_issues           56. crash_warnings         57. date_imported
        ================================================================================
        """
        from datetime import datetime
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Enable WAL mode for better concurrent access (prevents database lock issues)
        cursor.execute("PRAGMA journal_mode=WAL")
        cursor.execute("PRAGMA busy_timeout=30000")

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS programs (
                program_number TEXT PRIMARY KEY,
                title TEXT,
                spacer_type TEXT NOT NULL,
                outer_diameter REAL,
                thickness REAL,
                thickness_display TEXT,
                center_bore REAL,
                hub_height REAL,
                hub_diameter REAL,
                counter_bore_diameter REAL,
                counter_bore_depth REAL,
                paired_program TEXT,
                material TEXT,
                notes TEXT,
                date_created TEXT,
                last_modified TEXT,
                file_path TEXT,
                detection_confidence TEXT,
                detection_method TEXT,
                validation_status TEXT,
                validation_issues TEXT,
                validation_warnings TEXT,
                bore_warnings TEXT,
                dimensional_issues TEXT,
                cb_from_gcode REAL,
                ob_from_gcode REAL,
                lathe TEXT,
                feasibility_status TEXT,
                feasibility_issues TEXT,
                feasibility_warnings TEXT,
                crash_issues TEXT,
                crash_warnings TEXT,
                date_imported TEXT
            )
        ''')

        # Upgrade existing database if needed
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN title TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN detection_confidence TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN detection_method TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN validation_status TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN validation_issues TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN validation_warnings TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN cb_from_gcode REAL")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN ob_from_gcode REAL")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN bore_warnings TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN dimensional_issues TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN thickness_display TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN lathe TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN feasibility_status TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN feasibility_issues TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN feasibility_warnings TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN crash_issues TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN crash_warnings TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN duplicate_type TEXT")  # 'SOLID', 'NAME_COLLISION', 'CONTENT_DUP', NULL
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN parent_file TEXT")  # Reference to parent program_number
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN duplicate_group TEXT")  # Group ID for related duplicates
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN current_version INTEGER DEFAULT 1")  # Current version number
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN modified_by TEXT")  # Last user who modified
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN is_managed INTEGER DEFAULT 0")  # 1 if in repository, 0 if external
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN round_size REAL")  # Detected round size (e.g., 6.25, 10.5)
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN round_size_confidence TEXT")  # 'HIGH', 'MEDIUM', 'LOW', 'NONE'
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN round_size_source TEXT")  # 'TITLE', 'GCODE', 'DIMENSION', 'MANUAL'
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN in_correct_range INTEGER DEFAULT 1")  # 1 if program number matches round size range
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN legacy_names TEXT")  # JSON array of previous program numbers
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN last_renamed_date TEXT")  # ISO timestamp of last rename
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN rename_reason TEXT")  # Why it was renamed
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tools_used TEXT")  # JSON list of tool numbers (e.g., ["T101", "T121", "T202"])
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tool_sequence TEXT")  # JSON ordered list of tools in sequence
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tool_validation_status TEXT")  # 'PASS', 'WARNING', 'ERROR'
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tool_validation_issues TEXT")  # JSON list of tool issues
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN safety_blocks_status TEXT")  # 'PASS', 'WARNING', 'MISSING'
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN safety_blocks_issues TEXT")  # JSON list of missing safety blocks
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN content_hash TEXT")  # SHA256 hash for duplicate detection
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tool_home_status TEXT")  # 'PASS', 'WARNING', 'CRITICAL', 'N/A', 'UNKNOWN'
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN tool_home_issues TEXT")  # JSON list of G53 Z position issues
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN hub_height_display TEXT")  # Display format for hub height (e.g., "1.5")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN counter_bore_depth_display TEXT")  # Display format for counter bore depth
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN date_imported TEXT")  # ISO timestamp when file was imported to database
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN is_deleted INTEGER DEFAULT 0")  # 1 if soft-deleted, 0 if active
        except:
            pass
        try:
            cursor.execute("ALTER TABLE programs ADD COLUMN deleted_date TEXT")  # ISO timestamp when record was soft-deleted
        except:
            pass

        # Create users table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password_hash TEXT,
                password_salt TEXT,
                full_name TEXT,
                role TEXT DEFAULT 'viewer',
                email TEXT,
                date_created TEXT,
                last_login TEXT,
                is_active INTEGER DEFAULT 1,
                must_change_password INTEGER DEFAULT 0,
                failed_login_attempts INTEGER DEFAULT 0,
                locked_until TEXT
            )
        ''')

        # Add new columns to existing users table
        try:
            cursor.execute("ALTER TABLE users ADD COLUMN password_salt TEXT")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE users ADD COLUMN must_change_password INTEGER DEFAULT 0")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE users ADD COLUMN failed_login_attempts INTEGER DEFAULT 0")
        except:
            pass
        try:
            cursor.execute("ALTER TABLE users ADD COLUMN locked_until TEXT")
        except:
            pass

        # Create default admin user if no users exist (password: admin123 - must be changed on first login)
        cursor.execute("SELECT COUNT(*) FROM users")
        if cursor.fetchone()[0] == 0:
            default_password = "admin123"
            pw_hash, pw_salt = hash_password(default_password)
            cursor.execute("""
                INSERT INTO users (username, password_hash, password_salt, full_name, role, date_created, is_active, must_change_password)
                VALUES ('admin', ?, ?, 'Administrator', 'admin', ?, 1, 1)
            """, (pw_hash, pw_salt, datetime.now().isoformat()))
        else:
            # Fix existing admin user if password not set (migration from old version)
            cursor.execute("SELECT password_hash, password_salt FROM users WHERE username = 'admin'")
            admin_row = cursor.fetchone()
            if admin_row and (admin_row[0] is None or admin_row[1] is None):
                default_password = "admin123"
                pw_hash, pw_salt = hash_password(default_password)
                cursor.execute("""
                    UPDATE users SET password_hash = ?, password_salt = ?, must_change_password = 1
                    WHERE username = 'admin'
                """, (pw_hash, pw_salt))

        # Create program_versions table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS program_versions (
                version_id INTEGER PRIMARY KEY AUTOINCREMENT,
                program_number TEXT NOT NULL,
                version_number TEXT NOT NULL,
                version_tag TEXT,
                file_content TEXT,
                file_hash TEXT,
                file_path TEXT,
                date_created TEXT,
                created_by TEXT,
                change_summary TEXT,
                dimensions_snapshot TEXT,
                FOREIGN KEY (program_number) REFERENCES programs(program_number)
            )
        ''')

        # Add file_path column to existing program_versions table
        try:
            cursor.execute("ALTER TABLE program_versions ADD COLUMN file_path TEXT")
        except:
            pass

        # Create activity_log table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS activity_log (
                log_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                username TEXT,
                action_type TEXT,
                program_number TEXT,
                details TEXT,
                timestamp TEXT,
                FOREIGN KEY (user_id) REFERENCES users(user_id)
            )
        ''')

        # Create edit_locks table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS edit_locks (
                lock_id INTEGER PRIMARY KEY AUTOINCREMENT,
                program_number TEXT UNIQUE,
                locked_by INTEGER,
                locked_by_username TEXT,
                locked_at TEXT,
                FOREIGN KEY (locked_by) REFERENCES users(user_id)
            )
        ''')

        # Create comments table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS comments (
                comment_id INTEGER PRIMARY KEY AUTOINCREMENT,
                program_number TEXT,
                version_id INTEGER,
                user_id INTEGER,
                username TEXT,
                comment_text TEXT,
                parent_comment_id INTEGER,
                timestamp TEXT,
                FOREIGN KEY (user_id) REFERENCES users(user_id),
                FOREIGN KEY (version_id) REFERENCES program_versions(version_id)
            )
        ''')

        # Create production_tracking table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS production_tracking (
                track_id INTEGER PRIMARY KEY AUTOINCREMENT,
                program_number TEXT,
                version_id INTEGER,
                production_status TEXT,
                run_count INTEGER DEFAULT 0,
                last_used TEXT,
                quality_notes TEXT,
                operator TEXT,
                FOREIGN KEY (version_id) REFERENCES program_versions(version_id)
            )
        ''')

        # Create program_number_registry table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS program_number_registry (
                program_number TEXT PRIMARY KEY,
                round_size REAL,
                range_start INTEGER,
                range_end INTEGER,
                status TEXT DEFAULT 'AVAILABLE',
                file_path TEXT,
                duplicate_count INTEGER DEFAULT 0,
                last_checked TEXT,
                notes TEXT
            )
        ''')

        # Create duplicate_resolutions table for tracking resolution history
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS duplicate_resolutions (
                resolution_id INTEGER PRIMARY KEY AUTOINCREMENT,
                resolution_date TEXT,
                duplicate_type TEXT,
                program_numbers TEXT,
                action_taken TEXT,
                files_affected TEXT,
                old_values TEXT,
                new_values TEXT,
                user_override INTEGER DEFAULT 0,
                notes TEXT
            )
        ''')

        # Create archive_metadata table for tracking archived versions
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS archive_metadata (
                archive_id INTEGER PRIMARY KEY AUTOINCREMENT,
                program_number TEXT NOT NULL,
                version_number INTEGER NOT NULL,
                file_path TEXT NOT NULL,
                date_archived TEXT NOT NULL,
                archived_by TEXT,
                archive_reason TEXT,
                change_summary TEXT,
                file_size INTEGER,
                file_hash TEXT,
                is_compressed INTEGER DEFAULT 0,
                compressed_date TEXT,
                outer_diameter REAL,
                thickness REAL,
                center_bore REAL,
                metadata_source TEXT,
                metadata_confidence INTEGER,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(program_number, version_number, file_path)
            )
        ''')

        # =============================================================
        # USB SYNC MANAGER TABLES
        # =============================================================
        # Track sync status between repository and USB drives

        # USB Sync Tracking - sync status for each program on each drive
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS usb_sync_tracking (
                sync_id INTEGER PRIMARY KEY AUTOINCREMENT,
                drive_label TEXT NOT NULL,
                drive_path TEXT NOT NULL,
                program_number TEXT NOT NULL,
                last_sync_date TEXT,
                last_sync_direction TEXT,
                repo_hash TEXT,
                usb_hash TEXT,
                repo_modified TEXT,
                usb_modified TEXT,
                sync_status TEXT,
                notes TEXT,
                UNIQUE(drive_label, program_number)
            )
        ''')

        # USB Drives - registered drives and their metadata
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS usb_drives (
                drive_id INTEGER PRIMARY KEY AUTOINCREMENT,
                drive_label TEXT UNIQUE NOT NULL,
                drive_serial TEXT,
                last_seen_path TEXT,
                last_scan_date TEXT,
                total_programs INTEGER DEFAULT 0,
                in_sync_count INTEGER DEFAULT 0,
                notes TEXT
            )
        ''')

        # Sync History - audit trail of all sync operations
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sync_history (
                history_id INTEGER PRIMARY KEY AUTOINCREMENT,
                sync_date TEXT NOT NULL,
                drive_label TEXT NOT NULL,
                program_number TEXT NOT NULL,
                action TEXT NOT NULL,
                username TEXT,
                files_affected INTEGER DEFAULT 1,
                repo_hash_before TEXT,
                repo_hash_after TEXT,
                details TEXT
            )
        ''')

        # =============================================================
        # DATABASE INDEXES FOR PERFORMANCE
        # =============================================================
        # These indexes significantly speed up filtering and searching
        # CREATE INDEX IF NOT EXISTS prevents errors on existing DBs

        # Spacer type - used for type filtering
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_spacer_type ON programs(spacer_type)')

        # Validation status - used for status filtering
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_validation_status ON programs(validation_status)')

        # Outer diameter - used for OD range filtering
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_outer_diameter ON programs(outer_diameter)')

        # Round size - used for round size filtering and grouping
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_round_size ON programs(round_size)')

        # Is managed - used to separate repository vs external files
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_is_managed ON programs(is_managed)')

        # Material - used for material filtering
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_material ON programs(material)')

        # Duplicate type - used for duplicate filtering
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_duplicate_type ON programs(duplicate_type)')

        # Content hash - used for duplicate detection
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_content_hash ON programs(content_hash)')

        # File path - used for file lookup
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_file_path ON programs(file_path)')

        # Composite index for common filter combinations
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_type_status ON programs(spacer_type, validation_status)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_od_type ON programs(outer_diameter, spacer_type)')

        # Archive metadata indexes for performance
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_archive_meta_program ON archive_metadata(program_number, version_number DESC)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_archive_meta_date ON archive_metadata(date_archived DESC)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_archive_meta_compressed ON archive_metadata(is_compressed, date_archived)')

        # USB Sync indexes for performance
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usb_sync_drive ON usb_sync_tracking(drive_label)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usb_sync_program ON usb_sync_tracking(program_number)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usb_sync_status ON usb_sync_tracking(sync_status)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_usb_sync_composite ON usb_sync_tracking(drive_label, sync_status)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_sync_history_drive ON sync_history(drive_label, sync_date DESC)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_sync_history_program ON sync_history(program_number, sync_date DESC)')

        conn.commit()
        conn.close()

    @staticmethod
    def format_program_number(number):
        """
        Format a program number with proper leading zeros.

        Args:
            number: Integer or string program number (with or without 'o' prefix)

        Returns:
            str: Formatted program number (e.g., 'o00001', 'o01000', 'o12345')

        Examples:
            format_program_number(1) -> 'o00001'
            format_program_number(100) -> 'o00100'
            format_program_number('o1000') -> 'o01000'
            format_program_number('1000') -> 'o01000'
        """
        # Convert to string and remove any 'o' or 'O' prefix
        num_str = str(number).replace('o', '').replace('O', '')

        # Convert to integer and back to string (removes leading zeros if any)
        try:
            num_int = int(num_str)
            # Format with leading zeros (5 digits total)
            return f"o{num_int:05d}"
        except ValueError:
            # If conversion fails, return as-is with 'o' prefix
            return f"o{num_str}"

    def init_repository(self):
        """Initialize managed file repository structure"""
        # Get base path (where this script is located)
        base_path = os.path.dirname(os.path.abspath(__file__))

        # Define repository paths
        self.repository_path = os.path.join(base_path, 'repository')
        self.revised_repository_path = os.path.join(base_path, 'revised_repository')
        self.versions_path = os.path.join(base_path, 'versions')
        self.backups_path = os.path.join(base_path, 'backups')
        self.deleted_path = os.path.join(base_path, 'deleted')

        # Create directories if they don't exist
        os.makedirs(self.repository_path, exist_ok=True)
        os.makedirs(self.revised_repository_path, exist_ok=True)
        os.makedirs(self.versions_path, exist_ok=True)
        os.makedirs(self.backups_path, exist_ok=True)
        os.makedirs(self.deleted_path, exist_ok=True)

        logger.info(f"Repository initialized at: {self.repository_path}")
        logger.info(f"Revised Repository initialized at: {self.revised_repository_path}")
        logger.debug(f"Versions path: {self.versions_path}")
        logger.debug(f"Backups path: {self.backups_path}")
        logger.debug(f"Deleted path: {self.deleted_path}")

    def is_managed_file(self, file_path):
        """Check if a file is in the managed repository (either main or revised)"""
        if not file_path:
            return False
        abs_path = os.path.abspath(file_path)
        repo_path = os.path.abspath(self.repository_path)
        revised_repo_path = os.path.abspath(self.revised_repository_path)
        return abs_path.startswith(repo_path) or abs_path.startswith(revised_repo_path)

    def is_in_revised_repository(self, file_path):
        """Check if a file is in the revised repository"""
        if not file_path:
            return False
        abs_path = os.path.abspath(file_path)
        revised_repo_path = os.path.abspath(self.revised_repository_path)
        return abs_path.startswith(revised_repo_path)

    def is_in_main_repository(self, file_path):
        """Check if a file is in the main repository (not revised)"""
        if not file_path:
            return False
        abs_path = os.path.abspath(file_path)
        repo_path = os.path.abspath(self.repository_path)
        revised_repo_path = os.path.abspath(self.revised_repository_path)
        return abs_path.startswith(repo_path) and not abs_path.startswith(revised_repo_path)

    def import_to_repository(self, source_file, program_number=None):
        """
        Import a file into the managed repository with automatic archiving.
        New file keeps standard name, old file gets version suffix and moves to archive.

        Returns the new path in the repository.
        """
        try:
            # Initialize repository manager if not already done
            if not hasattr(self, 'repo_manager'):
                from repository_manager import RepositoryManager
                self.repo_manager = RepositoryManager(self.db_path, self.repository_path)

            # If already in repository, return as-is
            if self.is_managed_file(source_file):
                return source_file

            # Extract program number if not provided
            if not program_number:
                filename = os.path.basename(source_file)
                program_number = os.path.splitext(filename)[0].lower()

            # Use repository manager's import with archive
            # This handles: archiving old version, importing new file with standard name
            dest_path = self.repo_manager.import_with_archive(source_file, program_number)

            if dest_path:
                return dest_path

            # Fallback to old behavior if repo manager fails
            logger.warning("Archive system failed, using legacy import")

            filename = os.path.basename(source_file)
            dest_path = os.path.join(self.repository_path, filename)

            # If file already exists, handle collision
            if os.path.exists(dest_path):
                # Check if it's the same file (same content)
                with open(source_file, 'rb') as f1:
                    source_content = f1.read()
                with open(dest_path, 'rb') as f2:
                    dest_content = f2.read()

                if source_content == dest_content:
                    # Same file, just return existing path
                    logger.debug(f"File already exists (identical): {filename}")
                    return dest_path
                else:
                    # Different file with same name - create unique name
                    base, ext = os.path.splitext(filename)
                    counter = 1
                    while os.path.exists(dest_path):
                        dest_path = os.path.join(self.repository_path, f"{base}_{counter}{ext}")
                        counter += 1
                    logger.info(f"Name collision detected, using: {os.path.basename(dest_path)}")

            # Copy file to repository
            shutil.copy2(source_file, dest_path)
            logger.info(f"Imported to repository: {filename}")

            return dest_path

        except OSError as e:
            logger.error(f"File operation error importing {source_file}: {e}", exc_info=True)
            return None
        except Exception as e:
            logger.error(f"Error importing file to repository: {e}", exc_info=True)
            return None

    def create_version_file(self, program_number, version_number, source_file_path):
        """
        Save a version as a physical file in the versions folder.
        Returns the path to the version file.
        """
        try:
            # Create version folder for this program
            version_folder = os.path.join(self.versions_path, program_number)
            os.makedirs(version_folder, exist_ok=True)

            # Get file extension
            ext = os.path.splitext(source_file_path)[1] or '.nc'

            # Version filename
            version_filename = f"{version_number}{ext}"
            version_path = os.path.join(version_folder, version_filename)

            # Copy file to version folder
            if os.path.exists(source_file_path):
                shutil.copy2(source_file_path, version_path)
                logger.debug(f"Saved version file: {version_filename}")
                return version_path
            else:
                logger.warning(f"Source file not found for version: {source_file_path}")
                return None

        except OSError as e:
            logger.error(f"File operation error creating version: {e}")
            return None
        except Exception as e:
            logger.error(f"Error creating version file: {e}", exc_info=True)
            return None

    def get_version_file_path(self, program_number, version_number):
        """Get the file path for a specific version"""
        version_folder = os.path.join(self.versions_path, program_number)

        if not os.path.exists(version_folder):
            return None

        # Try common extensions
        for ext in ['.nc', '.gcode', '.txt', '']:
            version_path = os.path.join(version_folder, f"{version_number}{ext}")
            if os.path.exists(version_path):
                return version_path

        return None

    def migrate_file_to_repository(self, program_number):
        """
        Migrate a single file from external location to managed repository.
        Returns True if successful, False otherwise.
        """
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get current file path and managed status
            cursor.execute("SELECT file_path, is_managed FROM programs WHERE program_number = ?", (program_number,))
            result = cursor.fetchone()

            if not result:
                conn.close()
                return False

            current_path, is_managed = result

            # Already managed
            if is_managed:
                logger.debug(f"Migration skipped - {program_number} already in repository")
                conn.close()
                return True

            # Check if file exists
            if not current_path or not os.path.exists(current_path):
                logger.warning(f"Migration failed - file not found: {current_path}")
                conn.close()
                return False

            # Import to repository
            new_path = self.import_to_repository(current_path, program_number)

            if new_path:
                # Update database
                cursor.execute("""
                    UPDATE programs SET file_path = ?, is_managed = 1 WHERE program_number = ?
                """, (new_path, program_number))

                conn.commit()
                logger.info(f"Successfully migrated {program_number} to repository")

                # Log activity
                self.log_activity('migrate_to_repository', program_number, {
                    'old_path': current_path,
                    'new_path': new_path
                })

                conn.close()
                return True
            else:
                conn.close()
                return False

        except sqlite3.Error as e:
            logger.error(f"Database error migrating {program_number}: {e}")
            return False
        except Exception as e:
            logger.error(f"Error migrating {program_number}: {e}", exc_info=True)
            return False

    def migrate_all_to_repository(self):
        """
        Migrate all external files to the managed repository.
        Returns (success_count, error_count)
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Get all programs with external files
        cursor.execute("""
            SELECT program_number FROM programs
            WHERE file_path IS NOT NULL AND (is_managed IS NULL OR is_managed = 0)
        """)

        programs = [row[0] for row in cursor.fetchall()]
        conn.close()

        logger.info(f"Found {len(programs)} external files to migrate")

        success = 0
        errors = 0

        for prog_num in programs:
            if self.migrate_file_to_repository(prog_num):
                success += 1
            else:
                errors += 1

        logger.info(f"Migration complete: {success} successful, {errors} errors")
        return success, errors

    def get_repository_stats(self):
        """Get statistics about repository usage"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        stats = {}

        # Total programs
        cursor.execute("SELECT COUNT(*) FROM programs WHERE file_path IS NOT NULL")
        stats['total_programs'] = cursor.fetchone()[0]

        # Managed files
        cursor.execute("SELECT COUNT(*) FROM programs WHERE is_managed = 1")
        stats['managed_files'] = cursor.fetchone()[0]

        # External files
        stats['external_files'] = stats['total_programs'] - stats['managed_files']

        # Total versions
        cursor.execute("SELECT COUNT(*) FROM program_versions")
        stats['total_versions'] = cursor.fetchone()[0]

        # Repository size
        repo_size = 0
        if os.path.exists(self.repository_path):
            for file in os.listdir(self.repository_path):
                file_path = os.path.join(self.repository_path, file)
                if os.path.isfile(file_path):
                    repo_size += os.path.getsize(file_path)

        stats['repository_size_mb'] = repo_size / (1024 * 1024)

        # Versions size
        versions_size = 0
        if os.path.exists(self.versions_path):
            for root, _, files in os.walk(self.versions_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    versions_size += os.path.getsize(file_path)

        stats['versions_size_mb'] = versions_size / (1024 * 1024)

        conn.close()
        return stats

    def log_activity(self, action_type, program_number=None, details=None):
        """Log user activity to the activity_log table"""
        try:
            # Use timeout to prevent database locked errors
            conn = sqlite3.connect(self.db_path, timeout=10.0)
            cursor = conn.cursor()

            from datetime import datetime
            timestamp = datetime.now().isoformat()

            # Convert details to JSON if it's a dict
            if isinstance(details, dict):
                import json
                details = json.dumps(details)

            cursor.execute("""
                INSERT INTO activity_log (user_id, username, action_type, program_number, details, timestamp)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (self.current_user_id, self.current_username, action_type, program_number, details, timestamp))

            conn.commit()
            conn.close()
        except sqlite3.OperationalError as e:
            if "locked" in str(e).lower():
                logger.debug(f"Database temporarily locked, activity not logged: {action_type}")
            else:
                logger.warning(f"Database error logging activity: {e}")
        except Exception as e:
            logger.warning(f"Error logging activity: {e}")

    def _check_database_safety_before_write(self, operation_name="operation"):
        """
        Check database safety before performing write operation (Phase 1 Safety Checker)

        Returns:
            tuple: (safe_to_proceed: bool, warning_level: str, message: str)
        """
        if not hasattr(self, 'safety_checker'):
            return (True, 'none', '')

        if not self.config.get('safety_checks_enabled', True):
            return (True, 'none', '')

        try:
            # Check for conflicts
            conflict_check = self.safety_checker.check_for_conflicts()
            level = conflict_check['warning_level']

            if level in ['none', 'low']:
                return (True, level, conflict_check.get('message', ''))

            elif level == 'medium':
                # Show warning, allow user to proceed or cancel
                response = messagebox.askyesno(
                    "Database Safety Warning",
                    f"{conflict_check.get('message', 'Database may have been modified')}\n\n"
                    f"A backup will be created automatically.\n\n"
                    f"Do you want to proceed with this operation?",
                    icon='warning'
                )
                return (response, level, conflict_check.get('message', ''))

            elif level == 'high':
                # Strong warning with explicit confirmation
                response = messagebox.askyesno(
                    "⚠️ HIGH RISK: Database Conflict Detected",
                    f"{conflict_check.get('message', 'Database conflict detected!')}\n\n"
                    f"⚠️ WARNING: This operation may cause data loss!\n\n"
                    f"Recommendations:\n"
                    f"1. Create a manual backup first\n"
                    f"2. Coordinate with other users\n"
                    f"3. Consider canceling and investigating\n\n"
                    f"Continue anyway? (NOT RECOMMENDED)",
                    icon='error'
                )
                return (response, level, conflict_check.get('message', ''))

            return (False, 'critical', 'Unknown error')

        except Exception as e:
            logger.error(f"Safety check failed: {e}")
            # On error, allow operation to proceed (fail-safe)
            return (True, 'none', '')

    def _record_database_write(self, operation_name):
        """Record successful database write (Phase 1 Safety Checker)"""
        if hasattr(self, 'safety_checker') and self.config.get('safety_checks_enabled', True):
            try:
                self.safety_checker.record_write()
                # Also update access time to prevent false positives from our own writes
                self.safety_checker.record_access()
                self.log_activity('database_write', details={'operation': operation_name})
            except Exception as e:
                logger.warning(f"Failed to record database write: {e}")

    def create_version(self, program_number, change_summary=None):
        """Create a new version of a program"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get current program data
            cursor.execute("SELECT file_path, current_version FROM programs WHERE program_number = ?", (program_number,))
            result = cursor.fetchone()

            if not result:
                conn.close()
                return None

            file_path, current_version = result

            if not file_path or not os.path.exists(file_path):
                conn.close()
                return None

            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Calculate file hash
            import hashlib
            file_hash = hashlib.sha256(content.encode()).hexdigest()

            # Get dimensions snapshot
            cursor.execute("""
                SELECT outer_diameter, thickness, center_bore, hub_height, hub_diameter,
                       counter_bore_diameter, material, spacer_type
                FROM programs WHERE program_number = ?
            """, (program_number,))
            dims = cursor.fetchone()

            import json
            dimensions_snapshot = json.dumps({
                'outer_diameter': dims[0],
                'thickness': dims[1],
                'center_bore': dims[2],
                'hub_height': dims[3],
                'hub_diameter': dims[4],
                'counter_bore_diameter': dims[5],
                'material': dims[6],
                'spacer_type': dims[7]
            }) if dims else None

            # Increment version
            new_version = (current_version or 0) + 1
            version_number = f"v{new_version}.0"

            # Create version file (save physical copy)
            version_file_path = self.create_version_file(program_number, version_number, file_path)

            # Create version record
            from datetime import datetime
            cursor.execute("""
                INSERT INTO program_versions (
                    program_number, version_number, file_content, file_hash, file_path,
                    date_created, created_by, change_summary, dimensions_snapshot
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (program_number, version_number, content, file_hash, version_file_path,
                  datetime.now().isoformat(), self.current_username, change_summary, dimensions_snapshot))

            version_id = cursor.lastrowid

            # Update program's current version
            cursor.execute("""
                UPDATE programs SET current_version = ?, modified_by = ? WHERE program_number = ?
            """, (new_version, self.current_username, program_number))

            conn.commit()
            conn.close()

            # Log activity
            self.log_activity('create_version', program_number, {
                'version_number': version_number,
                'change_summary': change_summary,
                'version_file': version_file_path
            })

            return version_id

        except sqlite3.Error as e:
            logger.error(f"Database error creating version for {program_number}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error creating version: {e}", exc_info=True)
            return None

    def get_version_history(self, program_number):
        """Get all versions of a program"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT version_id, version_number, version_tag, date_created,
                       created_by, change_summary
                FROM program_versions
                WHERE program_number = ?
                ORDER BY date_created DESC
            """, (program_number,))

            versions = cursor.fetchall()
            conn.close()

            return versions

        except sqlite3.Error as e:
            logger.error(f"Database error getting version history for {program_number}: {e}")
            return []
        except Exception as e:
            logger.error(f"Error getting version history: {e}", exc_info=True)
            return []

    def compare_versions(self, version_id1, version_id2):
        """Compare two versions of a program"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("SELECT file_content, version_number FROM program_versions WHERE version_id = ?", (version_id1,))
            v1 = cursor.fetchone()

            cursor.execute("SELECT file_content, version_number FROM program_versions WHERE version_id = ?", (version_id2,))
            v2 = cursor.fetchone()

            conn.close()

            if not v1 or not v2:
                return None

            return {
                'version1': {'content': v1[0], 'version_number': v1[1]},
                'version2': {'content': v2[0], 'version_number': v2[1]}
            }

        except sqlite3.Error as e:
            logger.error(f"Database error comparing versions: {e}")
            return None
        except Exception as e:
            logger.error(f"Error comparing versions: {e}", exc_info=True)
            return None

    def get_unified_version_history(self, program_number):
        """
        Get versions from both archive/ (file-based) and program_versions (database).
        Returns a unified list of all versions with metadata from both sources.

        Returns:
            List of dictionaries with keys:
            - source: 'database' or 'archive'
            - version_number: Version number
            - date_created: Date created/archived
            - created_by: User who created/archived
            - change_summary: Summary of changes
            - file_size: File size (archive only)
            - is_compressed: Boolean (archive only)
            - metadata_quality: 'full', 'extracted', or 'inferred'
        """
        versions = []

        # Get DB versions from program_versions table
        try:
            db_versions = self.get_version_history(program_number)
            for v in db_versions:
                versions.append({
                    'source': 'database',
                    'version_number': v[1] if len(v) > 1 else None,
                    'date_created': v[3] if len(v) > 3 else None,
                    'created_by': v[4] if len(v) > 4 else None,
                    'change_summary': v[5] if len(v) > 5 else None,
                    'file_size': None,
                    'is_compressed': False,
                    'metadata_quality': 'full'
                })
        except Exception as e:
            logger.error(f"Error getting database versions for {program_number}: {e}")

        # Get archive versions from archive_metadata table
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT version_number, date_archived, archived_by, change_summary,
                       file_size, is_compressed, metadata_source
                FROM archive_metadata
                WHERE program_number = ?
                ORDER BY version_number DESC
            """, (program_number,))

            for row in cursor.fetchall():
                versions.append({
                    'source': 'archive',
                    'version_number': row[0],
                    'date_created': row[1],
                    'created_by': row[2],
                    'change_summary': row[3],
                    'file_size': row[4],
                    'is_compressed': bool(row[5]),
                    'metadata_quality': row[6] if row[6] else 'extracted'
                })

            conn.close()

        except sqlite3.Error as e:
            logger.error(f"Database error getting archive versions for {program_number}: {e}")
        except Exception as e:
            logger.error(f"Error getting archive versions: {e}", exc_info=True)

        # Sort by version number descending
        versions.sort(key=lambda x: x['version_number'] if x['version_number'] else 0, reverse=True)

        return versions

    def run_archive_metadata_migration(self, progress_callback=None):
        """
        One-time migration to populate metadata for all existing archive files.
        This scans all archive folders and extracts metadata for files that don't have it yet.

        Args:
            progress_callback: Optional callback function(current, total, message) for progress updates

        Returns:
            dict: Statistics about the migration (total_files, success, errors, skipped)
        """
        try:
            from utils.archive_metadata_manager import ArchiveMetadataManager
            from pathlib import Path

            # Get archive path
            repo_path = Path(self.repository_path)
            archive_path = repo_path.parent / 'archive'

            if not archive_path.exists():
                return {
                    'total_files': 0,
                    'success': 0,
                    'errors': 0,
                    'skipped': 0,
                    'message': 'Archive folder not found'
                }

            # Create metadata manager
            metadata_manager = ArchiveMetadataManager(self.db_path, str(archive_path))

            # Callback wrapper for ArchiveMetadataManager
            def wrapped_callback(count):
                if progress_callback:
                    progress_callback(count, count, f"Processed {count} files...")

            # Run bulk scan
            total_processed = metadata_manager.bulk_scan_archives(progress_callback=wrapped_callback)

            # Get final statistics
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("SELECT COUNT(*) FROM archive_metadata")
            total_metadata = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(DISTINCT program_number) FROM archive_metadata")
            unique_programs = cursor.fetchone()[0]

            conn.close()

            stats = {
                'total_files': total_processed,
                'success': total_processed,
                'errors': 0,
                'skipped': 0,
                'total_metadata': total_metadata,
                'unique_programs': unique_programs,
                'message': f'Successfully processed {total_processed} archive files'
            }

            logger.info(f"Archive metadata migration completed: {stats}")
            return stats

        except Exception as e:
            logger.error(f"Error during archive metadata migration: {e}", exc_info=True)
            return {
                'total_files': 0,
                'success': 0,
                'errors': 1,
                'skipped': 0,
                'message': f'Migration failed: {str(e)}'
            }

    def show_archive_migration_dialog(self):
        """Show dialog to run archive metadata migration"""
        # Create dialog window
        dialog = tk.Toplevel(self.root)
        dialog.title("Archive Metadata Migration")
        dialog.geometry("600x400")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)
        dialog.geometry(f"+{x}+{y}")

        # Title
        tk.Label(dialog,
                text="Archive Metadata Migration",
                font=("Arial", 14, "bold"),
                bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Info text
        info_frame = tk.Frame(dialog, bg=self.bg_color)
        info_frame.pack(fill=tk.X, padx=20, pady=10)

        info_text = (
            "This migration will scan all existing archive files and extract metadata.\n\n"
            "What will be extracted:\n"
            "  • File size and hash\n"
            "  • Archive date from folder structure\n"
            "  • Dimensions (OD, thickness, CB)\n"
            "  • Version numbers\n\n"
            "This is a one-time operation and may take several minutes.\n"
            "The application will remain responsive during the migration."
        )

        tk.Label(info_frame,
                text=info_text,
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9),
                justify=tk.LEFT).pack(anchor=tk.W)

        # Progress frame
        progress_frame = tk.Frame(dialog, bg=self.bg_color)
        progress_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_label = tk.Label(progress_frame,
                                 text="Ready to start migration...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 9))
        progress_label.pack(pady=5)

        # Progress bar
        progress_bar = ttk.Progressbar(progress_frame, mode='indeterminate')
        progress_bar.pack(fill=tk.X, pady=5)

        # Results text
        results_text = scrolledtext.ScrolledText(progress_frame,
                                                height=6,
                                                bg=self.input_bg,
                                                fg=self.fg_color,
                                                font=("Courier New", 9))
        results_text.pack(fill=tk.BOTH, expand=True, pady=5)

        # Button frame
        button_frame = tk.Frame(dialog, bg=self.bg_color)
        button_frame.pack(fill=tk.X, padx=20, pady=10)

        start_button = tk.Button(button_frame,
                                text="Start Migration",
                                bg=self.accent_color,
                                fg=self.fg_color,
                                font=("Arial", 10, "bold"),
                                width=15)
        start_button.pack(side=tk.LEFT, padx=5)

        close_button = tk.Button(button_frame,
                                text="Close",
                                command=dialog.destroy,
                                bg=self.button_bg,
                                fg=self.fg_color,
                                font=("Arial", 10),
                                width=15)
        close_button.pack(side=tk.RIGHT, padx=5)

        def run_migration():
            """Run the migration in the background"""
            start_button.config(state=tk.DISABLED)
            progress_bar.start(10)
            results_text.delete('1.0', tk.END)
            results_text.insert(tk.END, "Starting migration...\n")

            def progress_update(current, total, message):
                progress_label.config(text=message)
                results_text.insert(tk.END, f"{message}\n")
                results_text.see(tk.END)
                dialog.update()

            def do_migration():
                try:
                    stats = self.run_archive_metadata_migration(progress_callback=progress_update)

                    # Update UI with results
                    progress_bar.stop()
                    progress_label.config(text="Migration completed!")

                    results_text.insert(tk.END, "\n" + "=" * 50 + "\n")
                    results_text.insert(tk.END, "MIGRATION COMPLETE\n")
                    results_text.insert(tk.END, "=" * 50 + "\n")
                    results_text.insert(tk.END, f"Total files processed: {stats['total_files']}\n")
                    results_text.insert(tk.END, f"Successful: {stats['success']}\n")
                    if stats.get('unique_programs'):
                        results_text.insert(tk.END, f"Unique programs: {stats['unique_programs']}\n")
                    if stats.get('errors', 0) > 0:
                        results_text.insert(tk.END, f"Errors: {stats['errors']}\n")
                    results_text.insert(tk.END, f"\n{stats['message']}\n")
                    results_text.see(tk.END)

                    start_button.config(state=tk.NORMAL)
                    messagebox.showinfo("Migration Complete",
                                       f"Successfully processed {stats['total_files']} archive files!")

                except Exception as e:
                    progress_bar.stop()
                    progress_label.config(text="Migration failed!")
                    results_text.insert(tk.END, f"\nERROR: {str(e)}\n")
                    results_text.see(tk.END)
                    start_button.config(state=tk.NORMAL)
                    messagebox.showerror("Migration Failed", f"Error: {str(e)}")

            # Run in thread to keep UI responsive
            import threading
            thread = threading.Thread(target=do_migration, daemon=True)
            thread.start()

        start_button.config(command=run_migration)

        dialog.wait_window()

    def open_usb_sync_window(self):
        """Open USB Sync Manager window"""
        try:
            from gui.usb_sync_gui import USBSyncGUI

            # Create USB sync window
            usb_sync_gui = USBSyncGUI(
                parent=self.root,
                db_path=self.db_path,
                repository_path=self.repository_path
            )

        except ImportError as e:
            messagebox.showerror(
                "Import Error",
                f"Failed to import USB Sync Manager:\n{str(e)}\n\n"
                "Please ensure usb_sync_gui.py and usb_sync_manager.py are present."
            )
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"Failed to open USB Sync Manager:\n{str(e)}"
            )

    def open_archived_files_browser(self):
        """Open Archived/Deleted Files Browser"""
        try:
            from gui.archived_files_browser import ArchivedFilesBrowser

            # Create browser window
            browser = ArchivedFilesBrowser(
                parent=self.root,
                db_path=self.db_path,
                repository_path=self.repository_path,
                on_restore_callback=lambda: self.refresh_results()
            )

        except ImportError as e:
            messagebox.showerror(
                "Import Error",
                f"Failed to import Archived Files Browser:\n{str(e)}\n\n"
                "Please ensure archived_files_browser.py is present."
            )
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"Failed to open Archived Files Browser:\n{str(e)}"
            )

    # ==================== ROUND SIZE DETECTION & RANGE MANAGEMENT ====================

    def get_round_size_ranges(self):
        """Return dictionary of round size to program number ranges (all 5-digit: o10000-o99999)"""
        return {
            5.75:  (57500, 59999, "5.75"),
            6.0:   (60000, 62499, "6.0"),
            6.25:  (62500, 64999, "6.25"),
            6.5:   (65000, 69999, "6.5"),
            7.0:   (70000, 74999, "7.0"),
            7.5:   (75000, 79999, "7.5"),
            8.0:   (80000, 84999, "8.0"),
            8.5:   (85000, 89999, "8.5"),
            9.5:   (95000, 99999, "9.5"),
            10.0:  (10000, 10999, "10.0"),
            10.25: (11000, 11999, "10.25"),
            10.50: (12000, 12999, "10.50"),
            13.0:  (13000, 13999, "13.0"),
            # Free ranges (use when specific range is full)
            0.0:   (14000, 49999, "Free Range 1"),
            -1.0:  (50000, 57499, "Free Range 2")
        }

    def get_range_for_round_size(self, round_size):
        """Get program number range for a round size"""
        # Handle None or invalid round_size
        if round_size is None:
            return None

        ranges = self.get_round_size_ranges()

        # Exact match
        if round_size in ranges:
            return ranges[round_size][:2]  # Return (start, end)

        # Find closest match (for slight variations like 6.24 → 6.25)
        # Only consider positive round sizes (exclude free ranges)
        positive_ranges = {k: v for k, v in ranges.items() if k > 0}

        if not positive_ranges:
            return None

        closest_size = min(positive_ranges.keys(), key=lambda x: abs(x - round_size))

        # Tight tolerance for very close matches (6.24 → 6.25)
        tight_tolerance = 0.1
        if abs(closest_size - round_size) <= tight_tolerance:
            return ranges[closest_size][:2]

        # Smart fallback for orphaned round sizes (like 5.0, 5.5, etc.)
        # Use a more generous tolerance to find the nearest logical range
        smart_fallback_tolerance = 1.0
        if abs(closest_size - round_size) <= smart_fallback_tolerance:
            return ranges[closest_size][:2]

        # If still no match, try to find the nearest range boundary
        # Example: 5.0" → use 5.75" range (smallest available)
        # Example: 11.0" → use 10.25/10.50" range (nearest)
        if round_size > 0:
            # Find the nearest range by distance
            nearest = min(positive_ranges.items(),
                         key=lambda x: abs(x[0] - round_size))
            return nearest[1][:2]

        return None

    def detect_round_size_from_title(self, title):
        """
        Extract round size from title string.

        RULE: The FIRST numeric value at the start of the title is the OD/round size.
        Anything after is CB, OB, or other dimensions (not round size).

        Examples:
        - "10.25IN DIA 170.1/170 3.0 HC" -> 10.25" is round size
        - "13.0 10/10IN 1.0 HC .25" -> 13.0" is round size
        - "7.5IN 78.3MM ID" -> 7.5" is round size
        - "8 IN DIA 125MM" -> 8" is round size
        - "6.25\" 141.3/170MM" -> 6.25" is round size
        """
        if not title:
            return None

        import re

        # Pattern: Capture FIRST number (with optional decimal) at START of title
        # Matches: 13.0, 10.25, 8, 6.25, etc. (regardless of what follows)
        pattern = r'^(\d+(?:\.\d+)?)'

        match = re.match(pattern, title)
        if match:
            try:
                round_size = float(match.group(1))

                # Validate it's in a reasonable range for round sizes
                if 5.0 <= round_size <= 15.0:
                    return round_size
            except:
                pass

        return None

    def detect_round_size_from_gcode(self, program_number):
        """Get round size from ob_from_gcode field"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("SELECT ob_from_gcode FROM programs WHERE program_number = ?",
                          (program_number,))
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                ob_value = result[0]
                # ob_from_gcode is the outer bore/diameter
                if 5.0 <= ob_value <= 15.0:
                    return ob_value
        except sqlite3.Error as e:
            logger.error(f"Database error getting round size from gcode: {e}")
        except Exception as e:
            logger.error(f"Error getting round size from gcode: {e}", exc_info=True)

        return None

    def detect_round_size_from_dimension(self, program_number):
        """Get round size from outer_diameter field"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("SELECT outer_diameter FROM programs WHERE program_number = ?",
                          (program_number,))
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                od_value = result[0]
                if 5.0 <= od_value <= 15.0:
                    return od_value
        except sqlite3.Error as e:
            logger.error(f"Database error getting round size from dimension: {e}")
        except Exception as e:
            logger.error(f"Error getting round size from dimension: {e}", exc_info=True)

        return None

    def detect_round_size(self, program_number, title=None):
        """
        Detect round size using multiple methods with priority order.
        Returns: (round_size, confidence, source)
        confidence: 'HIGH', 'MEDIUM', 'LOW', 'NONE'
        source: 'TITLE', 'GCODE', 'DIMENSION', 'MANUAL'
        """
        # Method 1: Parse title (most reliable if present)
        if title:
            title_match = self.detect_round_size_from_title(title)
            if title_match:
                return (title_match, 'HIGH', 'TITLE')

        # Method 2: Get from G-code OB (high confidence)
        gcode_match = self.detect_round_size_from_gcode(program_number)
        if gcode_match:
            return (gcode_match, 'HIGH', 'GCODE')

        # Method 3: Get from database dimension (medium confidence)
        dimension_match = self.detect_round_size_from_dimension(program_number)
        if dimension_match:
            return (dimension_match, 'MEDIUM', 'DIMENSION')

        # Method 4: Manual required
        return (None, 'NONE', 'MANUAL')

    def is_in_correct_range(self, program_number, round_size):
        """Check if program number is in correct range for its round size"""
        if not round_size:
            return True  # Can't validate without round size

        # Extract numeric part of program number (strip suffixes like (1), (2), etc.)
        try:
            # Remove 'o' prefix and any suffix in parentheses
            prog_str = str(program_number).replace('o', '').replace('O', '').split('(')[0]
            prog_num = int(prog_str)
        except:
            return False

        # Get range for this round size
        range_info = self.get_range_for_round_size(round_size)
        if not range_info:
            return False

        range_start, range_end = range_info
        return range_start <= prog_num <= range_end

    def update_round_size_for_program(self, program_number, round_size=None, confidence=None,
                                     source=None, manual_override=False):
        """Update round size fields for a program"""
        try:
            # Auto-detect if not provided
            if round_size is None and not manual_override:
                round_size, confidence, source = self.detect_round_size(program_number)

            # Check if in correct range
            in_correct_range = 1 if self.is_in_correct_range(program_number, round_size) else 0

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            cursor.execute("""
                UPDATE programs
                SET round_size = ?,
                    round_size_confidence = ?,
                    round_size_source = ?,
                    in_correct_range = ?
                WHERE program_number = ?
            """, (round_size, confidence, source, in_correct_range, program_number))

            conn.commit()
            conn.close()

            return True
        except sqlite3.Error as e:
            logger.error(f"Database error updating round size for {program_number}: {e}")
            return False
        except Exception as e:
            logger.error(f"Error updating round size: {e}", exc_info=True)
            return False

    def batch_detect_round_sizes(self, program_numbers=None, show_progress=True):
        """Detect and update round sizes for multiple programs

        Args:
            program_numbers: Optional list of specific program numbers to process
            show_progress: If True, show GUI progress tracker
        """
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get programs to process
            if program_numbers:
                placeholders = ','.join('?' * len(program_numbers))
                query = f"SELECT program_number, title FROM programs WHERE program_number IN ({placeholders})"
                cursor.execute(query, program_numbers)
            else:
                cursor.execute("SELECT program_number, title FROM programs")

            programs = cursor.fetchall()
            conn.close()

            results = {
                'processed': 0,
                'detected': 0,
                'failed': 0,
                'manual_needed': 0
            }

            # Show progress tracker if requested (disabled - module not yet implemented)
            progress = None
            # if show_progress and len(programs) > 10:
            #     from modules.progress_tracker import GUIProgressTracker
            #     progress = GUIProgressTracker(self.root, "Detecting Round Sizes")
            #     progress.configure(total=len(programs))

            try:
                for program_number, title in programs:
                    # Check if cancelled
                    if progress and progress.is_cancelled():
                        break

                    round_size, confidence, source = self.detect_round_size(program_number, title)

                    if round_size:
                        if self.update_round_size_for_program(program_number, round_size,
                                                             confidence, source):
                            results['detected'] += 1
                        else:
                            results['failed'] += 1
                    else:
                        results['manual_needed'] += 1

                    results['processed'] += 1

                    # Update progress
                    if progress:
                        progress.update(1,
                                      status=f"Processing {program_number}...",
                                      stats={
                                          'Detected': results['detected'],
                                          'Manual': results['manual_needed'],
                                          'Failed': results['failed']
                                      })
            finally:
                if progress:
                    progress.close()

            return results
        except sqlite3.Error as e:
            logger.error(f"Database error in batch round size detection: {e}")
            return None
        except Exception as e:
            logger.error(f"Batch round size detection error: {e}", exc_info=True)
            return None

    def populate_program_registry(self):
        """
        Populate the program_number_registry table with all 97,001 program numbers.
        Marks existing programs as 'IN_USE' and tracks duplicates.

        Returns:
            dict: Statistics about registry population
        """
        from datetime import datetime
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all round size ranges
            ranges = self.get_round_size_ranges()

            # Clear existing registry (fresh start)
            cursor.execute("DELETE FROM program_number_registry")

            # Get all existing programs from database
            cursor.execute("SELECT program_number, file_path FROM programs")
            existing_programs = {row[0]: row[1] for row in cursor.fetchall()}

            # Track statistics
            stats = {
                'total_generated': 0,
                'in_use': 0,
                'available': 0,
                'duplicates': 0,
                'by_range': {}
            }

            # Generate all program numbers for each range
            # Track which ranges we've already processed to avoid duplicates (e.g., 10.25 and 10.50 share same range)
            processed_ranges = set()

            for round_size, (range_start, range_end, range_name) in ranges.items():
                # Skip if we've already processed this range
                range_key = (range_start, range_end)
                if range_key in processed_ranges:
                    continue
                processed_ranges.add(range_key)

                range_stats = {
                    'total': 0,
                    'in_use': 0,
                    'available': 0
                }

                for prog_num in range(range_start, range_end + 1):
                    program_number = self.format_program_number(prog_num)

                    # Check if this program exists in database
                    if program_number in existing_programs:
                        status = 'IN_USE'
                        file_path = existing_programs[program_number]
                        stats['in_use'] += 1
                        range_stats['in_use'] += 1
                    else:
                        status = 'AVAILABLE'
                        file_path = None
                        stats['available'] += 1
                        range_stats['available'] += 1

                    # Insert into registry
                    cursor.execute("""
                        INSERT INTO program_number_registry
                        (program_number, round_size, range_start, range_end, status, file_path, last_checked)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                    """, (program_number, round_size, range_start, range_end, status, file_path,
                          datetime.now().isoformat()))

                    stats['total_generated'] += 1
                    range_stats['total'] += 1

                stats['by_range'][range_name] = range_stats

            # Find duplicates (programs with same number but different content)
            cursor.execute("""
                SELECT program_number, COUNT(*) as count
                FROM programs
                GROUP BY program_number
                HAVING count > 1
            """)

            duplicate_programs = cursor.fetchall()
            for prog_num, count in duplicate_programs:
                cursor.execute("""
                    UPDATE program_number_registry
                    SET duplicate_count = ?,
                        notes = 'WARNING: Multiple files with this program number'
                    WHERE program_number = ?
                """, (count, prog_num))
                stats['duplicates'] += 1

            conn.commit()
            conn.close()

            return stats

        except Exception as e:
            messagebox.showerror("Registry Error", f"Failed to populate program registry:\n{str(e)}")
            return None

    def find_next_available_number(self, round_size, preferred_number=None):
        """
        Find the next available program number for a given round size.

        Args:
            round_size: The round size (e.g., 6.25, 10.5)
            preferred_number: Optional preferred number to try first

        Returns:
            str: Next available program number (e.g., 'o62500') or None if range full
        """
        try:
            # Get the range for this round size
            range_info = self.get_range_for_round_size(round_size)
            if not range_info:
                return None

            range_start, range_end = range_info

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # If preferred number provided, check if it's available
            if preferred_number:
                try:
                    pref_num = int(str(preferred_number).replace('o', '').replace('O', ''))
                    if range_start <= pref_num <= range_end:
                        cursor.execute("""
                            SELECT status FROM program_number_registry
                            WHERE program_number = ?
                        """, (self.format_program_number(pref_num),))
                        result = cursor.fetchone()
                        if result and result[0] == 'AVAILABLE':
                            conn.close()
                            return self.format_program_number(pref_num)
                except:
                    pass

            # Build the set of program numbers already used in the programs table
            # so we catch numbers that exist in the DB but weren't marked in the
            # registry (e.g. imported before the registry existed, or registry drift).
            cursor.execute("""
                SELECT CAST(REPLACE(REPLACE(LOWER(program_number), 'o', ''), ' ', '') AS INTEGER)
                FROM programs
                WHERE program_number IS NOT NULL
            """)
            used_in_db = set()
            for row in cursor.fetchall():
                try:
                    if row[0] is not None:
                        used_in_db.add(int(row[0]))
                except (ValueError, TypeError):
                    pass

            # Find first available number in range that is neither marked USED in
            # the registry NOR already present in the programs table.
            cursor.execute("""
                SELECT program_number
                FROM program_number_registry
                WHERE CAST(REPLACE(program_number, 'o', '') AS INTEGER) BETWEEN ? AND ?
                AND status = 'AVAILABLE'
                ORDER BY CAST(REPLACE(program_number, 'o', '') AS INTEGER)
            """, (range_start, range_end))

            result = None
            for row in cursor.fetchall():
                try:
                    num = int(str(row[0]).replace('o', '').replace('O', ''))
                    if num not in used_in_db:
                        result = row
                        break
                except (ValueError, TypeError):
                    pass

            conn.close()

            if result:
                return result[0]
            else:
                return None  # Range is full

        except Exception as e:
            messagebox.showerror("Registry Error", f"Failed to find available number:\n{str(e)}")
            return None

    def find_available_numbers(self, round_size, count=5):
        """
        Find multiple available program numbers for a given round size.

        Args:
            round_size: The round size (e.g., 6.25, 10.5)
            count: How many available numbers to return

        Returns:
            list: List of available program numbers as integers
        """
        try:
            # Get the range for this round size
            range_info = self.get_range_for_round_size(round_size)
            if not range_info:
                return []

            range_start, range_end = range_info

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Build set of numbers already in the programs table so we catch any
            # that exist in the DB but aren't marked USED in the registry.
            cursor.execute("""
                SELECT CAST(REPLACE(REPLACE(LOWER(program_number), 'o', ''), ' ', '') AS INTEGER)
                FROM programs
                WHERE program_number IS NOT NULL
            """)
            used_in_db = set()
            for row in cursor.fetchall():
                try:
                    if row[0] is not None:
                        used_in_db.add(int(row[0]))
                except (ValueError, TypeError):
                    pass

            # Fetch all registry-available candidates then filter against programs table
            cursor.execute("""
                SELECT program_number
                FROM program_number_registry
                WHERE CAST(REPLACE(program_number, 'o', '') AS INTEGER) BETWEEN ? AND ?
                AND status = 'AVAILABLE'
                ORDER BY CAST(REPLACE(program_number, 'o', '') AS INTEGER)
            """, (range_start, range_end))

            rows = cursor.fetchall()
            conn.close()

            available = []
            for row in rows:
                try:
                    num = int(str(row[0]).replace('o', '').replace('O', ''))
                    if num not in used_in_db:
                        available.append(num)
                        if len(available) >= count:
                            break
                except (ValueError, TypeError):
                    pass

            return available

        except Exception as e:
            logger.error(f"Error finding available numbers: {e}")
            return []

    def get_registry_statistics(self):
        """
        Get statistics about the program number registry.

        Returns:
            dict: Statistics about each range and overall usage
        """
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            stats = {
                'total_numbers': 0,
                'in_use': 0,
                'available': 0,
                'reserved': 0,
                'duplicates': 0,
                'by_range': {}
            }

            # Get overall statistics
            cursor.execute("""
                SELECT status, COUNT(*) as count
                FROM program_number_registry
                GROUP BY status
            """)

            for status, count in cursor.fetchall():
                stats['total_numbers'] += count
                if status == 'IN_USE':
                    stats['in_use'] = count
                elif status == 'AVAILABLE':
                    stats['available'] = count
                elif status == 'RESERVED':
                    stats['reserved'] = count

            # Get duplicate count
            cursor.execute("""
                SELECT COUNT(*) FROM program_number_registry
                WHERE duplicate_count > 0
            """)
            stats['duplicates'] = cursor.fetchone()[0]

            # Get statistics by range
            ranges = self.get_round_size_ranges()
            for round_size, (range_start, range_end, range_name) in ranges.items():
                cursor.execute("""
                    SELECT
                        COUNT(*) as total,
                        SUM(CASE WHEN status = 'IN_USE' THEN 1 ELSE 0 END) as in_use,
                        SUM(CASE WHEN status = 'AVAILABLE' THEN 1 ELSE 0 END) as available,
                        SUM(CASE WHEN duplicate_count > 0 THEN 1 ELSE 0 END) as duplicates
                    FROM program_number_registry
                    WHERE round_size = ?
                """, (round_size,))

                row = cursor.fetchone()
                stats['by_range'][range_name] = {
                    'round_size': round_size,
                    'range': f"o{range_start}-o{range_end}",
                    'total': row[0] or 0,
                    'in_use': row[1] or 0,
                    'available': row[2] or 0,
                    'duplicates': row[3] or 0,
                    'usage_percent': (row[1] or 0) / (row[0] or 1) * 100
                }

            conn.close()
            return stats

        except Exception as e:
            messagebox.showerror("Registry Error", f"Failed to get registry statistics:\n{str(e)}")
            return None

    # ===========================================================================================
    # UNIFIED FILE HANDLING SYSTEM
    # ===========================================================================================

    def compute_file_hash(self, file_path):
        """
        Compute SHA256 hash of a file for duplicate detection.

        Args:
            file_path: Path to the file

        Returns:
            str: SHA256 hex digest or None if error
        """
        import hashlib
        try:
            sha256 = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    sha256.update(chunk)
            return sha256.hexdigest()
        except OSError as e:
            logger.error(f"File read error computing hash for {file_path}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error computing hash for {file_path}: {e}", exc_info=True)
            return None

    def extract_internal_program_number(self, file_path):
        """
        Extract the internal O-number from a G-code file.
        Reads first 10 lines to find the O-number (may be after % delimiter).

        Args:
            file_path: Path to the G-code file

        Returns:
            str: Program number (e.g., 'o96002') or None if not found
        """
        import re
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                for _ in range(10):
                    line = f.readline().strip()
                    if not line:
                        continue
                    match = re.match(r'^[oO](\d{4,})', line)
                    if match:
                        return f"o{match.group(1)}"
        except OSError as e:
            logger.error(f"File read error extracting program number from {file_path}: {e}")
        except Exception as e:
            logger.error(f"Error extracting program number from {file_path}: {e}", exc_info=True)
        return None

    def sync_registry_for_operation(self, operation, old_number=None, new_number=None, file_path=None):
        """
        Update registry to reflect a single operation.
        Called automatically after every file operation.

        Args:
            operation: 'ADD', 'REMOVE', 'RENAME', 'UPDATE'
            old_number: Previous program number (for RENAME/REMOVE)
            new_number: New program number (for ADD/RENAME)
            file_path: File path to associate

        Returns:
            bool: Success status
        """
        from datetime import datetime
        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            now = datetime.now().isoformat()

            if operation == 'ADD' and new_number:
                # Mark new number as IN_USE
                cursor.execute("""
                    UPDATE program_number_registry
                    SET status = 'IN_USE', file_path = ?, last_checked = ?
                    WHERE program_number = ?
                """, (file_path, now, new_number))

                # If no registry entry exists, create one
                if cursor.rowcount == 0:
                    # Determine round_size from program number
                    try:
                        num = int(new_number.replace('o', '').replace('O', ''))
                        ranges = self.get_round_size_ranges()
                        round_size = None
                        range_start = range_end = 0
                        for rs, (start, end, _) in ranges.items():
                            if start <= num <= end:
                                round_size = rs
                                range_start = start
                                range_end = end
                                break
                        cursor.execute("""
                            INSERT INTO program_number_registry
                            (program_number, round_size, range_start, range_end, status, file_path, last_checked)
                            VALUES (?, ?, ?, ?, 'IN_USE', ?, ?)
                        """, (new_number, round_size, range_start, range_end, file_path, now))
                    except:
                        pass

            elif operation == 'REMOVE' and old_number:
                # Mark old number as AVAILABLE
                cursor.execute("""
                    UPDATE program_number_registry
                    SET status = 'AVAILABLE', file_path = NULL, last_checked = ?
                    WHERE program_number = ?
                """, (now, old_number))

            elif operation == 'RENAME' and old_number and new_number:
                # Free old number
                cursor.execute("""
                    UPDATE program_number_registry
                    SET status = 'AVAILABLE', file_path = NULL, last_checked = ?
                    WHERE program_number = ?
                """, (now, old_number))
                # Claim new number
                cursor.execute("""
                    UPDATE program_number_registry
                    SET status = 'IN_USE', file_path = ?, last_checked = ?
                    WHERE program_number = ?
                """, (file_path, now, new_number))

            elif operation == 'UPDATE' and new_number:
                # Just update file_path
                cursor.execute("""
                    UPDATE program_number_registry
                    SET file_path = ?, last_checked = ?
                    WHERE program_number = ?
                """, (file_path, now, new_number))

            conn.commit()
            return True

        except sqlite3.Error as e:
            logger.error(f"Database error syncing registry for {operation}: {e}")
            return False
        except Exception as e:
            logger.error(f"Error syncing registry for {operation}: {e}", exc_info=True)
            return False
        finally:
            if conn:
                conn.close()

    def populate_content_hashes(self, progress_callback=None):
        """
        Populate content_hash for all files that don't have one.
        Should be run once to initialize hashes for existing files.

        Args:
            progress_callback: Optional function(current, total, message) for progress updates

        Returns:
            dict: {'updated': int, 'errors': int, 'skipped': int}
        """
        result = {'updated': 0, 'errors': 0, 'skipped': 0}

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all files without hash
            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE content_hash IS NULL AND file_path IS NOT NULL
            """)
            files_to_hash = cursor.fetchall()
            total = len(files_to_hash)

            for i, (prog_num, file_path) in enumerate(files_to_hash):
                if progress_callback:
                    progress_callback(i + 1, total, f"Hashing {prog_num}...")

                if not file_path or not os.path.exists(file_path):
                    result['skipped'] += 1
                    continue

                file_hash = self.compute_file_hash(file_path)
                if file_hash:
                    cursor.execute("""
                        UPDATE programs SET content_hash = ? WHERE program_number = ?
                    """, (file_hash, prog_num))
                    result['updated'] += 1
                else:
                    result['errors'] += 1

                # Commit every 100 files
                if (i + 1) % 100 == 0:
                    conn.commit()

            conn.commit()
            conn.close()
            return result

        except sqlite3.Error as e:
            logger.error(f"Database error populating hashes: {e}")
            return result
        except Exception as e:
            logger.error(f"Error populating hashes: {e}", exc_info=True)
            return result

    def find_similar_files(self, source_path):
        """
        Find files with similar dimensions to the source file.
        Useful for detecting files that are slight variations (e.g., more passes).

        Args:
            source_path: Path to the file to compare

        Returns:
            list: List of similar files with comparison details
        """
        similar = []

        try:
            # Parse the source file
            parse_result = self.parser.parse_file(source_path)

            if not parse_result.outer_diameter:
                return similar

            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Find files with same outer_diameter and center_bore (within tolerance)
            od_tolerance = 0.1  # 0.1" tolerance
            cb_tolerance = 0.1  # 0.1mm tolerance

            cursor.execute("""
                SELECT program_number, title, file_path, outer_diameter, center_bore,
                       thickness, hub_diameter, content_hash
                FROM programs
                WHERE outer_diameter BETWEEN ? AND ?
                AND (center_bore IS NULL OR center_bore BETWEEN ? AND ?)
                AND file_path IS NOT NULL
            """, (
                parse_result.outer_diameter - od_tolerance,
                parse_result.outer_diameter + od_tolerance,
                (parse_result.center_bore or 0) - cb_tolerance,
                (parse_result.center_bore or 999) + cb_tolerance
            ))

            source_hash = self.compute_file_hash(source_path)

            for row in cursor.fetchall():
                prog_num, title, file_path, od, cb, thickness, hub_dia, existing_hash = row

                # Skip if same file
                if file_path and file_path.lower() == source_path.lower():
                    continue

                # Calculate similarity score
                similarity = {
                    'program_number': prog_num,
                    'title': title,
                    'file_path': file_path,
                    'outer_diameter': od,
                    'center_bore': cb,
                    'thickness': thickness,
                    'hub_diameter': hub_dia,
                    'is_exact_match': existing_hash == source_hash if existing_hash else False,
                    'dimension_match': True,  # Already filtered by query
                    'differences': []
                }

                # Note differences
                if parse_result.thickness and thickness:
                    if abs(parse_result.thickness - thickness) > 0.01:
                        similarity['differences'].append(
                            f"Thickness: {parse_result.thickness} vs {thickness}"
                        )

                if parse_result.hub_diameter and hub_dia:
                    if abs(parse_result.hub_diameter - hub_dia) > 0.1:
                        similarity['differences'].append(
                            f"Hub: {parse_result.hub_diameter} vs {hub_dia}"
                        )

                similar.append(similarity)

            conn.close()
            return similar

        except sqlite3.Error as e:
            logger.error(f"Database error finding similar files: {e}")
            return similar
        except Exception as e:
            logger.error(f"Error finding similar files: {e}", exc_info=True)
            return similar

    def compare_file_contents(self, file1_path, file2_path):
        """
        Compare two G-code files focusing on DIMENSIONAL differences.
        This is the key comparison - same OD but different CB, thickness, hub, etc.
        indicates a variation made from the original.

        Args:
            file1_path: Path to first file
            file2_path: Path to second file

        Returns:
            dict: Comparison results with dimensional analysis
        """
        result = {
            'identical': False,
            'line_count_diff': 0,
            'file1_lines': 0,
            'file2_lines': 0,
            'file1_size': 0,
            'file2_size': 0,
            'common_lines_percent': 0,
            'recommendation': None,
            # Dimensional comparison
            'file1_dimensions': {},
            'file2_dimensions': {},
            'dimension_differences': [],
            'same_od': False,
            'is_variation': False,  # Same OD but different other dimensions
            'variation_type': None  # 'CB_DIFF', 'THICKNESS_DIFF', 'HUB_DIFF', 'MULTI_DIFF'
        }

        try:
            # Get file sizes
            result['file1_size'] = os.path.getsize(file1_path)
            result['file2_size'] = os.path.getsize(file2_path)

            # Read files for line comparison
            with open(file1_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines1 = [l.strip() for l in f.readlines() if l.strip()]
            with open(file2_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines2 = [l.strip() for l in f.readlines() if l.strip()]

            result['file1_lines'] = len(lines1)
            result['file2_lines'] = len(lines2)
            result['line_count_diff'] = abs(len(lines1) - len(lines2))

            # Check if identical content
            if lines1 == lines2:
                result['identical'] = True
                result['common_lines_percent'] = 100.0
                result['recommendation'] = 'SKIP_DUPLICATE'
                return result

            # Calculate common lines percentage
            set1 = set(lines1)
            set2 = set(lines2)
            common = set1.intersection(set2)
            total_unique = len(set1.union(set2))
            result['common_lines_percent'] = (len(common) / total_unique * 100) if total_unique > 0 else 0

            # Parse both files to get dimensions
            try:
                parse1 = self.parser.parse_file(file1_path)
                parse2 = self.parser.parse_file(file2_path)

                # Store dimensions
                result['file1_dimensions'] = {
                    'outer_diameter': parse1.outer_diameter,
                    'center_bore': parse1.center_bore,
                    'thickness': parse1.thickness,
                    'hub_height': parse1.hub_height,
                    'hub_diameter': parse1.hub_diameter,
                    'counter_bore_diameter': parse1.counter_bore_diameter,
                    'counter_bore_depth': parse1.counter_bore_depth,
                    'title': parse1.title
                }
                result['file2_dimensions'] = {
                    'outer_diameter': parse2.outer_diameter,
                    'center_bore': parse2.center_bore,
                    'thickness': parse2.thickness,
                    'hub_height': parse2.hub_height,
                    'hub_diameter': parse2.hub_diameter,
                    'counter_bore_diameter': parse2.counter_bore_diameter,
                    'counter_bore_depth': parse2.counter_bore_depth,
                    'title': parse2.title
                }

                # Compare dimensions
                od1, od2 = parse1.outer_diameter, parse2.outer_diameter
                cb1, cb2 = parse1.center_bore, parse2.center_bore
                th1, th2 = parse1.thickness, parse2.thickness
                hh1, hh2 = parse1.hub_height, parse2.hub_height
                hd1, hd2 = parse1.hub_diameter, parse2.hub_diameter
                cbd1, cbd2 = parse1.counter_bore_diameter, parse2.counter_bore_diameter
                cbdepth1, cbdepth2 = parse1.counter_bore_depth, parse2.counter_bore_depth

                # Check if same OD (within 0.1" tolerance)
                if od1 and od2 and abs(od1 - od2) < 0.1:
                    result['same_od'] = True

                # Track what's different
                diff_types = []

                if cb1 and cb2 and abs(cb1 - cb2) > 0.1:  # CB differs by more than 0.1mm
                    result['dimension_differences'].append(f"Center Bore: {cb1}mm vs {cb2}mm")
                    diff_types.append('CB')
                elif (cb1 and not cb2) or (cb2 and not cb1):
                    result['dimension_differences'].append(f"Center Bore: {cb1 or 'None'} vs {cb2 or 'None'}")
                    diff_types.append('CB')

                if th1 and th2 and abs(th1 - th2) > 0.01:  # Thickness differs
                    result['dimension_differences'].append(f"Thickness: {th1}\" vs {th2}\"")
                    diff_types.append('THICKNESS')

                if hh1 and hh2 and abs(hh1 - hh2) > 0.01:  # Hub height differs
                    result['dimension_differences'].append(f"Hub Height: {hh1}\" vs {hh2}\"")
                    diff_types.append('HUB_HEIGHT')
                elif (hh1 and not hh2) or (hh2 and not hh1):
                    result['dimension_differences'].append(f"Hub Height: {hh1 or 'None'} vs {hh2 or 'None'}")
                    diff_types.append('HUB_HEIGHT')

                if hd1 and hd2 and abs(hd1 - hd2) > 0.1:  # Hub diameter differs
                    result['dimension_differences'].append(f"Hub Diameter: {hd1}\" vs {hd2}\"")
                    diff_types.append('HUB_DIA')

                if cbd1 and cbd2 and abs(cbd1 - cbd2) > 0.1:  # Counter bore diameter differs by more than 0.1mm
                    result['dimension_differences'].append(f"Counter Bore Dia: {cbd1}mm vs {cbd2}mm")
                    diff_types.append('CB_DIA')
                elif (cbd1 and not cbd2) or (cbd2 and not cbd1):
                    result['dimension_differences'].append(f"Counter Bore Dia: {cbd1 or 'None'} vs {cbd2 or 'None'}")
                    diff_types.append('CB_DIA')

                if cbdepth1 and cbdepth2 and abs(cbdepth1 - cbdepth2) > 0.01:  # CB depth differs
                    result['dimension_differences'].append(f"Counter Bore Depth: {cbdepth1}\" vs {cbdepth2}\"")
                    diff_types.append('CB_DEPTH')

                # Determine if this is a variation (same OD, different finishing dimensions)
                if result['same_od'] and len(diff_types) > 0:
                    result['is_variation'] = True
                    if len(diff_types) == 1:
                        result['variation_type'] = f"{diff_types[0]}_DIFF"
                    else:
                        result['variation_type'] = 'MULTI_DIFF'

            except Exception as e:
                logger.warning(f"Error parsing files for dimensional comparison: {e}")

            # Recommendation based on analysis
            if result['identical']:
                result['recommendation'] = 'SKIP_DUPLICATE'
            elif result['is_variation']:
                # Same OD but different dimensions - these are intentional variations
                result['recommendation'] = 'KEEP_BOTH_VARIATIONS'
            elif result['same_od'] and result['common_lines_percent'] > 95:
                # Same OD, very similar code - likely a copy with minor tweaks (more passes, etc.)
                result['recommendation'] = 'REVIEW_KEEP_LARGER'
            elif result['common_lines_percent'] > 80:
                result['recommendation'] = 'SIMILAR_REVIEW_MANUALLY'
            else:
                result['recommendation'] = 'DIFFERENT_KEEP_BOTH'

            return result

        except OSError as e:
            logger.error(f"File operation error comparing files: {e}")
            result['recommendation'] = 'ERROR'
            return result
        except Exception as e:
            logger.error(f"Error comparing files: {e}", exc_info=True)
            result['recommendation'] = 'ERROR'
            return result

    def find_dimensional_variations(self, program_number=None, outer_diameter=None):
        """
        Find all files that are dimensional variations of each other.
        These are files with the same OD but different CB, thickness, hub, etc.

        Args:
            program_number: Optional - find variations of this specific program
            outer_diameter: Optional - find all variations for this OD

        Returns:
            dict: Groups of variations keyed by base OD
        """
        variations = {}

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            if program_number:
                # Get the OD for this program
                cursor.execute("SELECT outer_diameter FROM programs WHERE program_number = ?",
                             (program_number,))
                row = cursor.fetchone()
                if row and row[0]:
                    outer_diameter = row[0]
                else:
                    conn.close()
                    return variations

            if outer_diameter:
                # Find all programs with this OD (within 0.1" tolerance)
                cursor.execute("""
                    SELECT program_number, title, file_path, outer_diameter,
                           center_bore, thickness, hub_height, hub_diameter,
                           counter_bore_diameter, counter_bore_depth
                    FROM programs
                    WHERE outer_diameter BETWEEN ? AND ?
                    AND file_path IS NOT NULL
                    ORDER BY program_number
                """, (outer_diameter - 0.1, outer_diameter + 0.1))
            else:
                # Find ALL potential variations - group by OD
                cursor.execute("""
                    SELECT program_number, title, file_path, outer_diameter,
                           center_bore, thickness, hub_height, hub_diameter,
                           counter_bore_diameter, counter_bore_depth
                    FROM programs
                    WHERE outer_diameter IS NOT NULL
                    AND file_path IS NOT NULL
                    ORDER BY outer_diameter, program_number
                """)

            rows = cursor.fetchall()
            conn.close()

            # Group by OD (rounded to nearest 0.25")
            od_groups = {}
            for row in rows:
                prog_num, title, file_path, od, cb, thickness, hh, hd, cbd, cbdepth = row

                # Round OD to nearest 0.25 for grouping
                od_key = round(od * 4) / 4 if od else 0

                if od_key not in od_groups:
                    od_groups[od_key] = []

                od_groups[od_key].append({
                    'program_number': prog_num,
                    'title': title,
                    'file_path': file_path,
                    'outer_diameter': od,
                    'center_bore': cb,
                    'thickness': thickness,
                    'hub_height': hh,
                    'hub_diameter': hd,
                    'counter_bore_diameter': cbd,
                    'counter_bore_depth': cbdepth
                })

            # For each OD group, find actual variations (different dimensions)
            for od_key, programs in od_groups.items():
                if len(programs) < 2:
                    continue

                # Create dimension signature for each program
                # Programs with same signature are true duplicates
                # Programs with different signatures are variations
                signatures = {}
                for prog in programs:
                    # Create a signature from key dimensions
                    sig = (
                        round(prog['center_bore'] or 0, 1),
                        round(prog['thickness'] or 0, 3),
                        round(prog['hub_height'] or 0, 3) if prog['hub_height'] else None,
                        round(prog['hub_diameter'] or 0, 2) if prog['hub_diameter'] else None,
                        round(prog['counter_bore_diameter'] or 0, 1) if prog['counter_bore_diameter'] else None
                    )

                    if sig not in signatures:
                        signatures[sig] = []
                    signatures[sig].append(prog)

                # If there are multiple different signatures, we have variations
                if len(signatures) > 1:
                    variations[od_key] = {
                        'outer_diameter': od_key,
                        'variation_count': len(signatures),
                        'total_programs': len(programs),
                        'groups': []
                    }

                    for sig, progs in signatures.items():
                        group_desc = []
                        if sig[0]: group_desc.append(f"CB:{sig[0]}mm")
                        if sig[1]: group_desc.append(f"T:{sig[1]}\"")
                        if sig[2]: group_desc.append(f"HH:{sig[2]}\"")
                        if sig[3]: group_desc.append(f"HD:{sig[3]}\"")
                        if sig[4]: group_desc.append(f"CBD:{sig[4]}mm")

                        variations[od_key]['groups'].append({
                            'signature': ' | '.join(group_desc) if group_desc else 'Base dimensions',
                            'programs': progs,
                            'count': len(progs)
                        })

            return variations

        except sqlite3.Error as e:
            logger.error(f"Database error finding dimensional variations: {e}")
            return variations
        except Exception as e:
            logger.error(f"Error finding dimensional variations: {e}", exc_info=True)
            return variations

    def find_compatible_2pc_parts(self, program_number=None, spacer_type=None,
                                  stud_thickness_min=None, stud_thickness_max=None,
                                  lug_thickness_min=None, lug_thickness_max=None,
                                  cb_min=None, cb_max=None, od_min=None, od_max=None):
        """
        Find compatible 2PC part pairings (STUD + LUG).

        Matching criteria:
        1. Round size (OD) must match within tolerance (±1mm or ±0.04")
        2. STUD hub diameter must fit inside LUG step diameter (with 1-3mm clearance)
        3. STUD hub height fits inside LUG step depth (with clearance)
        4. CB matching is optional (parts can work with different CBs)
        5. Optional thickness filters for STUD and LUG separately

        This allows matching parts where hub_diameter ≠ CB, enabling custom
        hub configurations.

        Args:
            program_number: Optional - find matches for this specific program
            spacer_type: Optional - '2PC STUD' or '2PC LUG'
            stud_thickness_min: Optional - minimum STUD thickness (inches)
            stud_thickness_max: Optional - maximum STUD thickness (inches)
            lug_thickness_min: Optional - minimum LUG thickness (inches)
            lug_thickness_max: Optional - maximum LUG thickness (inches)
            cb_min: Optional - minimum center bore (mm)
            cb_max: Optional - maximum center bore (mm)
            od_min: Optional - minimum outer diameter (inches)
            od_max: Optional - maximum outer diameter (inches)

        Returns:
            list: Compatible pairings with match quality scores
        """
        matches = []

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get the reference part if program_number specified
            reference_part = None
            if program_number:
                cursor.execute("""
                    SELECT program_number, title, outer_diameter, center_bore,
                           thickness, hub_height, hub_diameter, counter_bore_depth,
                           counter_bore_diameter, spacer_type, file_path
                    FROM programs
                    WHERE program_number = ?
                """, (program_number,))
                row = cursor.fetchone()
                if row:
                    reference_part = {
                        'program_number': row[0], 'title': row[1], 'outer_diameter': row[2],
                        'center_bore': row[3], 'thickness': row[4], 'hub_height': row[5],
                        'hub_diameter': row[6], 'counter_bore_depth': row[7],
                        'counter_bore_diameter': row[8], 'spacer_type': row[9],
                        'file_path': row[10]
                    }
                    # Determine which type we're looking for
                    if '2PC STUD' in reference_part['spacer_type']:
                        spacer_type = '2PC LUG'  # Find LUGs for this STUD
                    elif '2PC LUG' in reference_part['spacer_type']:
                        spacer_type = '2PC STUD'  # Find STUDs for this LUG
                    else:
                        conn.close()
                        return matches  # Not a 2PC part

            # Get all 2PC parts
            cursor.execute("""
                SELECT program_number, title, outer_diameter, center_bore,
                       thickness, hub_height, hub_diameter, counter_bore_depth,
                       counter_bore_diameter, spacer_type, file_path
                FROM programs
                WHERE spacer_type LIKE '%2PC%'
                AND outer_diameter IS NOT NULL
                ORDER BY outer_diameter, program_number
            """)

            all_2pc_parts = []
            for row in cursor.fetchall():
                all_2pc_parts.append({
                    'program_number': row[0], 'title': row[1], 'outer_diameter': row[2],
                    'center_bore': row[3], 'thickness': row[4], 'hub_height': row[5],
                    'hub_diameter': row[6], 'counter_bore_depth': row[7],
                    'counter_bore_diameter': row[8], 'spacer_type': row[9],
                    'file_path': row[10]
                })

            conn.close()

            # Separate into STUDs and LUGs, with optional filtering
            studs = [p for p in all_2pc_parts if '2PC STUD' in p['spacer_type']]
            lugs = [p for p in all_2pc_parts if '2PC LUG' in p['spacer_type']]

            # Apply thickness filters
            if stud_thickness_min is not None or stud_thickness_max is not None:
                filtered_studs = []
                for stud in studs:
                    thickness = stud.get('thickness')
                    if thickness is None:
                        continue
                    if stud_thickness_min is not None and thickness < stud_thickness_min:
                        continue
                    if stud_thickness_max is not None and thickness > stud_thickness_max:
                        continue
                    filtered_studs.append(stud)
                studs = filtered_studs

            if lug_thickness_min is not None or lug_thickness_max is not None:
                filtered_lugs = []
                for lug in lugs:
                    thickness = lug.get('thickness')
                    if thickness is None:
                        continue
                    if lug_thickness_min is not None and thickness < lug_thickness_min:
                        continue
                    if lug_thickness_max is not None and thickness > lug_thickness_max:
                        continue
                    filtered_lugs.append(lug)
                lugs = filtered_lugs

            # Apply CB filter (affects both STUD and LUG)
            if cb_min is not None or cb_max is not None:
                if cb_min is not None:
                    studs = [s for s in studs if s.get('center_bore') and s['center_bore'] >= cb_min]
                    lugs = [l for l in lugs if l.get('center_bore') and l['center_bore'] >= cb_min]
                if cb_max is not None:
                    studs = [s for s in studs if s.get('center_bore') and s['center_bore'] <= cb_max]
                    lugs = [l for l in lugs if l.get('center_bore') and l['center_bore'] <= cb_max]

            # Apply OD filter (affects both STUD and LUG)
            if od_min is not None or od_max is not None:
                if od_min is not None:
                    studs = [s for s in studs if s.get('outer_diameter') and s['outer_diameter'] >= od_min]
                    lugs = [l for l in lugs if l.get('outer_diameter') and l['outer_diameter'] >= od_min]
                if od_max is not None:
                    studs = [s for s in studs if s.get('outer_diameter') and s['outer_diameter'] <= od_max]
                    lugs = [l for l in lugs if l.get('outer_diameter') and l['outer_diameter'] <= od_max]

            # If we have a reference part, only match against it
            if reference_part:
                if '2PC STUD' in reference_part['spacer_type']:
                    # Reference is STUD, find compatible LUGs
                    logger.info(f"[2PC MATCH] Reference {reference_part['program_number']} is STUD, checking against {len(lugs)} LUGs")
                    for lug in lugs:
                        match_result = self._check_2pc_compatibility(reference_part, lug)
                        if match_result['compatible']:
                            matches.append({
                                'stud': reference_part,
                                'lug': lug,
                                'score': match_result['score'],
                                'notes': match_result['notes'],
                                'clearance_mm': match_result.get('clearance_mm', 999)
                            })
                else:
                    # Reference is LUG, find compatible STUDs
                    for stud in studs:
                        match_result = self._check_2pc_compatibility(stud, reference_part)
                        if match_result['compatible']:
                            matches.append({
                                'stud': stud,
                                'lug': reference_part,
                                'score': match_result['score'],
                                'notes': match_result['notes'],
                                'clearance_mm': match_result.get('clearance_mm', 999)
                            })
            else:
                # No reference - find all compatible pairings
                for stud in studs:
                    for lug in lugs:
                        match_result = self._check_2pc_compatibility(stud, lug)
                        if match_result['compatible']:
                            matches.append({
                                'stud': stud,
                                'lug': lug,
                                'score': match_result['score'],
                                'notes': match_result['notes'],
                                'clearance_mm': match_result.get('clearance_mm', 999)
                            })

            # Sort by clearance (tightest fit first), then by score
            matches.sort(key=lambda x: (x['clearance_mm'], -x['score']))

            return matches

        except sqlite3.Error as e:
            logger.error(f"Database error finding compatible 2PC parts: {e}")
            return matches
        except Exception as e:
            logger.error(f"Error finding compatible 2PC parts: {e}", exc_info=True)
            return matches

    def _check_2pc_compatibility(self, stud, lug):
        """
        Check if a STUD and LUG are compatible.

        Returns:
            dict: {'compatible': bool, 'score': int (0-100), 'notes': list}
        """
        result = {'compatible': False, 'score': 0, 'notes': []}

        # Rule 0: CRITICAL - Verify proper 2PC mating features
        # 2PC mating uses:
        #   - Small hub (~0.25" / 0.20-0.30") for mating
        #   - Recess (~0.3-0.35" / 0.25-0.40" deep) for receiving the small hub
        # Non-2PC features (ignore these):
        #   - Large hub (~0.50" / 0.45-0.60") for mounting/handling (not for 2PC mating)

        stud_hub_dia = stud.get('hub_diameter')
        stud_hub_height = stud.get('hub_height')
        lug_step_dia = lug.get('counter_bore_diameter')
        lug_step_depth = lug.get('counter_bore_depth')

        # Check STUD has a small hub for 2PC mating (0.20-0.30")
        if not stud_hub_dia or not stud_hub_height:
            result['notes'].append('❌ STUD missing hub dimensions')
            return result
        if stud_hub_dia <= 0 or stud_hub_height <= 0:
            result['notes'].append('❌ STUD has invalid hub dimensions')
            return result

        # Identify if this is a 2PC mating hub (small ~0.25") or other hub (large ~0.50")
        is_stud_small_hub = 0.20 <= stud_hub_height <= 0.30
        is_stud_large_hub = 0.45 <= stud_hub_height <= 0.60

        if not is_stud_small_hub:
            if is_stud_large_hub:
                result['notes'].append('❌ STUD has large hub (0.50" - not for 2PC mating)')
            else:
                result['notes'].append(f'❌ STUD hub height {stud_hub_height:.2f}" is not a 2PC mating hub (expected 0.20-0.30")')
            return result

        # Check LUG dimensions
        lug_hub_dia = lug.get('hub_diameter')
        lug_hub_height = lug.get('hub_height')

        # Identify LUG features
        has_lug_recess = lug_step_dia and lug_step_depth and lug_step_dia > 0 and lug_step_depth > 0
        has_lug_small_hub = lug_hub_dia and lug_hub_height and lug_hub_dia > 0 and 0.20 <= lug_hub_height <= 0.30
        has_lug_large_hub = lug_hub_height and 0.45 <= lug_hub_height <= 0.60

        # LUG must have a proper 2PC recess (0.25-0.40" deep) to receive the STUD's small hub
        is_lug_proper_recess = has_lug_recess and 0.25 <= lug_step_depth <= 0.40

        # REJECT: Both parts have only small hubs (0.25") - can't mate together
        if has_lug_small_hub and not is_lug_proper_recess:
            result['notes'].append('❌ Both parts have 0.25" hubs - cannot mate (no recess)')
            return result

        # REJECT: LUG has no proper recess for 2PC mating
        if not is_lug_proper_recess:
            if has_lug_large_hub:
                result['notes'].append('❌ LUG has only large hub (0.50") - no recess for 2PC mating')
            else:
                result['notes'].append('❌ LUG missing proper recess (expected 0.25-0.40" deep)')
            return result

        # ALLOW: LUG has proper recess + optional large hub (0.50" hub is for other purposes)
        # This is valid - the 0.50" hub on LUG is not for 2PC mating with this STUD

        # Rule 1: Round size (OD) must match within tolerance
        stud_od = stud.get('outer_diameter')
        lug_od = lug.get('outer_diameter')

        if not stud_od or not lug_od:
            result['notes'].append('Missing OD data')
            return result

        od_diff_inches = abs(stud_od - lug_od)
        od_diff_mm = od_diff_inches * 25.4

        # Tolerance: ±1mm (0.04") for OD match
        if od_diff_mm > 1.0:
            result['notes'].append(f'OD mismatch: {od_diff_mm:.1f}mm difference')
            return result

        # OD matches - good start
        result['score'] += 40
        result['notes'].append(f'✓ OD match: {stud_od:.2f}" (Δ={od_diff_mm:.1f}mm)')

        # Rule 2: Hub diameter must fit inside step diameter
        clearance_mm = lug_step_dia - stud_hub_dia

        # Minimum clearance: 0.001" = 0.0254mm (parts must have positive clearance)
        if clearance_mm < 0.025:
            result['notes'].append(f'❌ Hub too large: {stud_hub_dia:.1f}mm hub vs {lug_step_dia:.1f}mm recess (clearance: {clearance_mm:.2f}mm)')
            return result

        # Score based on tightness of fit (tighter = better)
        # 0.025-0.5mm clearance = excellent fit (30 points)
        # 0.5-2.0mm clearance = good fit (25 points)
        # 2.0-5.0mm clearance = acceptable fit (20 points)
        # >5.0mm clearance = loose fit (10 points)
        if clearance_mm <= 0.5:
            result['score'] += 30
            result['notes'].append(f'✓ Hub fit: {stud_hub_dia:.1f}mm hub → {lug_step_dia:.1f}mm recess (clearance: {clearance_mm:.2f}mm - TIGHT FIT)')
        elif clearance_mm <= 2.0:
            result['score'] += 25
            result['notes'].append(f'✓ Hub fit: {stud_hub_dia:.1f}mm hub → {lug_step_dia:.1f}mm recess (clearance: {clearance_mm:.2f}mm)')
        elif clearance_mm <= 5.0:
            result['score'] += 20
            result['notes'].append(f'✓ Hub fit: {stud_hub_dia:.1f}mm hub → {lug_step_dia:.1f}mm recess (clearance: {clearance_mm:.2f}mm)')
        else:
            result['score'] += 10
            result['notes'].append(f'⚠ Hub fit: {stud_hub_dia:.1f}mm hub → {lug_step_dia:.1f}mm recess (clearance: {clearance_mm:.2f}mm - LOOSE FIT)')

        # Store clearance for sorting
        result['clearance_mm'] = clearance_mm

        # Rule 3: Hub height must fit inside step depth
        depth_clearance = lug_step_depth - stud_hub_height

        # Need at least 0.02" clearance
        if depth_clearance < 0.02:
            result['notes'].append(f'❌ Hub too tall: {stud_hub_height:.2f}" hub vs {lug_step_depth:.2f}" recess depth (clearance: {depth_clearance:.3f}")')
            return result

        # Good depth clearance
        result['score'] += 20
        result['notes'].append(f'✓ Hub depth: {stud_hub_height:.2f}" hub → {lug_step_depth:.2f}" recess (clearance: {depth_clearance:.3f}")')

        # Rule 4: CB match is a bonus (not required)
        stud_cb = stud.get('center_bore')
        lug_cb = lug.get('center_bore')

        if stud_cb and lug_cb:
            cb_diff_mm = abs(stud_cb - lug_cb)
            if cb_diff_mm < 1.0:
                result['score'] += 10
                result['notes'].append(f'CB match: {stud_cb:.1f}mm (bonus!)')
            else:
                result['notes'].append(f'CB different: STUD={stud_cb:.1f}mm, LUG={lug_cb:.1f}mm (OK - not required)')

        # Compatible if we got here
        result['compatible'] = True

        return result

    def find_suffix_programs(self):
        """
        Find all programs that have temporary suffix placeholders like (1), (2), _1, _2.
        These need to be resolved to proper unique numbers.

        Returns:
            list: List of dicts with program info and detected suffix
        """
        import re
        suffix_programs = []

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, title, file_path, outer_diameter, round_size
                FROM programs
                WHERE file_path IS NOT NULL
            """)

            # Pattern to match suffixes: (1), (2), _1, _2, etc.
            suffix_pattern = re.compile(r'^(o\d+)([(_]\d+[)]?)$', re.IGNORECASE)

            for row in cursor.fetchall():
                prog_num, title, file_path, od, round_size = row

                # Skip if program_number is None
                if prog_num is None:
                    continue

                match = suffix_pattern.match(prog_num)
                if match:
                    base_number = match.group(1)
                    suffix = match.group(2)

                    suffix_programs.append({
                        'program_number': prog_num,
                        'base_number': base_number,
                        'suffix': suffix,
                        'title': title,
                        'file_path': file_path,
                        'outer_diameter': od,
                        'round_size': round_size or od
                    })

            conn.close()
            return suffix_programs

        except sqlite3.Error as e:
            logger.error(f"Database error finding suffix programs: {e}")
            return suffix_programs
        except Exception as e:
            logger.error(f"Error finding suffix programs: {e}", exc_info=True)
            return suffix_programs

    def resolve_suffix_program(self, program_number, dry_run=False):
        """
        Resolve a single program with suffix to a proper unique number.

        Args:
            program_number: Program number with suffix (e.g., 'o80001(1)')
            dry_run: If True, only simulate without making changes

        Returns:
            dict: Result with old_number, new_number, success, error
        """
        import re
        from datetime import datetime

        result = {
            'success': False,
            'old_number': program_number,
            'new_number': None,
            'old_file_path': None,
            'new_file_path': None,
            'error': None
        }

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get program info
            cursor.execute("""
                SELECT title, file_path, outer_diameter, round_size
                FROM programs
                WHERE program_number = ?
            """, (program_number,))

            row = cursor.fetchone()
            if not row:
                result['error'] = f"Program {program_number} not found"
                conn.close()
                return result

            title, file_path, od, round_size = row
            result['old_file_path'] = file_path

            # Determine round size for finding new number
            effective_round_size = round_size or od
            if not effective_round_size:
                # Try to parse from file
                if file_path and os.path.exists(file_path):
                    try:
                        parse_result = self.parser.parse_file(file_path)
                        effective_round_size = parse_result.outer_diameter
                    except:
                        pass

            if not effective_round_size:
                result['error'] = f"Cannot determine round size for {program_number}"
                conn.close()
                return result

            # Find next available number in correct range
            new_number = self.find_next_available_number(effective_round_size)
            if not new_number:
                result['error'] = f"No available numbers in range for round size {effective_round_size}"
                conn.close()
                return result

            result['new_number'] = new_number

            if dry_run:
                conn.close()
                result['success'] = True
                return result

            # Perform the rename
            if file_path and os.path.exists(file_path):
                # Generate new file path in repository
                old_dir = os.path.dirname(file_path)
                new_filename = f"{new_number}.nc"
                new_file_path = os.path.join(old_dir, new_filename)
                result['new_file_path'] = new_file_path

                # Check if destination already exists
                if os.path.exists(new_file_path):
                    result['error'] = f"Destination file already exists: {new_file_path}"
                    conn.close()
                    return result

                # Read file content
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                # Extract base number without suffix for replacement
                # The DB program number might be o80001(1), but file content has O80001
                suffix_pattern = re.compile(r'^(o?)(\d+)([(_]\d+[)]?)$', re.IGNORECASE)
                match = suffix_pattern.match(program_number)
                if match:
                    old_num_base = match.group(2)
                else:
                    old_num_base = program_number.replace('o', '').replace('O', '')

                new_num_plain = new_number.replace('o', '').replace('O', '')

                # Also try to find the actual O-number in the file (might be different)
                internal_number = self.extract_internal_program_number(file_path)
                if internal_number:
                    internal_num_plain = internal_number.replace('o', '').replace('O', '')
                else:
                    internal_num_plain = old_num_base

                # Replace program number in file content - try both the base number and internal number
                updated_content = content

                # First try the internal number from the file
                updated_content = re.sub(
                    rf'^[oO]{internal_num_plain}\b',
                    f'O{new_num_plain}',
                    updated_content,
                    flags=re.MULTILINE
                )

                # Also replace if base number is different from internal
                if internal_num_plain != old_num_base:
                    updated_content = re.sub(
                        rf'^[oO]{old_num_base}\b',
                        f'O{new_num_plain}',
                        updated_content,
                        flags=re.MULTILINE
                    )

                # Write to new file
                with open(new_file_path, 'w', encoding='utf-8') as f:
                    f.write(updated_content)

                # Delete old file if different path and new file was created successfully
                if os.path.exists(new_file_path):
                    if file_path.lower() != new_file_path.lower() and os.path.exists(file_path):
                        os.remove(file_path)
                else:
                    result['error'] = f"Failed to create new file: {new_file_path}"
                    conn.close()
                    return result

            else:
                new_file_path = None
                result['new_file_path'] = None

            # Update database
            cursor.execute("""
                UPDATE programs
                SET program_number = ?,
                    file_path = ?,
                    last_modified = ?
                WHERE program_number = ?
            """, (new_number, new_file_path or file_path, datetime.now().isoformat(), program_number))

            # Update registry
            self.sync_registry_for_operation('RENAME', program_number, new_number, new_file_path or file_path)

            conn.commit()
            conn.close()

            result['success'] = True
            return result

        except Exception as e:
            result['error'] = str(e)
            return result

    def resolve_all_suffix_programs(self, dry_run=False, progress_callback=None):
        """
        Resolve all programs with suffix placeholders to proper unique numbers.

        Args:
            dry_run: If True, only simulate without making changes
            progress_callback: Function(current, total, message) for progress updates

        Returns:
            dict: Statistics about the resolution process
        """
        stats = {
            'total': 0,
            'resolved': 0,
            'failed': 0,
            'skipped': 0,
            'errors': [],
            'renames': []
        }

        try:
            # Find all suffix programs
            suffix_programs = self.find_suffix_programs()
            stats['total'] = len(suffix_programs)

            if stats['total'] == 0:
                return stats

            for i, prog in enumerate(suffix_programs):
                if progress_callback:
                    progress_callback(i + 1, stats['total'], f"Resolving {prog['program_number']}...")

                result = self.resolve_suffix_program(prog['program_number'], dry_run=dry_run)

                if result['success']:
                    stats['resolved'] += 1
                    stats['renames'].append({
                        'old': result['old_number'],
                        'new': result['new_number'],
                        'title': prog['title']
                    })
                else:
                    stats['failed'] += 1
                    stats['errors'].append({
                        'program': prog['program_number'],
                        'error': result['error']
                    })

            return stats

        except Exception as e:
            stats['errors'].append({'program': 'BATCH', 'error': str(e)})
            return stats

    def check_for_duplicates(self, source_path, file_hash=None):
        """
        Multi-layered duplicate detection with enhanced similarity checking.

        Args:
            source_path: Path to file being imported
            file_hash: Pre-computed hash (optional, will compute if not provided)

        Returns:
            dict: {
                'is_duplicate': bool,
                'duplicate_type': str | None,  # 'CONTENT_EXACT', 'CONTENT_SIMILAR', 'FILENAME', 'NUMBER'
                'existing_record': dict | None,
                'similar_files': list,  # Files with similar dimensions
                'recommendation': str,  # 'SKIP', 'REPLACE', 'ASSIGN_NEW_NUMBER', 'REVIEW', 'PROCEED'
                'comparison': dict | None  # Detailed comparison if similar
            }
        """
        result = {
            'is_duplicate': False,
            'duplicate_type': None,
            'existing_record': None,
            'similar_files': [],
            'recommendation': 'PROCEED',
            'comparison': None
        }

        try:
            # Compute hash if not provided
            if file_hash is None:
                file_hash = self.compute_file_hash(source_path)

            if not file_hash:
                return result

            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Check 1: EXACT content hash match (regardless of filename)
            cursor.execute("""
                SELECT program_number, title, file_path
                FROM programs
                WHERE content_hash = ?
            """, (file_hash,))
            existing = cursor.fetchone()
            if existing:
                result['is_duplicate'] = True
                result['duplicate_type'] = 'CONTENT_EXACT'
                result['existing_record'] = {
                    'program_number': existing[0],
                    'title': existing[1],
                    'file_path': existing[2]
                }
                result['recommendation'] = 'SKIP'
                conn.close()
                return result

            # Get filename and internal O-number
            filename = os.path.basename(source_path)
            filename_base = os.path.splitext(filename)[0].lower()
            internal_number = self.extract_internal_program_number(source_path)

            # Check 2: Filename collision (same filename exists but different content)
            cursor.execute("""
                SELECT program_number, title, file_path, content_hash
                FROM programs
                WHERE LOWER(program_number) = ?
            """, (filename_base,))
            existing = cursor.fetchone()
            if existing:
                result['is_duplicate'] = True
                result['duplicate_type'] = 'FILENAME'
                result['existing_record'] = {
                    'program_number': existing[0],
                    'title': existing[1],
                    'file_path': existing[2],
                    'content_hash': existing[3]
                }

                # Compare the files to decide what to do
                if existing[2] and os.path.exists(existing[2]):
                    comparison = self.compare_file_contents(source_path, existing[2])
                    result['comparison'] = comparison

                    if comparison['identical']:
                        result['duplicate_type'] = 'CONTENT_EXACT'
                        result['recommendation'] = 'SKIP'
                    elif comparison['common_lines_percent'] > 95:
                        result['duplicate_type'] = 'CONTENT_SIMILAR'
                        # Keep the larger file (more complete)
                        if comparison['file1_size'] > comparison['file2_size']:
                            result['recommendation'] = 'REPLACE_EXISTING'
                        else:
                            result['recommendation'] = 'SKIP'
                    else:
                        result['recommendation'] = 'ASSIGN_NEW_NUMBER'
                else:
                    result['recommendation'] = 'ASSIGN_NEW_NUMBER'

                conn.close()
                return result

            # Check 3: Internal O-number collision (file has O-number already in use)
            if internal_number:
                cursor.execute("""
                    SELECT program_number, title, file_path
                    FROM programs
                    WHERE LOWER(program_number) = ?
                """, (internal_number.lower(),))
                existing = cursor.fetchone()
                if existing:
                    result['is_duplicate'] = True
                    result['duplicate_type'] = 'NUMBER'
                    result['existing_record'] = {
                        'program_number': existing[0],
                        'title': existing[1],
                        'file_path': existing[2]
                    }
                    result['recommendation'] = 'ASSIGN_NEW_NUMBER'
                    conn.close()
                    return result

            conn.close()
            return result

        except sqlite3.Error as e:
            logger.error(f"Database error checking for duplicates: {e}")
            return result
        except Exception as e:
            logger.error(f"Error checking for duplicates: {e}", exc_info=True)
            return result

    def cascade_refresh(self, trigger='unknown', affected_numbers=None):
        """
        Refresh all dependent systems after a file operation.

        Args:
            trigger: What caused the refresh ('import', 'delete', 'rename', 'sync', 'integrity')
            affected_numbers: Specific program numbers affected (for targeted refresh)
        """
        logger.debug(f"Cascade refresh starting - trigger: {trigger}, affected: {affected_numbers}")
        try:
            # 1. Refresh the UI tree view
            logger.debug("Cascade refresh: refreshing results...")
            self.refresh_results()
            logger.debug("Cascade refresh: results refreshed")

            # 2. Refresh filter values (in case new values appeared)
            logger.debug("Cascade refresh: refreshing filter values...")
            self.refresh_filter_values()
            logger.debug("Cascade refresh: filter values refreshed")

            # 3. Log completion
            logger.debug(f"Cascade refresh completed for trigger: {trigger}")

        except Exception as e:
            logger.error(f"Error during cascade refresh: {e}", exc_info=True)

    def process_new_file(self, source_path, import_mode='repository', auto_resolve_collision=True):
        """
        Central entry point for ALL file additions to the system.

        Args:
            source_path: Path to the file to import
            import_mode: 'repository' (copy to managed folder) or 'external' (reference only)
            auto_resolve_collision: If True, automatically assign new number on collision

        Returns:
            dict: {
                'success': bool,
                'program_number': str,
                'file_path': str,
                'collision_type': str | None,
                'original_number': str | None,
                'new_number': str | None,
                'warnings': list[str],
                'errors': list[str]
            }
        """
        import re
        from datetime import datetime
        import json

        result = {
            'success': False,
            'program_number': None,
            'file_path': None,
            'collision_type': None,
            'original_number': None,
            'new_number': None,
            'warnings': [],
            'errors': []
        }

        try:
            # Step 1: Validate file exists
            if not os.path.exists(source_path):
                result['errors'].append(f"File not found: {source_path}")
                return result

            # Step 2: Compute content hash
            file_hash = self.compute_file_hash(source_path)
            if not file_hash:
                result['errors'].append("Could not compute file hash")
                return result

            # Step 3: Check for duplicates
            dup_check = self.check_for_duplicates(source_path, file_hash)

            if dup_check['is_duplicate']:
                if dup_check['duplicate_type'] == 'CONTENT_EXACT':
                    # Exact content duplicate - skip (file already exists with same content)
                    result['warnings'].append(
                        f"Exact duplicate of {dup_check['existing_record']['program_number']} - skipped"
                    )
                    result['collision_type'] = 'CONTENT_EXACT'
                    result['program_number'] = dup_check['existing_record']['program_number']
                    return result

                elif dup_check['duplicate_type'] == 'CONTENT_SIMILAR':
                    # Very similar content (>95% same) - handle based on recommendation
                    if dup_check['recommendation'] == 'SKIP':
                        result['warnings'].append(
                            f"Very similar to {dup_check['existing_record']['program_number']} (existing is larger) - skipped"
                        )
                        result['collision_type'] = 'CONTENT_SIMILAR'
                        result['program_number'] = dup_check['existing_record']['program_number']
                        return result
                    elif dup_check['recommendation'] == 'REPLACE_EXISTING':
                        # New file is larger/more complete - will replace existing
                        result['collision_type'] = 'CONTENT_SIMILAR'
                        result['original_number'] = dup_check['existing_record']['program_number']
                        result['warnings'].append(
                            f"Replacing {result['original_number']} with more complete version"
                        )
                        # Use the existing program number (will overwrite)
                        result['new_number'] = None  # Not assigning new, just replacing

                elif dup_check['duplicate_type'] in ('FILENAME', 'NUMBER'):
                    if auto_resolve_collision:
                        result['collision_type'] = dup_check['duplicate_type']
                        result['original_number'] = dup_check['existing_record']['program_number']
                        result['warnings'].append(
                            f"Collision with {result['original_number']} - will assign new number"
                        )
                    else:
                        result['errors'].append(
                            f"Collision with {dup_check['existing_record']['program_number']}"
                        )
                        return result

            # Step 4: Parse the G-code file
            try:
                parse_result = self.parser.parse_file(source_path)
                if parse_result is None:
                    result['errors'].append(f"Parse failed: Could not parse file (returned None)")
                    return result
            except Exception as e:
                result['errors'].append(f"Parse error: {e}")
                return result

            # Step 4.5: Optional file scanning (Phase 1 feature)
            if self.config.get('scan_on_import', True):
                try:
                    scan_results = self.file_scanner.scan_file_for_issues(source_path)

                    # Add scan warnings to result object
                    if scan_results.get('warnings'):
                        for warning in scan_results['warnings']:
                            result['warnings'].append(f"[{warning['category']}] {warning['message']}")

                    # Critical errors might block import (if strict mode enabled)
                    if self.config.get('scan_strict_mode', False) and scan_results.get('errors'):
                        for error in scan_results['errors']:
                            result['errors'].append(f"[CRITICAL] {error['message']}")
                        # If we have critical errors in strict mode, stop here
                        if result['errors']:
                            return result

                    # Store scan results for later reference
                    result['scan_results'] = scan_results

                    # Step 4.6: Auto-fix if enabled (Phase 1.4)
                    if self.config.get('scan_auto_fix', False) and scan_results.get('warnings'):
                        try:
                            logger.info("Auto-fix enabled - attempting to fix issues...")

                            # Read file content
                            with open(source_path, 'r') as f:
                                content = f.read()

                            # Apply fixes
                            fixed_content, fixes_applied = AutoFixer.apply_all_fixes(content, scan_results)

                            if fixes_applied:
                                # Save fixed version to temporary file
                                temp_file = source_path + '.fixed.tmp'
                                with open(temp_file, 'w') as f:
                                    f.write(fixed_content)

                                # Update source_path to use fixed version
                                source_path = temp_file
                                result['warnings'].append(f"Auto-fixed {len(fixes_applied)} issue(s): {', '.join(fixes_applied)}")
                                logger.info(f"Applied {len(fixes_applied)} auto-fixes")

                                # Re-parse fixed file
                                parse_result = self.parser.parse_file(source_path)
                        except Exception as e:
                            logger.warning(f"Auto-fix failed: {e}")
                            # Continue with original file

                except Exception as e:
                    logger.warning(f"File scanning failed: {e}")
                    # Don't block import if scanning fails

            # Step 5: Determine program number
            internal_number = self.extract_internal_program_number(source_path)
            filename_base = os.path.splitext(os.path.basename(source_path))[0].lower()

            # Decide what program number to use
            if result['collision_type']:
                # Need to assign a new number
                round_size = parse_result.outer_diameter
                new_number = self.find_next_available_number(round_size)
                if not new_number:
                    result['errors'].append("No available program numbers in range")
                    return result
                result['new_number'] = new_number
                program_number = new_number
            elif internal_number:
                program_number = internal_number
            else:
                program_number = filename_base

            result['program_number'] = program_number

            # Step 6: Copy to repository if needed
            if import_mode == 'repository':
                new_filename = f"{program_number}.nc"
                final_path = os.path.join(self.repository_path, new_filename)

                # If file already exists at destination, check if content is different
                if os.path.exists(final_path) and final_path.lower() != source_path.lower():
                    # Check if content is actually different before archiving
                    import filecmp
                    files_are_identical = filecmp.cmp(source_path, final_path, shallow=False)

                    if files_are_identical:
                        # Same content - no need to archive or copy, but STILL add to database
                        logger.debug(f"File {program_number} already exists with identical content, skipping copy (will still add to DB)")
                        result['file_path'] = final_path
                    else:
                        # Different content - check if it's a different PART or just an update
                        # Get existing file's data from database
                        temp_conn = sqlite3.connect(self.db_path, timeout=30.0)
                        temp_cursor = temp_conn.cursor()
                        temp_cursor.execute("""
                            SELECT title, outer_diameter, thickness, center_bore, hub_diameter,
                                   counter_bore_diameter, spacer_type
                            FROM programs WHERE program_number = ?
                        """, (program_number,))
                        existing_data = temp_cursor.fetchone()
                        temp_conn.close()

                        # Compare key dimensions to determine if it's the same part
                        is_different_part = False
                        if existing_data:
                            existing_title, existing_od, existing_thick, existing_cb, existing_hub_d, existing_step_d, existing_type = existing_data
                            new_od = parse_result.outer_diameter
                            new_thick = parse_result.thickness
                            new_cb = parse_result.center_bore
                            new_hub_d = parse_result.hub_diameter
                            new_step_d = parse_result.counter_bore_diameter
                            new_type = parse_result.spacer_type

                            # Check if key dimensions differ significantly (different part)
                            def dims_differ(old, new, tolerance=0.01):
                                if old is None or new is None:
                                    return old != new
                                return abs(float(old) - float(new)) > tolerance

                            # If OD, thickness, CB, hub diameter, or step diameter differ, it's a different part
                            if (dims_differ(existing_od, new_od) or
                                dims_differ(existing_thick, new_thick) or
                                dims_differ(existing_cb, new_cb) or
                                dims_differ(existing_hub_d, new_hub_d) or
                                dims_differ(existing_step_d, new_step_d) or
                                (existing_type and new_type and existing_type != new_type)):
                                is_different_part = True
                                logger.info(f"File {program_number}: Different part detected (dims don't match existing)")
                                logger.debug(f"  Existing: OD={existing_od}, T={existing_thick}, CB={existing_cb}, Hub={existing_hub_d}, Step={existing_step_d}")
                                logger.debug(f"  New:      OD={new_od}, T={new_thick}, CB={new_cb}, Hub={new_hub_d}, Step={new_step_d}")

                        if is_different_part:
                            # Different part with same program number - assign new number
                            round_size = parse_result.outer_diameter
                            new_number = self.find_next_available_number(round_size)
                            if new_number:
                                logger.info(f"Assigning new program number {new_number} to avoid overwriting different part {program_number}")
                                result['original_number'] = program_number
                                result['new_number'] = new_number
                                result['collision_type'] = 'DIFFERENT_PART'
                                result['warnings'].append(f"Different part than existing {program_number}, assigned {new_number}")
                                program_number = new_number
                                result['program_number'] = new_number
                                new_filename = f"{program_number}.nc"
                                final_path = os.path.join(self.repository_path, new_filename)
                            else:
                                result['errors'].append(f"Could not find available number for different part (original: {program_number})")
                                return result

                            # Copy with new name
                            import shutil
                            shutil.copy2(source_path, final_path)
                            result['file_path'] = final_path
                        else:
                            # Same part, updated version - archive old and replace
                            logger.info(f"Updated version detected for {program_number}, archiving old version")
                            if hasattr(self, 'repo_manager') and self.repo_manager:
                                self.repo_manager.archive_file(final_path, "replaced_by_update")

                            # Copy new file
                            import shutil
                            shutil.copy2(source_path, final_path)
                            result['file_path'] = final_path
                elif source_path.lower() != final_path.lower():
                    # File doesn't exist at destination - just copy
                    import shutil
                    shutil.copy2(source_path, final_path)
                    result['file_path'] = final_path
                else:
                    # Source and destination are the same file
                    result['file_path'] = final_path

                # Update internal O-number if we assigned a new one
                if result['new_number']:
                    self._update_internal_program_number(final_path, result['new_number'])
            else:
                result['file_path'] = source_path

            # Step 6.5: Safety check before database write (Phase 1)
            safe, level, msg = self._check_database_safety_before_write("import_file")
            if not safe:
                result['errors'].append(f"Operation cancelled by safety check: {msg}")
                logger.info(f"Import cancelled by safety check: {msg}")
                return result

            # Step 7: Update database
            logger.debug(f"Step 7: Updating database for {program_number}, file_path={result.get('file_path')}")
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Determine validation status
            validation_status = "PASS"
            if parse_result.validation_issues:
                validation_status = "CRITICAL"
            elif parse_result.bore_warnings:
                validation_status = "BORE_WARNING"
            elif parse_result.dimensional_issues:
                validation_status = "DIMENSIONAL"
            elif parse_result.validation_warnings:
                validation_status = "WARNING"

            # Check if program exists
            cursor.execute("SELECT 1 FROM programs WHERE program_number = ?", (program_number,))
            exists = cursor.fetchone()

            now = datetime.now().isoformat()

            if exists:
                # Update existing record
                cursor.execute("""
                    UPDATE programs SET
                        title = ?, outer_diameter = ?, thickness = ?, thickness_display = ?,
                        center_bore = ?, hub_height = ?, hub_diameter = ?,
                        counter_bore_diameter = ?, counter_bore_depth = ?,
                        material = ?, file_path = ?, last_modified = ?,
                        validation_status = ?, validation_issues = ?, validation_warnings = ?,
                        bore_warnings = ?, dimensional_issues = ?,
                        cb_from_gcode = ?, ob_from_gcode = ?, content_hash = ?,
                        is_managed = ?, round_size = ?,
                        tool_home_status = ?, tool_home_issues = ?
                    WHERE program_number = ?
                """, (
                    parse_result.title, parse_result.outer_diameter,
                    parse_result.thickness, parse_result.thickness_display,
                    parse_result.center_bore, parse_result.hub_height, parse_result.hub_diameter,
                    parse_result.counter_bore_diameter, parse_result.counter_bore_depth,
                    parse_result.material, result['file_path'], now,
                    validation_status,
                    json.dumps(parse_result.validation_issues) if parse_result.validation_issues else None,
                    json.dumps(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                    json.dumps(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                    json.dumps(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                    parse_result.cb_from_gcode, parse_result.ob_from_gcode, file_hash,
                    1 if import_mode == 'repository' else 0,
                    parse_result.outer_diameter,
                    parse_result.tool_home_status,
                    json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                    program_number
                ))
            else:
                # Insert new record
                cursor.execute("""
                    INSERT INTO programs (
                        program_number, title, spacer_type, outer_diameter, thickness, thickness_display,
                        center_bore, hub_height, hub_diameter, counter_bore_diameter, counter_bore_depth,
                        material, file_path, date_created, last_modified,
                        validation_status, validation_issues, validation_warnings,
                        bore_warnings, dimensional_issues, cb_from_gcode, ob_from_gcode,
                        content_hash, is_managed, round_size, round_size_confidence, round_size_source, in_correct_range,
                        tool_home_status, tool_home_issues,
                        feasibility_status, feasibility_issues, feasibility_warnings,
                        crash_issues, crash_warnings,
                        is_deleted, deleted_date
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    program_number, parse_result.title, parse_result.spacer_type or 'Unknown',
                    parse_result.outer_diameter, parse_result.thickness, parse_result.thickness_display,
                    parse_result.center_bore, parse_result.hub_height, parse_result.hub_diameter,
                    parse_result.counter_bore_diameter, parse_result.counter_bore_depth,
                    parse_result.material, result['file_path'], now, now,
                    validation_status,
                    json.dumps(parse_result.validation_issues) if parse_result.validation_issues else None,
                    json.dumps(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                    json.dumps(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                    json.dumps(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                    parse_result.cb_from_gcode, parse_result.ob_from_gcode,
                    file_hash,
                    1 if import_mode == 'repository' else 0,
                    parse_result.outer_diameter, 'HIGH', 'PARSED',
                    1 if self.is_in_correct_range(program_number, parse_result.outer_diameter) else 0,
                    parse_result.tool_home_status,
                    json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                    parse_result.feasibility_status,
                    json.dumps(parse_result.feasibility_issues) if parse_result.feasibility_issues else None,
                    json.dumps(parse_result.feasibility_warnings) if parse_result.feasibility_warnings else None,
                    json.dumps(parse_result.crash_issues) if parse_result.crash_issues else None,
                    json.dumps(parse_result.crash_warnings) if parse_result.crash_warnings else None,
                    0, None  # is_deleted, deleted_date
                ))

            conn.commit()
            conn.close()

            # Record successful database write (Phase 1)
            self._record_database_write("import_file")

            # Step 8: Sync registry
            if result['original_number'] and result['new_number']:
                self.sync_registry_for_operation('RENAME', result['original_number'], result['new_number'], result['file_path'])
            else:
                self.sync_registry_for_operation('ADD', None, program_number, result['file_path'])

            result['success'] = True
            logger.debug(f"Successfully processed {program_number}")
            return result

        except Exception as e:
            logger.error(f"Exception in process_new_file for {result.get('program_number', 'unknown')}: {e}", exc_info=True)
            result['errors'].append(f"Unexpected error: {str(e)}")
            import traceback
            traceback.print_exc()
            return result

    def scan_file_before_import(self):
        """Scan a G-code file and show results without importing (Phase 1 feature)"""
        if not self.has_permission('add_files'):
            messagebox.showerror("Permission Denied", "You don't have permission to scan files.")
            return

        file_path = filedialog.askopenfilename(
            title="Select G-Code File to Scan",
            filetypes=[("G-Code Files", "*.nc *.NC"), ("All Files", "*.*")],
            initialdir=self.config.get('last_folder', '')
        )

        if not file_path:
            return

        try:
            # Perform scan
            scan_results = self.file_scanner.scan_file_for_issues(file_path)

            # Show results dialog
            self.show_scan_results_dialog(scan_results, file_path)

        except Exception as e:
            messagebox.showerror("Scan Error", f"Failed to scan file:\n{str(e)}")

    def show_scan_results_dialog(self, scan_results, file_path):
        """Show scan results in a structured, severity-ordered dialog."""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Scan Results - {os.path.basename(file_path)}")
        dialog.geometry("760x700")
        dialog.configure(bg=self.bg_color)

        # ── Header ──────────────────────────────────────────────────────
        header = tk.Frame(dialog, bg=self.bg_color)
        header.pack(fill=tk.X, padx=10, pady=10)
        tk.Label(header, text=f"File: {os.path.basename(file_path)}",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 11, "bold")).pack(anchor='w')

        # ── Counts ──────────────────────────────────────────────────────
        all_errors      = scan_results.get('errors', [])
        all_warnings    = scan_results.get('warnings', [])
        all_suggestions = scan_results.get('suggestions', [])

        crashes       = [e for e in all_errors if e.get('type') == 'crash']
        other_errors  = [e for e in all_errors if e.get('type') != 'crash']
        warnings_count    = len(all_warnings)
        errors_count      = len(all_errors)
        crashes_count     = len(crashes)
        other_errors_count = len(other_errors)
        suggestions_count = len(all_suggestions)

        # ── Summary bar ─────────────────────────────────────────────────
        summary_frame = tk.Frame(dialog, bg=self.bg_color, relief=tk.RIDGE, borderwidth=2)
        summary_frame.pack(fill=tk.X, padx=10, pady=5)

        if crashes_count > 0:
            status_color = "#FF1744"
            parts = [f"🔴 {crashes_count} Crash(es)"]
            if other_errors_count: parts.append(f"✗ {other_errors_count} Error(s)")
            if warnings_count:     parts.append(f"⚠ {warnings_count} Warning(s)")
            status_text = "  |  ".join(parts)
        elif other_errors_count > 0:
            status_color = "#F44336"
            status_text = f"✗ {other_errors_count} Error(s)"
            if warnings_count: status_text += f"  |  ⚠ {warnings_count} Warning(s)"
        elif warnings_count > 0:
            status_color = "#FF9800"
            status_text = f"⚠ {warnings_count} Warning(s)"
        else:
            status_color = "#4CAF50"
            status_text = "✓ PASS"

        if suggestions_count:
            status_text += f"  |  💡 {suggestions_count} Suggestion(s)"

        tk.Label(summary_frame, text=status_text,
                 bg=self.bg_color, fg=status_color,
                 font=("Arial", 10, "bold")).pack(pady=5)

        # ── Metadata grid (all available fields) ────────────────────────
        dims   = scan_results.get('dimensions', {}) or {}
        tools  = scan_results.get('tools_used')  or []
        pcodes = scan_results.get('pcodes_found') or []

        meta_pairs = []
        if scan_results.get('program_number'):
            meta_pairs.append(("Program",     scan_results['program_number']))
        if scan_results.get('title'):
            meta_pairs.append(("Title",       scan_results['title']))
        if scan_results.get('spacer_type'):
            meta_pairs.append(("Type",        scan_results['spacer_type']))
        if scan_results.get('material'):
            meta_pairs.append(("Material",    scan_results['material']))
        if dims.get('outer_diameter'):
            meta_pairs.append(("OD",          f"{dims['outer_diameter']:.3f}\""))
        if scan_results.get('round_size'):
            meta_pairs.append(("Round Size",  f"{scan_results['round_size']}\""))
        if dims.get('thickness'):
            meta_pairs.append(("Thickness",   f"{dims['thickness']:.4f}\""))
        if dims.get('center_bore'):
            meta_pairs.append(("Center Bore", f"{dims['center_bore']:.3f}\""))
        if dims.get('hub_diameter'):
            meta_pairs.append(("Hub Dia",     f"{dims['hub_diameter']:.3f}\""))
        if dims.get('hub_height'):
            meta_pairs.append(("Hub Height",  f"{dims['hub_height']:.3f}\""))
        if dims.get('counter_bore_diameter'):
            meta_pairs.append(("CB Dia",      f"{dims['counter_bore_diameter']:.3f}\""))
        if dims.get('counter_bore_depth'):
            meta_pairs.append(("CB Depth",    f"{dims['counter_bore_depth']:.3f}\""))

        if meta_pairs:
            meta_frame = tk.Frame(summary_frame, bg=self.bg_color)
            meta_frame.pack(fill=tk.X, padx=10, pady=(2, 4))
            for i, (lbl_text, val_text) in enumerate(meta_pairs):
                col = (i % 2) * 2
                row = i // 2
                tk.Label(meta_frame, text=f"{lbl_text}:",
                         bg=self.bg_color, fg="#90CAF9",
                         font=("Consolas", 9, "bold"),
                         anchor='e', width=12).grid(row=row, column=col, sticky='e', padx=(4, 2))
                tk.Label(meta_frame, text=val_text,
                         bg=self.bg_color, fg=self.fg_color,
                         font=("Consolas", 9),
                         anchor='w').grid(row=row, column=col + 1, sticky='w', padx=(0, 20))

        if tools:
            tools_row = tk.Frame(summary_frame, bg=self.bg_color)
            tools_row.pack(fill=tk.X, padx=10, pady=(0, 2))
            tk.Label(tools_row, text="Tools:", bg=self.bg_color, fg="#90CAF9",
                     font=("Consolas", 9, "bold")).pack(side=tk.LEFT, padx=4)
            tk.Label(tools_row, text=", ".join(str(t) for t in tools),
                     bg=self.bg_color, fg=self.fg_color,
                     font=("Consolas", 9)).pack(side=tk.LEFT)

        if pcodes:
            pcodes_row = tk.Frame(summary_frame, bg=self.bg_color)
            pcodes_row.pack(fill=tk.X, padx=10, pady=(0, 4))
            tk.Label(pcodes_row, text="P-Codes:", bg=self.bg_color, fg="#90CAF9",
                     font=("Consolas", 9, "bold")).pack(side=tk.LEFT, padx=4)
            tk.Label(pcodes_row, text=", ".join(str(p) for p in pcodes),
                     bg=self.bg_color, fg=self.fg_color,
                     font=("Consolas", 9)).pack(side=tk.LEFT)

        # ── Issues area ─────────────────────────────────────────────────
        issues_frame = tk.Frame(dialog, bg=self.bg_color)
        issues_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        tk.Label(issues_frame,
                 text="Issues  (most severe → least severe):",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 10, "bold")).pack(anchor='w')

        issues_text = scrolledtext.ScrolledText(
            issues_frame, height=22, width=86,
            bg=self.input_bg, fg=self.fg_color,
            font=("Consolas", 9), wrap=tk.WORD)
        issues_text.pack(fill=tk.BOTH, expand=True)

        # ── Text tags ────────────────────────────────────────────────────
        issues_text.tag_configure("crash_hdr",   foreground="#FF1744", font=("Consolas", 10, "bold"))
        issues_text.tag_configure("error_hdr",   foreground="#F44336", font=("Consolas", 10, "bold"))
        issues_text.tag_configure("warning_hdr", foreground="#FF9800", font=("Consolas", 10, "bold"))
        issues_text.tag_configure("suggest_hdr", foreground="#42A5F5", font=("Consolas", 10, "bold"))
        issues_text.tag_configure("cat_crash",   foreground="#FF6D6D", font=("Consolas",  9, "bold"))
        issues_text.tag_configure("cat_error",   foreground="#EF9A9A", font=("Consolas",  9, "bold"))
        issues_text.tag_configure("cat_warn",    foreground="#FFCC80", font=("Consolas",  9, "bold"))
        issues_text.tag_configure("cat_suggest", foreground="#90CAF9", font=("Consolas",  9, "bold"))
        issues_text.tag_configure("item_crash",   foreground="#FF6D6D")
        issues_text.tag_configure("item_error",   foreground="#EF9A9A")
        issues_text.tag_configure("item_warn",    foreground="#FFCC80")
        issues_text.tag_configure("item_suggest", foreground="#90CAF9")
        issues_text.tag_configure("pass_msg",     foreground="#4CAF50", font=("Consolas", 9, "bold"))

        DIV = "─" * 70 + "\n"

        def insert_section(title, items, hdr_tag, cat_tag, item_tag, icon):
            """Render one severity band grouped by category."""
            if not items:
                return
            issues_text.insert(tk.END, DIV, hdr_tag)
            issues_text.insert(tk.END, f"  {icon}  {title}  ({len(items)})\n", hdr_tag)
            issues_text.insert(tk.END, DIV, hdr_tag)
            issues_text.insert(tk.END, "\n")

            # Group by category, preserving insertion order
            groups = {}
            for item in items:
                cat = item.get('category', 'General')
                groups.setdefault(cat, []).append(item)

            for cat, cat_items in groups.items():
                issues_text.insert(tk.END, f"  {cat}:\n", cat_tag)
                for it in cat_items:
                    msg = it.get('message', '').strip()
                    issues_text.insert(tk.END, f"       {icon} {msg}\n", item_tag)
                issues_text.insert(tk.END, "\n")

        total = errors_count + warnings_count + suggestions_count

        if total == 0:
            issues_text.insert(tk.END,
                "\n  ✓  No issues found — file looks good!\n", "pass_msg")
        else:
            # Ordered: crashes → errors → warnings → suggestions
            insert_section("CRASHES",              crashes,       "crash_hdr",   "cat_crash",   "item_crash",   "✗")
            insert_section("ERRORS",               other_errors,  "error_hdr",   "cat_error",   "item_error",   "✗")
            insert_section("WARNINGS",             all_warnings,  "warning_hdr", "cat_warn",    "item_warn",    "⚠")
            insert_section("SUGGESTIONS",          all_suggestions, "suggest_hdr", "cat_suggest", "item_suggest", "💡")

            if not crashes and not other_errors and not all_warnings and all_suggestions:
                issues_text.insert(tk.END,
                    "\n  ✓  File PASSES validation  "
                    "(suggestions are optional best practices)\n", "pass_msg")

        issues_text.config(state=tk.DISABLED)

        # Buttons
        button_frame = tk.Frame(dialog, bg=self.bg_color)
        button_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(button_frame, text="Close", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=15).pack(side=tk.RIGHT, padx=5)

        tk.Button(button_frame, text="Import File", command=lambda: self._import_from_scan(dialog, file_path),
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 10),
                 width=15).pack(side=tk.RIGHT, padx=5)

        # Show Auto-Fix button only if there are fixable issues
        fixable_warnings = [w for w in scan_results.get('warnings', [])
                           if w.get('type') in ['tool_home', 'validation']]
        if fixable_warnings and self.config.get('auto_fix_tool_home', True):
            tk.Button(button_frame, text="🔧 Auto-Fix & Import",
                     command=lambda: self._auto_fix_and_import_from_scan(dialog, file_path, scan_results),
                     bg="#E91E63", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18).pack(side=tk.RIGHT, padx=5)

    def _import_from_scan(self, dialog, file_path):
        """Import file from scan dialog"""
        dialog.destroy()
        # Trigger import workflow
        self.process_new_files_workflow()

    def _auto_fix_and_import_from_scan(self, dialog, file_path, scan_results):
        """Auto-fix issues in file and then import (Phase 1.4)"""
        try:
            # Check if file has fixable issues
            fixable_warnings = [w for w in scan_results.get('warnings', [])
                               if w.get('type') in ['tool_home', 'validation']]

            if not fixable_warnings:
                messagebox.showinfo("No Fixes Available",
                                   "No auto-fixable issues found in this file.")
                return

            # Confirm with user
            response = messagebox.askyesno(
                "Auto-Fix Confirmation",
                f"Found {len(fixable_warnings)} fixable issue(s):\n\n" +
                "\n".join([f"• {w['message'][:60]}..." if len(w['message']) > 60
                          else f"• {w['message']}" for w in fixable_warnings[:5]]) +
                ("\n..." if len(fixable_warnings) > 5 else "") +
                "\n\nApply fixes and import?",
                icon='question'
            )

            if not response:
                return

            # Create backup if configured
            if self.config.get('auto_fix_create_backup', True):
                backup_path = self.create_auto_backup(f"auto_fix_before_import")
                if backup_path:
                    logger.info(f"Created backup before auto-fix: {backup_path}")

            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Apply fixes
            fixed_content, fixes_applied = AutoFixer.apply_all_fixes(content, scan_results)

            if fixes_applied:
                # Write fixed content to temporary file
                temp_file = file_path + '.autofixed.tmp'
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(fixed_content)

                # Replace original with fixed version
                import shutil
                shutil.move(temp_file, file_path)

                # Show success message
                messagebox.showinfo(
                    "Auto-Fix Applied",
                    f"Successfully applied {len(fixes_applied)} fix(es):\n\n" +
                    "\n".join([f"✓ {fix}" for fix in fixes_applied]) +
                    "\n\nProceeding with import..."
                )

                # Log the fixes
                self.log_activity('auto_fix', details={
                    'file_path': file_path,
                    'fixes': fixes_applied
                })

                # Close dialog and proceed with import
                dialog.destroy()
                self.process_new_files_workflow()
            else:
                messagebox.showwarning("No Fixes Applied",
                                      "No fixes could be applied to this file.")

        except Exception as e:
            logger.error(f"Auto-fix failed: {e}")
            messagebox.showerror("Auto-Fix Failed",
                               f"Failed to apply automatic fixes:\n{str(e)}\n\n"
                               f"You can still import the file without fixes.")

    # ------------------------------------------------------------------
    # Auto-Fix Crash Risks (right-click action on existing DB entry)
    # ------------------------------------------------------------------

    def auto_fix_crash_risks(self):
        """
        Apply AutoFixer.fix_rapid_to_negative_z to the selected file,
        create a backup, write the result, then rescan.
        """
        if not self.has_permission('edit_files'):
            messagebox.showerror("Permission Denied",
                                 "You need edit permission to auto-fix files.")
            return

        selected = self.tree.selection()
        if not selected:
            return

        program_number = self.tree.item(selected[0])['values'][0]

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path, crash_issues FROM programs WHERE program_number = ?",
                       (program_number,))
        row = cursor.fetchone()
        conn.close()

        if not row or not row[0]:
            messagebox.showwarning("Auto-Fix", "No file path found for this program.")
            return

        file_path = row[0]
        if not os.path.exists(file_path):
            messagebox.showwarning("Auto-Fix", f"File not found:\n{file_path}")
            return

        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            original = f.read()

        fixed_content, changes = AutoFixer.fix_rapid_to_negative_z(original)

        if not changes:
            messagebox.showinfo("Auto-Fix: G00 Crash Risks",
                                "No explicit G00 rapid-to-negative-Z patterns found.\n"
                                "File is already safe (or only modal G00 cases exist,\n"
                                "which require manual review).")
            return

        change_summary = "\n".join(f"  • {c}" for c in changes)
        confirmed = messagebox.askyesno(
            "Auto-Fix: G00 Crash Risks",
            f"Found {len(changes)} line(s) to fix in {program_number}:\n\n"
            f"{change_summary}\n\n"
            f"A backup will be created before saving.\n\nApply fixes?",
            icon='warning'
        )
        if not confirmed:
            return

        # Backup
        import shutil
        backup_path = file_path + '.crash_fix_backup'
        shutil.copy2(file_path, backup_path)

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(fixed_content)

        logger.info(f"Auto-fix crash risks applied to {file_path}: {changes}")

        messagebox.showinfo(
            "Auto-Fix Applied",
            f"Fixed {len(changes)} line(s).\n\n"
            f"{change_summary}\n\n"
            f"Backup saved as:\n{backup_path}\n\n"
            f"Rescanning file..."
        )

        self.refresh_selected_file()

    # ------------------------------------------------------------------
    # Scan Folder for Issues (per-file feedback, no import)
    # ------------------------------------------------------------------

    def scan_folder_for_issues(self):
        """Scan every G-code file in a chosen folder and report per-file issues without importing."""
        if not self.has_permission('add_files'):
            messagebox.showerror("Permission Denied", "You don't have permission to scan files.")
            return

        folder = filedialog.askdirectory(
            title="Select Folder to Scan for Issues",
            initialdir=self.config.get('last_folder', '')
        )
        if not folder:
            return

        import glob
        nc_files = sorted(set(
            glob.glob(os.path.join(folder, '*.nc')) +
            glob.glob(os.path.join(folder, '*.NC'))
        ))

        if not nc_files:
            messagebox.showinfo("No Files Found",
                                f"No .nc or .NC files found in:\n{folder}")
            return

        # --- Progress window ---
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Scanning Folder for Issues...")
        progress_window.geometry("650x420")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text=f"Scanning {len(nc_files)} file(s)...",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 12, "bold")).pack(pady=12)

        from tkinter import ttk
        progress_var = tk.DoubleVar()
        ttk.Progressbar(progress_window, variable=progress_var,
                        maximum=len(nc_files), length=560).pack(pady=4, padx=20)

        current_lbl = tk.Label(progress_window, text="",
                               bg=self.bg_color, fg=self.fg_color,
                               font=("Arial", 9), wraplength=600)
        current_lbl.pack(pady=4, padx=20)

        log_text = scrolledtext.ScrolledText(progress_window,
                                             bg=self.input_bg, fg=self.fg_color,
                                             font=("Courier", 9),
                                             width=75, height=16)
        log_text.pack(padx=10, pady=6, fill=tk.BOTH, expand=True)
        self.root.update()

        # --- Scan loop ---
        all_results = []
        for i, file_path in enumerate(nc_files):
            filename = os.path.basename(file_path)
            current_lbl.config(text=f"Scanning: {filename}")
            log_text.insert(tk.END, f"Scanning {filename}...")
            log_text.see(tk.END)
            self.root.update_idletasks()

            try:
                result = self.file_scanner.scan_file_for_issues(file_path)
                result['file_path'] = file_path
                all_results.append(result)

                errors = len(result.get('errors', []))
                warnings = len(result.get('warnings', []))
                if errors > 0:
                    log_text.insert(tk.END, f"  ✗ {errors} error(s), {warnings} warning(s)\n")
                elif warnings > 0:
                    log_text.insert(tk.END, f"  ⚠ {warnings} warning(s)\n")
                else:
                    log_text.insert(tk.END, "  ✓ PASS\n")

            except Exception as e:
                all_results.append({
                    'file_path': file_path,
                    'success': False,
                    'program_number': '',
                    'round_size': None,
                    'errors': [{'category': 'scan_error', 'message': str(e)}],
                    'warnings': [],
                    'suggestions': [],
                })
                log_text.insert(tk.END, f"  ✗ Scan failed: {e}\n")

            progress_var.set(i + 1)
            log_text.see(tk.END)
            self.root.update_idletasks()

        progress_window.destroy()
        self.show_folder_scan_results_dialog(folder, all_results)

    def show_folder_scan_results_dialog(self, folder, all_results):
        """Display per-file scan results for an entire folder in a results dialog."""
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Folder Scan Results — {os.path.basename(folder)}")
        dialog.geometry("950x680")
        dialog.configure(bg=self.bg_color)

        total = len(all_results)
        passed = sum(1 for r in all_results if not r.get('errors') and not r.get('warnings'))
        with_warnings = sum(1 for r in all_results if not r.get('errors') and r.get('warnings'))
        with_errors = sum(1 for r in all_results if r.get('errors'))

        # Header
        hdr = tk.Frame(dialog, bg=self.bg_color)
        hdr.pack(fill=tk.X, padx=12, pady=(10, 4))
        tk.Label(hdr, text=f"Folder: {folder}",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 10), wraplength=900, justify=tk.LEFT).pack(anchor='w')

        # Summary bar
        summ = tk.Frame(dialog, bg=self.bg_color, relief=tk.RIDGE, borderwidth=2)
        summ.pack(fill=tk.X, padx=12, pady=4)
        inner = tk.Frame(summ, bg=self.bg_color)
        inner.pack(pady=8)
        tk.Label(inner, text=f"Total: {total}",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 11, "bold")).pack(side=tk.LEFT, padx=14)
        tk.Label(inner, text=f"✓ Pass: {passed}",
                 bg=self.bg_color, fg="#4CAF50",
                 font=("Arial", 11, "bold")).pack(side=tk.LEFT, padx=14)
        tk.Label(inner, text=f"⚠ Warnings: {with_warnings}",
                 bg=self.bg_color, fg="#FF9800",
                 font=("Arial", 11, "bold")).pack(side=tk.LEFT, padx=14)
        tk.Label(inner, text=f"✗ Errors: {with_errors}",
                 bg=self.bg_color, fg="#F44336",
                 font=("Arial", 11, "bold")).pack(side=tk.LEFT, padx=14)

        # File list
        list_frame = tk.Frame(dialog, bg=self.bg_color)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=12, pady=4)
        tk.Label(list_frame, text="Files  —  double-click any row for full details:",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 10, "bold")).pack(anchor='w', pady=(0, 3))

        list_container = tk.Frame(list_frame, bg=self.bg_color)
        list_container.pack(fill=tk.BOTH, expand=True)

        sb_y = tk.Scrollbar(list_container, orient=tk.VERTICAL)
        sb_y.pack(side=tk.RIGHT, fill=tk.Y)
        sb_x = tk.Scrollbar(list_container, orient=tk.HORIZONTAL)
        sb_x.pack(side=tk.BOTTOM, fill=tk.X)

        file_listbox = tk.Listbox(list_container,
                                  bg=self.input_bg, fg=self.fg_color,
                                  font=("Consolas", 10),
                                  yscrollcommand=sb_y.set,
                                  xscrollcommand=sb_x.set,
                                  selectbackground=self.accent_color,
                                  activestyle='dotbox',
                                  height=22)
        file_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sb_y.config(command=file_listbox.yview)
        sb_x.config(command=file_listbox.xview)

        result_map = {}
        for idx, result in enumerate(all_results):
            filename = os.path.basename(result['file_path'])
            errors = len(result.get('errors', []))
            warnings = len(result.get('warnings', []))
            suggestions = len(result.get('suggestions', []))
            prog_num = result.get('program_number', '')

            if errors > 0:
                icon, status_str, color = "✗", f"{errors}E  {warnings}W", "#F44336"
            elif warnings > 0:
                icon = "⚠"
                status_str = f"{warnings}W"
                if suggestions:
                    status_str += f"  {suggestions}S"
                color = "#FF9800"
            else:
                icon = "✓"
                status_str = "PASS"
                if suggestions:
                    status_str += f"  {suggestions}S"
                color = "#4CAF50"

            prog_part = f"[{prog_num}]" if prog_num else ""
            line = f"{icon}  {filename:<32} {prog_part:<14} {status_str}"
            file_listbox.insert(tk.END, line)
            file_listbox.itemconfig(idx, fg=color)
            result_map[idx] = result

        def on_double_click(event):
            sel = file_listbox.curselection()
            if sel:
                r = result_map[sel[0]]
                self.show_scan_results_dialog(r, r['file_path'])

        file_listbox.bind('<Double-1>', on_double_click)

        # Bottom buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=12, pady=10)
        tk.Label(btn_frame, text="Double-click a file to view full scan details",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 9, "italic")).pack(side=tk.LEFT)
        tk.Button(btn_frame, text="Export Report",
                  command=lambda: self._export_folder_scan_report(folder, all_results),
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                  width=15).pack(side=tk.RIGHT, padx=5)
        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                  width=10).pack(side=tk.RIGHT, padx=5)

    def _export_folder_scan_report(self, folder, all_results):
        """Save a plain-text folder scan report to a file chosen by the user."""
        from tkinter import filedialog as fd
        from datetime import datetime

        save_path = fd.asksaveasfilename(
            title="Save Folder Scan Report",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")],
            initialfile=f"scan_report_{os.path.basename(folder)}.txt"
        )
        if not save_path:
            return

        total = len(all_results)
        passed = sum(1 for r in all_results if not r.get('errors') and not r.get('warnings'))
        with_warnings = sum(1 for r in all_results if not r.get('errors') and r.get('warnings'))
        with_errors = sum(1 for r in all_results if r.get('errors'))

        lines = [
            "FOLDER SCAN REPORT",
            f"Generated : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Folder    : {folder}",
            "",
            "SUMMARY",
            "-------",
            f"Total Files : {total}",
            f"Pass        : {passed}",
            f"Warnings    : {with_warnings}",
            f"Errors      : {with_errors}",
            "",
            "FILE DETAILS",
            "------------",
        ]

        for result in all_results:
            filename = os.path.basename(result['file_path'])
            errors = result.get('errors', [])
            warnings = result.get('warnings', [])
            suggestions = result.get('suggestions', [])
            prog_num = result.get('program_number', 'Unknown')

            if errors:
                status = f"ERRORS ({len(errors)})"
            elif warnings:
                status = f"WARNINGS ({len(warnings)})"
            else:
                status = "PASS"

            lines += [
                "",
                "=" * 60,
                f"File    : {filename}",
                f"Program : {prog_num}",
                f"Status  : {status}",
            ]
            if errors:
                lines.append("ERRORS:")
                for e in errors:
                    lines.append(f"  x [{e.get('category', '?')}] {e.get('message', '')}")
            if warnings:
                lines.append("WARNINGS:")
                for w in warnings:
                    lines.append(f"  ! [{w.get('category', '?')}] {w.get('message', '')}")
            if suggestions:
                lines.append("SUGGESTIONS:")
                for s in suggestions:
                    lines.append(f"  > [{s.get('category', '?')}] {s.get('message', '')}")

        try:
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(lines))
            messagebox.showinfo("Report Saved", f"Scan report saved to:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Save Failed", f"Could not save report:\n{str(e)}")

    def _update_internal_program_number(self, file_path, new_number):
        """
        Update the internal O-number in a G-code file.

        Args:
            file_path: Path to the file
            new_number: New program number (e.g., 'o80645')
        """
        import re
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Extract just the number part
            num = new_number.replace('o', '').replace('O', '')

            # Replace the O-number (first occurrence on its own line)
            lines = content.split('\n')
            updated = False
            for i, line in enumerate(lines):
                if re.match(r'^[oO]\d{4,}', line.strip()):
                    lines[i] = re.sub(r'^[oO]\d{4,}', f'O{num}', line)
                    updated = True
                    break

            if updated:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(lines))

        except OSError as e:
            logger.error(f"File operation error updating internal program number in {file_path}: {e}")
        except Exception as e:
            logger.error(f"Error updating internal program number: {e}", exc_info=True)

    def verify_repository_integrity(self, fix_issues=False):
        """
        Comprehensive integrity check between filesystem and database.

        Args:
            fix_issues: If True, automatically fix detected issues

        Returns:
            dict: {
                'untracked_files': list,      # Files in repository/ not in DB
                'orphaned_records': list,     # DB records with missing files
                'registry_stale': list,       # Registry entries out of sync
                'fixed': dict                 # What was fixed (if fix_issues=True)
            }
        """
        import glob

        result = {
            'untracked_files': [],
            'orphaned_records': [],
            'registry_stale': [],
            'fixed': {
                'files_added': 0,
                'records_removed': 0,
                'registry_updated': 0
            }
        }

        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all file_paths from database (managed files only)
            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE is_managed = 1 AND file_path IS NOT NULL
            """)
            db_records = {row[1].lower(): row[0] for row in cursor.fetchall() if row[1]}

            # Get all files in repository
            repo_files = glob.glob(os.path.join(self.repository_path, '*'))
            repo_files = [f for f in repo_files if os.path.isfile(f)]

            # Find untracked files (in repo but not in DB)
            for file_path in repo_files:
                if file_path.lower() not in db_records:
                    # Skip non-gcode files
                    import re
                    if re.match(r'^[oO]\d{4,}', os.path.basename(file_path)):
                        result['untracked_files'].append(file_path)

            # Find orphaned records (in DB but file missing)
            for file_path_lower, prog_num in db_records.items():
                if not os.path.exists(file_path_lower):
                    # Try case-insensitive check
                    found = False
                    for repo_file in repo_files:
                        if repo_file.lower() == file_path_lower:
                            found = True
                            break
                    if not found:
                        result['orphaned_records'].append({
                            'program_number': prog_num,
                            'file_path': file_path_lower
                        })

            # Check registry sync
            cursor.execute("""
                SELECT program_number, file_path, status
                FROM program_number_registry
                WHERE status = 'IN_USE'
            """)
            for prog_num, reg_path, status in cursor.fetchall():
                if reg_path and not os.path.exists(reg_path):
                    result['registry_stale'].append({
                        'program_number': prog_num,
                        'file_path': reg_path
                    })

            # Close connection before fix operations to avoid nested connections
            conn.close()
            conn = None

            # Fix issues if requested
            if fix_issues:
                # Add untracked files
                for file_path in result['untracked_files']:
                    import_result = self.process_new_file(file_path, import_mode='repository')
                    if import_result['success']:
                        result['fixed']['files_added'] += 1

                # Remove orphaned records - use single connection for batch
                if result['orphaned_records'] or result['registry_stale']:
                    conn = sqlite3.connect(self.db_path, timeout=30.0)
                    cursor = conn.cursor()

                    for orphan in result['orphaned_records']:
                        cursor.execute("DELETE FROM programs WHERE program_number = ?",
                                     (orphan['program_number'],))
                        result['fixed']['records_removed'] += 1

                    # Fix stale registry entries
                    for stale in result['registry_stale']:
                        cursor.execute("""
                            UPDATE program_number_registry
                            SET status = 'AVAILABLE', file_path = NULL
                            WHERE program_number = ?
                        """, (stale['program_number'],))
                        result['fixed']['registry_updated'] += 1

                    conn.commit()
                    conn.close()
                    conn = None

                # Sync registry for removed orphans (separate connections)
                for orphan in result['orphaned_records']:
                    self.sync_registry_for_operation('REMOVE', orphan['program_number'])

            return result

        except sqlite3.Error as e:
            logger.error(f"Database error verifying integrity: {e}")
            return result
        except Exception as e:
            logger.error(f"Error verifying integrity: {e}", exc_info=True)
            return result
        finally:
            if conn:
                conn.close()

    def check_missing_m30(self, file_path):
        """
        Check if a G-code file is missing the M30 program end code.

        Args:
            file_path: Path to the G-code file

        Returns:
            bool: True if M30 is missing, False if present
        """
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read().upper()

            # Check for M30 (program end) or M02 (program stop - also acceptable)
            # Should be near the end of the file
            last_500_chars = content[-500:] if len(content) > 500 else content

            has_m30 = 'M30' in last_500_chars or 'M02' in last_500_chars
            return not has_m30

        except OSError as e:
            logger.warning(f"File read error checking M30 in {file_path}: {e}")
            return False  # Can't verify, assume OK
        except Exception as e:
            logger.warning(f"Error checking M30 in {file_path}: {e}")
            return False  # Can't verify, assume OK

    def find_missing_m30_programs(self):
        """
        Find all programs missing the M30 program end code.

        Returns:
            list: List of dicts with program_number, title, file_path
        """
        missing = []

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, title, file_path
                FROM programs
                WHERE file_path IS NOT NULL AND is_managed = 1
            """)

            for prog_num, title, file_path in cursor.fetchall():
                if file_path and os.path.exists(file_path):
                    if self.check_missing_m30(file_path):
                        missing.append({
                            'program_number': prog_num,
                            'title': title,
                            'file_path': file_path
                        })

            conn.close()
            return missing

        except sqlite3.Error as e:
            logger.error(f"Database error finding missing M30 programs: {e}")
            return missing
        except Exception as e:
            logger.error(f"Error finding missing M30 programs: {e}", exc_info=True)
            return missing

    def find_duplicate_internal_onumbers(self):
        """
        Find files where the internal O-number doesn't match the filename,
        or multiple files have the same internal O-number.

        Returns:
            dict: {
                'mismatched': list of files where internal != filename,
                'duplicates': dict mapping internal O-number to list of files
            }
        """
        result = {
            'mismatched': [],
            'duplicates': {}
        }

        internal_numbers = {}  # {internal_number: [(prog_num, file_path), ...]}

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE file_path IS NOT NULL AND is_managed = 1
            """)

            for prog_num, file_path in cursor.fetchall():
                if not file_path or not os.path.exists(file_path):
                    continue

                internal_num = self.extract_internal_program_number(file_path)
                if not internal_num:
                    continue

                # Check for mismatch between filename and internal number
                if internal_num.lower() != prog_num.lower():
                    result['mismatched'].append({
                        'program_number': prog_num,
                        'internal_number': internal_num,
                        'file_path': file_path
                    })

                # Track for duplicate detection
                if internal_num.lower() not in internal_numbers:
                    internal_numbers[internal_num.lower()] = []
                internal_numbers[internal_num.lower()].append((prog_num, file_path))

            # Find duplicates (same internal number in multiple files)
            for internal_num, files in internal_numbers.items():
                if len(files) > 1:
                    result['duplicates'][internal_num] = [
                        {'program_number': f[0], 'file_path': f[1]} for f in files
                    ]

            conn.close()
            return result

        except sqlite3.Error as e:
            logger.error(f"Database error finding duplicate internal O-numbers: {e}")
            return result
        except Exception as e:
            logger.error(f"Error finding duplicate internal O-numbers: {e}", exc_info=True)
            return result

    def find_stale_records(self):
        """
        Find database records where the file has been modified since last scan.

        Returns:
            list: List of dicts with program_number, db_modified, file_modified, file_path
        """
        from datetime import datetime, timedelta
        stale = []

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, last_modified, file_path
                FROM programs
                WHERE file_path IS NOT NULL AND is_managed = 1
            """)

            for prog_num, db_modified, file_path in cursor.fetchall():
                if not file_path or not os.path.exists(file_path):
                    continue

                try:
                    file_mtime = os.path.getmtime(file_path)
                    file_modified = datetime.fromtimestamp(file_mtime).isoformat()

                    # Compare timestamps
                    if db_modified:
                        db_time = datetime.fromisoformat(db_modified.replace('Z', '+00:00').split('+')[0])
                        file_time = datetime.fromtimestamp(file_mtime)

                        # File is newer than DB record by more than 1 second
                        if file_time > db_time + timedelta(seconds=1):
                            stale.append({
                                'program_number': prog_num,
                                'db_modified': db_modified,
                                'file_modified': file_modified,
                                'file_path': file_path
                            })
                except (ValueError, OSError):
                    continue

            conn.close()
            return stale

        except sqlite3.Error as e:
            logger.error(f"Database error finding stale records: {e}")
            return stale
        except Exception as e:
            logger.error(f"Error finding stale records: {e}", exc_info=True)
            return stale

    def find_zero_byte_files(self):
        """
        Find files in the repository that are empty (zero bytes).

        Returns:
            list: List of dicts with program_number, file_path, in_database
        """
        zero_byte = []

        try:
            import glob

            # Get all files in repository
            repo_files = glob.glob(os.path.join(self.repository_path, '*'))

            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            for file_path in repo_files:
                if not os.path.isfile(file_path):
                    continue

                try:
                    if os.path.getsize(file_path) == 0:
                        # Check if in database
                        filename = os.path.basename(file_path)
                        prog_num = os.path.splitext(filename)[0].lower()

                        cursor.execute("SELECT 1 FROM programs WHERE LOWER(program_number) = ?", (prog_num,))
                        in_db = cursor.fetchone() is not None

                        zero_byte.append({
                            'program_number': prog_num,
                            'file_path': file_path,
                            'in_database': in_db
                        })
                except OSError:
                    continue

            conn.close()
            return zero_byte

        except sqlite3.Error as e:
            logger.error(f"Database error finding zero-byte files: {e}")
            return zero_byte
        except Exception as e:
            logger.error(f"Error finding zero-byte files: {e}", exc_info=True)
            return zero_byte

    def run_extended_integrity_check(self, fix_issues=False):
        """
        Run all integrity checks including the new extended checks.

        Args:
            fix_issues: If True, automatically fix issues where possible

        Returns:
            dict: Comprehensive results from all checks
        """
        from datetime import datetime, timedelta

        result = {
            'basic': None,  # From verify_repository_integrity
            'missing_m30': [],
            'duplicate_internal_numbers': {'mismatched': [], 'duplicates': {}},
            'stale_records': [],
            'zero_byte_files': [],
            'fixed': {
                'stale_refreshed': 0,
                'zero_byte_removed': 0
            },
            'summary': {
                'total_issues': 0,
                'critical': 0,
                'warnings': 0
            }
        }

        try:
            # Run basic integrity check
            result['basic'] = self.verify_repository_integrity(fix_issues=fix_issues)

            # Check for missing M30
            result['missing_m30'] = self.find_missing_m30_programs()

            # Check for duplicate internal O-numbers
            result['duplicate_internal_numbers'] = self.find_duplicate_internal_onumbers()

            # Check for stale records
            result['stale_records'] = self.find_stale_records()

            # Check for zero-byte files
            result['zero_byte_files'] = self.find_zero_byte_files()

            # Fix issues if requested
            if fix_issues:
                # Refresh stale records
                for stale in result['stale_records']:
                    try:
                        # Re-parse and update the file
                        parse_result = self.parser.parse_file(stale['file_path'])
                        if parse_result:
                            conn = sqlite3.connect(self.db_path, timeout=30.0)
                            cursor = conn.cursor()
                            cursor.execute("""
                                UPDATE programs SET last_modified = ?
                                WHERE program_number = ?
                            """, (datetime.now().isoformat(), stale['program_number']))
                            conn.commit()
                            conn.close()
                            result['fixed']['stale_refreshed'] += 1
                    except:
                        pass

                # Remove zero-byte files from database (but don't delete files - user should decide)
                for zb in result['zero_byte_files']:
                    if zb['in_database']:
                        try:
                            conn = sqlite3.connect(self.db_path, timeout=30.0)
                            cursor = conn.cursor()
                            cursor.execute("DELETE FROM programs WHERE LOWER(program_number) = ?",
                                         (zb['program_number'].lower(),))
                            conn.commit()
                            conn.close()
                            result['fixed']['zero_byte_removed'] += 1
                        except:
                            pass

            # Calculate summary
            result['summary']['critical'] = (
                len(result['zero_byte_files']) +
                len(result['duplicate_internal_numbers']['duplicates'])
            )
            result['summary']['warnings'] = (
                len(result['missing_m30']) +
                len(result['stale_records']) +
                len(result['duplicate_internal_numbers']['mismatched'])
            )
            result['summary']['total_issues'] = (
                result['summary']['critical'] + result['summary']['warnings']
            )

            if result['basic']:
                result['summary']['total_issues'] += (
                    len(result['basic'].get('untracked_files', [])) +
                    len(result['basic'].get('orphaned_records', [])) +
                    len(result['basic'].get('registry_stale', []))
                )

            return result

        except sqlite3.Error as e:
            logger.error(f"Database error in extended integrity check: {e}")
            return result
        except Exception as e:
            logger.error(f"Error in extended integrity check: {e}", exc_info=True)
            return result

    def get_out_of_range_programs(self):
        """
        Get all programs that are in the wrong range for their round size.

        Returns:
            list: List of tuples (program_number, round_size, current_range, correct_range, title)
        """
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, round_size, round_size_source, title
                FROM programs
                WHERE in_correct_range = 0
                AND round_size IS NOT NULL
                ORDER BY round_size, program_number
            """)

            out_of_range = []
            for prog_num, round_size, source, title in cursor.fetchall():
                # Get current range
                try:
                    num = int(str(prog_num).replace('o', '').replace('O', ''))
                    current_range = None
                    ranges = self.get_round_size_ranges()
                    for rs, (start, end, name) in ranges.items():
                        if start <= num <= end:
                            current_range = f"o{start}-o{end} ({name})"
                            break
                    if not current_range:
                        current_range = "Unknown"
                except:
                    current_range = "Invalid"

                # Get correct range
                correct_range_info = self.get_range_for_round_size(round_size)
                if correct_range_info:
                    correct_range = f"o{correct_range_info[0]}-o{correct_range_info[1]}"
                else:
                    correct_range = "No range defined"

                out_of_range.append((prog_num, round_size, current_range, correct_range, title))

            conn.close()
            return out_of_range

        except Exception as e:
            messagebox.showerror("Registry Error", f"Failed to get out-of-range programs:\n{str(e)}")
            return []

    def rename_to_correct_range(self, program_number, dry_run=False):
        """
        Rename a program to the correct range for its round size.
        This is the core function for Type 1 duplicate resolution.

        Args:
            program_number: Program to rename (e.g., 'o62000')
            dry_run: If True, only simulate the rename without making changes

        Returns:
            dict: Result with keys:
                - success: bool
                - old_number: str
                - new_number: str
                - round_size: float
                - file_path: str
                - legacy_name_added: bool
                - error: str (if failed)
        """
        from datetime import datetime
        import json
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get program info
            cursor.execute("""
                SELECT round_size, file_path, title, legacy_names
                FROM programs
                WHERE program_number = ?
            """, (program_number,))

            result = cursor.fetchone()
            if not result:
                return {'success': False, 'error': f'Program {program_number} not found'}

            round_size, file_path, title, legacy_names = result

            if not round_size:
                return {'success': False, 'error': f'Program {program_number} has no detected round size'}

            # Check if already in correct range
            if self.is_in_correct_range(program_number, round_size):
                return {'success': False, 'error': f'Program {program_number} is already in correct range'}

            # Find next available number in correct range
            new_number = self.find_next_available_number(round_size)
            if not new_number:
                return {'success': False, 'error': f'No available numbers in range for round size {round_size}'}

            if dry_run:
                conn.close()
                return {
                    'success': True,
                    'dry_run': True,
                    'old_number': program_number,
                    'new_number': new_number,
                    'round_size': round_size,
                    'file_path': file_path,
                    'title': title
                }

            # Update legacy names
            if legacy_names:
                try:
                    legacy_list = json.loads(legacy_names)
                except:
                    legacy_list = []
            else:
                legacy_list = []

            legacy_list.append({
                'old_number': program_number,
                'renamed_date': datetime.now().isoformat(),
                'reason': 'Out of range - moved to correct range'
            })

            # Read file content
            if not os.path.exists(file_path):
                conn.close()
                return {'success': False, 'error': f'File not found: {file_path}'}

            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # Update program number in file content
            import re

            # Strip any suffix from old program number for matching internal content
            # Database might have o00002(1) or o00002_1, but file content has O00002
            old_num_plain = program_number.replace('o', '').replace('O', '')
            # Remove any suffix patterns: (1), (2), _1, _2, etc.
            old_num_base = re.sub(r'[(_]\d+[\)]?$', '', old_num_plain)

            new_num_plain = new_number.replace('o', '').replace('O', '')

            # Replace program number (common patterns)
            updated_content = content

            # Pattern 1: O12345 or o12345 at start of line
            # Use the BASE number without suffix to match file content
            updated_content = re.sub(
                rf'^[oO]{old_num_base}\b',
                new_number.upper(),
                updated_content,
                flags=re.MULTILINE
            )

            # Pattern 2: In program number comments
            # Use the BASE number without suffix to match file content
            updated_content = re.sub(
                rf'\b[oO]{old_num_base}\b',
                new_number.upper(),
                updated_content
            )

            # Add legacy comment at top of file (after first line if it's a program number)
            lines = updated_content.split('\n')
            legacy_comment = f"(RENAMED FROM {program_number.upper()} ON {datetime.now().strftime('%Y-%m-%d')} - OUT OF RANGE)"

            # Insert after the program number line
            if len(lines) > 0:
                lines.insert(1, legacy_comment)
            else:
                lines.insert(0, legacy_comment)

            updated_content = '\n'.join(lines)

            # Generate new file path with new program number
            old_dir = os.path.dirname(file_path)
            new_filename = f"{new_number}.nc"
            new_file_path = os.path.join(old_dir, new_filename)

            # Write updated content to new file
            with open(new_file_path, 'w', encoding='utf-8') as f:
                f.write(updated_content)

            # Delete old file if new file was created successfully
            if os.path.exists(new_file_path) and os.path.exists(file_path):
                os.remove(file_path)

            # Update database - programs table with new file path
            cursor.execute("""
                UPDATE programs
                SET program_number = ?,
                    file_path = ?,
                    legacy_names = ?,
                    last_renamed_date = ?,
                    rename_reason = 'Out of range correction',
                    in_correct_range = 1
                WHERE program_number = ?
            """, (new_number, new_file_path, json.dumps(legacy_list), datetime.now().isoformat(), program_number))

            # Update registry - mark old number as available
            cursor.execute("""
                UPDATE program_number_registry
                SET status = 'AVAILABLE',
                    file_path = NULL
                WHERE program_number = ?
            """, (program_number,))

            # Update registry - mark new number as in use with new file path
            cursor.execute("""
                UPDATE program_number_registry
                SET status = 'IN_USE',
                    file_path = ?
                WHERE program_number = ?
            """, (new_file_path, new_number))

            # Log resolution in duplicate_resolutions table
            cursor.execute("""
                INSERT INTO duplicate_resolutions
                (resolution_date, duplicate_type, program_numbers, action_taken,
                 files_affected, old_values, new_values, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                datetime.now().isoformat(),
                'TYPE_1_OUT_OF_RANGE',
                json.dumps([program_number, new_number]),
                'RENAME',
                json.dumps([{'old': file_path, 'new': new_file_path}]),
                json.dumps({'program_number': program_number, 'round_size': round_size, 'old_file': file_path}),
                json.dumps({'program_number': new_number, 'round_size': round_size, 'new_file': new_file_path}),
                f'Renamed from {program_number} to {new_number} - file renamed from {os.path.basename(file_path)} to {new_filename}'
            ))

            conn.commit()
            conn.close()

            return {
                'success': True,
                'old_number': program_number,
                'new_number': new_number,
                'round_size': round_size,
                'file_path': new_file_path,
                'old_file_path': file_path,
                'new_file_path': new_file_path,
                'title': title,
                'legacy_name_added': True
            }

        except Exception as e:
            return {'success': False, 'error': f'Rename failed: {str(e)}'}

    def batch_resolve_out_of_range(self, program_numbers=None, dry_run=False, progress_callback=None):
        """
        Batch rename programs that are out of range.

        Args:
            program_numbers: List of specific programs to rename, or None for all out-of-range
            dry_run: If True, simulate without making changes
            progress_callback: Function to call with progress updates

        Returns:
            dict: Statistics about the batch operation
        """
        try:
            # Get programs to process
            if program_numbers:
                programs_to_process = program_numbers
            else:
                out_of_range = self.get_out_of_range_programs()
                programs_to_process = [prog[0] for prog in out_of_range]  # Extract program numbers

            total = len(programs_to_process)
            stats = {
                'total': total,
                'successful': 0,
                'failed': 0,
                'skipped': 0,
                'errors': [],
                'renames': []
            }

            for i, prog_num in enumerate(programs_to_process):
                if progress_callback:
                    progress_callback(i + 1, total, prog_num)

                result = self.rename_to_correct_range(prog_num, dry_run=dry_run)

                if result['success']:
                    stats['successful'] += 1
                    stats['renames'].append({
                        'old': result['old_number'],
                        'new': result['new_number'],
                        'round_size': result['round_size'],
                        'file': result.get('file_path', '')
                    })
                elif 'already in correct range' in result.get('error', ''):
                    stats['skipped'] += 1
                else:
                    stats['failed'] += 1
                    stats['errors'].append({
                        'program': prog_num,
                        'error': result.get('error', 'Unknown error')
                    })

            return stats

        except Exception as e:
            return {
                'total': 0,
                'successful': 0,
                'failed': 0,
                'skipped': 0,
                'errors': [{'program': 'BATCH', 'error': str(e)}],
                'renames': []
            }

    def preview_rename_plan(self, limit=None):
        """
        Preview what would happen if we renamed all out-of-range programs.
        This is a dry-run of the batch resolution.

        Args:
            limit: Maximum number of programs to preview (None = all)

        Returns:
            list: Preview data with old number, new number, round size, title
        """
        try:
            out_of_range = self.get_out_of_range_programs()

            if limit:
                out_of_range = out_of_range[:limit]

            preview = []
            # Track which numbers we've already assigned in this batch
            # to prevent conflicts where multiple programs get assigned the same number
            assigned_in_batch = set()

            for prog_num, round_size, current_range, correct_range, title in out_of_range:
                # Find what the new number would be
                new_number = self.find_next_available_number(round_size)

                # If this number was already assigned in this batch, find the next one
                while new_number and new_number in assigned_in_batch:
                    # Get the numeric part of the new_number
                    try:
                        current_num = int(new_number.replace('o', '').replace('O', ''))
                        range_info = self.get_range_for_round_size(round_size)
                        if not range_info:
                            new_number = None
                            break

                        range_start, range_end = range_info

                        # Try the next sequential number
                        next_num = current_num + 1
                        if next_num > range_end:
                            # Range is full
                            new_number = None
                            break

                        # Check if this next number is available in the registry
                        conn = sqlite3.connect(self.db_path)
                        cursor = conn.cursor()
                        cursor.execute("""
                            SELECT status FROM program_number_registry
                            WHERE program_number = ?
                        """, (self.format_program_number(next_num),))
                        result = cursor.fetchone()
                        conn.close()

                        if result and result[0] == 'AVAILABLE':
                            new_number = self.format_program_number(next_num)
                        else:
                            # This number is also taken, keep searching
                            current_num = next_num
                            new_number = self.format_program_number(current_num)
                    except Exception:
                        new_number = None
                        break

                if new_number:
                    # Mark this number as assigned in this batch
                    assigned_in_batch.add(new_number)

                    preview.append({
                        'old_number': prog_num,
                        'new_number': new_number,
                        'round_size': round_size,
                        'current_range': current_range,
                        'correct_range': correct_range,
                        'title': title,
                        'status': 'Ready'
                    })
                else:
                    preview.append({
                        'old_number': prog_num,
                        'new_number': 'NO SPACE',
                        'round_size': round_size,
                        'current_range': current_range,
                        'correct_range': correct_range,
                        'title': title,
                        'status': 'Error: No available numbers'
                    })

            return preview

        except Exception as e:
            messagebox.showerror("Preview Error", f"Failed to generate preview:\n{str(e)}")
            return []

    def load_config(self):
        """Load configuration from file"""
        default_config = {
            "last_folder": "",
            "material_list": ["6061-T6", "Steel", "Stainless", "Other"],
            "spacer_types": ["standard", "hub_centric", "steel_ring", "2pc_part1", "2pc_part2"],
            "theme": "dark",

            # Phase 1: File Scanner settings
            "scan_on_import": True,
            "scan_strict_mode": False,
            "scan_show_dialog": True,
            "scan_auto_fix": False,

            # Phase 1: Database Monitor settings
            "db_monitor_enabled": False,
            "db_monitor_auto_refresh": True,
            "db_monitor_notify": True,

            # Phase 1: Safety Checker settings
            "safety_checks_enabled": True,
            "safety_auto_backup": True,
            "safety_strict_mode": False,
            "safety_conflict_threshold": 300,

            # Phase 1: Auto-Fixer settings
            "auto_fix_tool_home": True,
            "auto_fix_coolant": True,
            "auto_fix_create_backup": True
        }

        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    self.config = json.load(f)
                # Ensure theme key exists
                if "theme" not in self.config:
                    self.config["theme"] = "dark"
            except:
                self.config = default_config
        else:
            self.config = default_config

        # Apply saved theme
        self.current_theme = self.config.get("theme", "dark")
        self._apply_theme_colors()

    def save_config(self):
        """Save configuration to file"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)

    def _apply_theme_colors(self):
        """Apply current theme colors to instance variables"""
        theme = THEMES.get(self.current_theme, THEMES['dark'])
        self.bg_color = theme['bg_color']
        self.fg_color = theme['fg_color']
        self.input_bg = theme['input_bg']
        self.button_bg = theme['button_bg']
        self.accent_color = theme['accent_color']
        self.success_color = theme['success_color']
        self.warning_color = theme['warning_color']
        self.error_color = theme['error_color']
        self.tree_bg = theme['tree_bg']
        self.tree_fg = theme['tree_fg']
        self.tree_selected = theme['tree_selected']
        self.header_bg = theme['header_bg']

    def toggle_theme(self):
        """Toggle between dark and light themes"""
        # Switch theme
        self.current_theme = 'light' if self.current_theme == 'dark' else 'dark'
        self._apply_theme_colors()

        # Save preference
        self.config['theme'] = self.current_theme
        self.save_config()

        # Update toggle button text
        if hasattr(self, 'theme_toggle_btn'):
            icon = "🌙" if self.current_theme == 'light' else "☀️"
            self.theme_toggle_btn.config(text=icon)

        # Apply theme to all widgets
        self._apply_theme_to_widgets(self.root)

        # Update ttk styles
        self._update_ttk_styles()

        # Refresh the treeview
        if hasattr(self, 'tree'):
            self.tree.tag_configure('oddrow', background=self.input_bg)
            self.tree.tag_configure('evenrow', background=self.bg_color)

        logger.info(f"Theme switched to: {self.current_theme}")

    def _apply_theme_to_widgets(self, widget):
        """Recursively apply theme to all widgets"""
        try:
            widget_type = widget.winfo_class()

            # Configure based on widget type
            if widget_type == 'Frame' or widget_type == 'Labelframe':
                widget.configure(bg=self.bg_color)
            elif widget_type == 'Label':
                widget.configure(bg=self.bg_color, fg=self.fg_color)
            elif widget_type == 'Button':
                # Preserve special button colors (success, error, etc.)
                current_bg = str(widget.cget('bg')).lower()
                if current_bg not in ['#4caf50', '#d32f2f', '#ff9800', '#2e7d32', '#1976d2',
                                      '#9c27b0', '#e91e63', '#673ab7', '#3f51b5', '#ff5722',
                                      '#34a853', '#ff6f00']:
                    widget.configure(bg=self.button_bg, fg=self.fg_color)
            elif widget_type == 'Entry':
                widget.configure(bg=self.input_bg, fg=self.fg_color, insertbackground=self.fg_color)
            elif widget_type == 'Text':
                widget.configure(bg=self.input_bg, fg=self.fg_color, insertbackground=self.fg_color)
            elif widget_type == 'Listbox':
                widget.configure(bg=self.input_bg, fg=self.fg_color)
            elif widget_type == 'Canvas':
                widget.configure(bg=self.bg_color)
            elif widget_type == 'Checkbutton':
                widget.configure(bg=self.bg_color, fg=self.fg_color,
                               selectcolor=self.input_bg, activebackground=self.bg_color)
            elif widget_type == 'Radiobutton':
                widget.configure(bg=self.bg_color, fg=self.fg_color,
                               selectcolor=self.input_bg, activebackground=self.bg_color)
            elif widget_type == 'Toplevel':
                widget.configure(bg=self.bg_color)
        except tk.TclError:
            pass  # Some widgets don't support all options

        # Recursively apply to children
        for child in widget.winfo_children():
            self._apply_theme_to_widgets(child)

    def _update_ttk_styles(self):
        """Update ttk widget styles for current theme"""
        style = ttk.Style()

        # Treeview styling
        style.configure('Treeview',
                       background=self.tree_bg,
                       foreground=self.tree_fg,
                       fieldbackground=self.tree_bg,
                       rowheight=25)
        style.configure('Treeview.Heading',
                       background=self.header_bg,
                       foreground=self.fg_color,
                       font=('Arial', 9, 'bold'))
        style.map('Treeview',
                 background=[('selected', self.tree_selected)],
                 foreground=[('selected', '#ffffff')])

        # Notebook styling
        style.configure('TNotebook', background=self.bg_color)
        style.configure('TNotebook.Tab', background=self.button_bg, foreground=self.fg_color)
        style.map('TNotebook.Tab',
                 background=[('selected', self.accent_color)],
                 foreground=[('selected', '#ffffff')])

        # Combobox styling
        style.configure('TCombobox',
                       fieldbackground=self.input_bg,
                       background=self.button_bg,
                       foreground=self.fg_color)

        # Scrollbar styling
        style.configure('TScrollbar', background=self.button_bg, troughcolor=self.bg_color)

    def _update_error_filter_counts(self):
        """Refresh the Error Contains combobox to show (N) hit counts from the DB."""
        if not hasattr(self, '_error_filter_keywords') or not hasattr(self, 'filter_error_text'):
            return
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            new_values = []
            for kw in self._error_filter_keywords:
                if not kw:
                    new_values.append("")
                    continue
                search = f"%{kw}%"
                cursor.execute(
                    "SELECT COUNT(*) FROM programs WHERE ("
                    "validation_issues LIKE ? OR validation_warnings LIKE ? "
                    "OR bore_warnings LIKE ? OR dimensional_issues LIKE ? "
                    "OR tool_home_issues LIKE ? OR crash_issues LIKE ? "
                    "OR crash_warnings LIKE ?)",
                    [search] * 7
                )
                count = cursor.fetchone()[0]
                new_values.append(f"{kw} ({count})" if count > 0 else kw)

            conn.close()

            # Preserve current selection (strip suffix before comparing)
            current_raw = re.sub(r'\s*\(\d+\)$', '', self.filter_error_text.get())
            self.filter_error_text['values'] = new_values
            for v in new_values:
                if re.sub(r'\s*\(\d+\)$', '', v) == current_raw:
                    self.filter_error_text.set(v)
                    break
        except Exception:
            pass  # Never crash the UI for cosmetic counts

    def backup_database(self) -> bool:
        """Create a backup of the database in a special backup folder

        Returns:
            bool: True if backup was successful, False otherwise
        """
        from datetime import datetime
        try:
            # Create backup folder if it doesn't exist
            backup_folder = "Database_Backups"
            if not os.path.exists(backup_folder):
                os.makedirs(backup_folder)

            # Generate backup filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"gcode_database_backup_{timestamp}.db"
            backup_path = os.path.join(backup_folder, backup_filename)

            # Copy database file
            shutil.copy2(self.db_path, backup_path)

            # Keep only last 10 backups to prevent folder bloat
            self.cleanup_old_backups(backup_folder, keep_count=10)

            return True
        except Exception as e:
            messagebox.showerror("Backup Error", f"Failed to create database backup:\n{str(e)}")
            return False

    def cleanup_old_backups(self, backup_folder: str, keep_count: int = 10):
        """Keep only the most recent N backups

        Args:
            backup_folder: Path to backup folder
            keep_count: Number of recent backups to keep
        """
        try:
            # Get all backup files
            backup_files = [f for f in os.listdir(backup_folder)
                           if f.startswith("gcode_database_backup_") and f.endswith(".db")]

            # Sort by modification time (newest first)
            backup_files.sort(key=lambda x: os.path.getmtime(os.path.join(backup_folder, x)), reverse=True)

            # Delete older backups
            for old_backup in backup_files[keep_count:]:
                old_path = os.path.join(backup_folder, old_backup)
                os.remove(old_path)
        except Exception as e:
            # Don't show error for cleanup failures, just log it
            print(f"Backup cleanup warning: {str(e)}")

    def get_available_values(self, column: str) -> List[str]:
        """Get distinct values from database column for filter dropdowns"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute(f"SELECT DISTINCT {column} FROM programs WHERE {column} IS NOT NULL ORDER BY {column}")
            values = [row[0] for row in cursor.fetchall()]
            conn.close()
            return values
        except:
            return []
            
    def setup_gui(self):
        """Setup the main GUI"""
        # Create main container
        main_container = tk.Frame(self.root, bg=self.bg_color)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Top section - Title and Ribbon Tabs
        top_frame = tk.Frame(main_container, bg=self.bg_color)
        top_frame.pack(fill=tk.X, pady=(0, 10))

        self.create_top_section(top_frame)

        # User status bar (right side of top frame)
        user_frame = tk.Frame(top_frame, bg=self.bg_color)
        user_frame.pack(side=tk.RIGHT, padx=10)

        # Role color coding
        role_colors = {'admin': '#4CAF50', 'editor': '#2196F3', 'operator': '#FF9800', 'viewer': '#9E9E9E'}
        role_color = role_colors.get(self.current_user_role, '#9E9E9E')

        tk.Label(user_frame, text=f"Logged in as: {self.current_username}",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 9)).pack(side=tk.LEFT, padx=5)

        tk.Label(user_frame, text=f"[{self.current_user_role.upper()}]",
                bg=self.bg_color, fg=role_color, font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=2)

        # Theme toggle button - sun for dark mode (click to go light), moon for light mode (click to go dark)
        theme_icon = "☀️" if self.current_theme == 'dark' else "🌙"
        self.theme_toggle_btn = tk.Button(user_frame, text=theme_icon, command=self.toggle_theme,
                                          bg=self.button_bg, fg=self.fg_color, font=("Arial", 12),
                                          width=3, relief=tk.FLAT, cursor="hand2")
        self.theme_toggle_btn.pack(side=tk.LEFT, padx=5)

        tk.Button(user_frame, text="Logout", command=self.logout_user,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 8),
                 width=8).pack(side=tk.LEFT, padx=10)

        # Ribbon tabs section
        ribbon_frame = tk.Frame(main_container, bg=self.bg_color, relief=tk.RAISED, borderwidth=1)
        ribbon_frame.pack(fill=tk.X, pady=(0, 10))

        self.create_ribbon_tabs(ribbon_frame)

        # Create dropdown selector for view mode instead of tabs
        view_selector_frame = tk.Frame(main_container, bg=self.bg_color)
        view_selector_frame.pack(fill=tk.X, pady=(0, 5))

        tk.Label(view_selector_frame, text="View:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=5)

        self.view_mode_var = tk.StringVar(value="all")
        view_dropdown = ttk.Combobox(view_selector_frame, textvariable=self.view_mode_var,
                                     values=["all", "repository", "revised", "external"],
                                     state="readonly", width=20, font=("Arial", 10))
        view_dropdown.pack(side=tk.LEFT, padx=5)
        view_dropdown.bind('<<ComboboxSelected>>', self.on_view_mode_change)

        # Create action button frames (hidden/shown based on view mode)
        action_buttons_frame = tk.Frame(main_container, bg=self.bg_color)
        action_buttons_frame.pack(fill=tk.X, pady=(0, 5))

        # Create separate frames for each view mode
        self.all_programs_tab = tk.Frame(action_buttons_frame, bg=self.bg_color)
        self.repository_tab = tk.Frame(action_buttons_frame, bg=self.bg_color)
        self.revised_tab = tk.Frame(action_buttons_frame, bg=self.bg_color)
        self.external_tab = tk.Frame(action_buttons_frame, bg=self.bg_color)

        # Store reference to action buttons frame
        self.action_buttons_container = action_buttons_frame

        # Setup tab-specific action buttons
        self.setup_all_programs_tab()
        self.setup_repository_tab()
        self.setup_revised_tab()
        self.setup_external_tab()

        # Show "all" tab by default
        self.all_programs_tab.pack(fill=tk.X)

        # Create shared filter and results section (below tabs)
        # Middle section - Filters with toggle capability
        self.filter_outer_frame = tk.Frame(main_container, bg=self.bg_color)
        self.filter_outer_frame.pack(fill=tk.X, pady=(0, 10))

        # Toggle bar - always visible
        toggle_bar = tk.Frame(self.filter_outer_frame, bg=self.bg_color)
        toggle_bar.pack(fill=tk.X)

        # Toggle button
        self.filter_expanded = True
        self.toggle_filter_btn = tk.Button(toggle_bar, text="▼ Search & Filter",
                                          command=self.toggle_filter_section,
                                          bg=self.accent_color, fg=self.fg_color,
                                          font=("Arial", 10, "bold"), width=20, anchor="w")
        self.toggle_filter_btn.pack(side=tk.LEFT, padx=5, pady=2)

        tk.Label(toggle_bar, text="(Click to minimize/expand)",
                bg=self.bg_color, fg="#888888", font=("Arial", 8, "italic")).pack(side=tk.LEFT, padx=5)

        # Collapsible filter frame
        filter_frame = tk.Frame(self.filter_outer_frame, bg=self.bg_color)
        filter_frame.pack(fill=tk.X, pady=(5, 0))
        self.filter_collapsible_frame = filter_frame

        self.create_filter_section(filter_frame)

        # Results header with counter
        results_header = tk.Frame(main_container, bg=self.bg_color)
        results_header.pack(fill=tk.X, pady=(5, 0))

        tk.Label(results_header, text="Results", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=10)

        # Results counter label - visible and prominent
        self.results_counter_label = tk.Label(results_header, text="", bg=self.bg_color,
                                              fg="#4CAF50", font=("Arial", 10, "bold"))
        self.results_counter_label.pack(side=tk.LEFT, padx=10)

        # Bottom section - Results
        results_frame = tk.Frame(main_container, bg=self.bg_color, relief=tk.SUNKEN, borderwidth=1)
        results_frame.pack(fill=tk.BOTH, expand=True)

        self.create_results_section(results_frame)

    def setup_all_programs_tab(self):
        """Setup the All Programs tab - shows all files (repository + external)"""
        # Info and action buttons
        info_frame = tk.Frame(self.all_programs_tab, bg=self.bg_color)
        info_frame.pack(fill=tk.X, pady=5, padx=10)

        # Info label
        tk.Label(info_frame, text="Viewing all programs (repository + external files)",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 10, "italic")).pack(side=tk.LEFT)

        # Stats button
        tk.Button(info_frame, text="📊 Stats", command=self.show_all_programs_stats,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

    def setup_repository_tab(self):
        """Setup the Repository tab (managed files only)"""
        # Info and action buttons
        info_frame = tk.Frame(self.repository_tab, bg=self.bg_color)
        info_frame.pack(fill=tk.X, pady=5, padx=10)

        # Info label
        tk.Label(info_frame, text="Repository: Managed files in repository/ folder",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 10, "italic")).pack(side=tk.LEFT)

        # Repository stats button
        tk.Button(info_frame, text="📊 Stats", command=self.show_repository_stats,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

        # Refresh button
        tk.Button(info_frame, text="🔄 Refresh", command=self.refresh_repository_scan,
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

        # Repository management buttons - Row 1 (Basic operations)
        repo_buttons1 = tk.Frame(self.repository_tab, bg=self.bg_color)
        repo_buttons1.pack(fill=tk.X, pady=5, padx=10)

        # Delete button - only for admins
        if self.has_permission('delete_files'):
            tk.Button(repo_buttons1, text="🗑️ Delete", command=self.delete_from_repository,
                     bg="#D32F2F", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=12).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Export - available to all
        tk.Button(repo_buttons1, text="📤 Export", command=self.export_selected_file,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=12).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Manage Duplicates - editors and above
        if self.has_permission('manage_duplicates'):
            tk.Button(repo_buttons1, text="🔍 Manage Duplicates",
                     command=self.manage_duplicates,
                     bg="#FF6B00", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=18).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Sync Filenames - editors and above
        if self.has_permission('edit_files'):
            tk.Button(repo_buttons1, text="🔄 Sync Filenames",
                     command=self.sync_filenames_with_database,
                     bg="#00BCD4", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=16).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Repository management buttons - Row 2 (Program Number Management) - editors and above
        if self.has_permission('batch_operations'):
            repo_buttons2 = tk.Frame(self.repository_tab, bg=self.bg_color)
            repo_buttons2.pack(fill=tk.X, pady=2, padx=10)

            tk.Button(repo_buttons2, text="📋 Registry",
                     command=self.show_registry_window,
                     bg="#6B5B93", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=12).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

            tk.Button(repo_buttons2, text="⚠️ Out-of-Range",
                     command=self.show_out_of_range_window,
                     bg="#C41E3A", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

            tk.Button(repo_buttons2, text="🔧 Batch Rename",
                     command=self.show_batch_rename_window,
                     bg="#9B59B6", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

            tk.Button(repo_buttons2, text="🎯 Move to Range",
                     command=self.move_to_correct_range,
                     bg="#E91E63", fg=self.fg_color, font=("Arial", 8, "bold"),
                     width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Repository management buttons - Row 3 (Utilities)
        repo_buttons3 = tk.Frame(self.repository_tab, bg=self.bg_color)
        repo_buttons3.pack(fill=tk.X, pady=2, padx=10)

        tk.Button(repo_buttons3, text="📦 Export by Round Size",
                 command=self.export_repository_by_round_size,
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=20).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(repo_buttons3, text="🔧 Repair Paths",
                 command=self.repair_file_paths,
                 bg="#FF9800", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(repo_buttons3, text="🔄 Rebase Paths",
                 command=self.quick_rebase_paths,
                 bg="#2196F3", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(repo_buttons3, text="🔢 Fix Prog# Format",
                 command=self.fix_program_number_formatting,
                 bg="#9C27B0", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=16).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(repo_buttons3, text="📋 Verification Standards",
                 command=self.show_standards_reference,
                 bg="#00BCD4", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=20).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

    def setup_revised_tab(self):
        """Setup the Revised Repository tab (hand-refined programs)"""
        # Info and action buttons
        info_frame = tk.Frame(self.revised_tab, bg=self.bg_color)
        info_frame.pack(fill=tk.X, pady=5, padx=10)

        # Info label
        tk.Label(info_frame, text="Revised Repository: Hand-refined programs in revised_repository/ folder",
                bg=self.bg_color, fg="#FFD700", font=("Arial", 10, "italic")).pack(side=tk.LEFT)

        # Stats button
        tk.Button(info_frame, text="📊 Stats", command=self.show_revised_stats,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

        # Refresh button
        tk.Button(info_frame, text="🔄 Refresh", command=self.refresh_revised_scan,
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

        # Revised repository management buttons - Row 1
        revised_buttons1 = tk.Frame(self.revised_tab, bg=self.bg_color)
        revised_buttons1.pack(fill=tk.X, pady=5, padx=10)

        tk.Button(revised_buttons1, text="📥 Import from Main",
                 command=self.import_to_revised_repository,
                 bg="#FF9800", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=16).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(revised_buttons1, text="📤 Move to Main",
                 command=self.move_to_main_repository,
                 bg="#2196F3", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(revised_buttons1, text="🗑️ Delete",
                 command=self.delete_from_revised_repository,
                 bg="#D32F2F", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=12).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(revised_buttons1, text="📤 Export",
                 command=self.export_from_revised,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=12).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        # Row 2 - Comparison tools
        revised_buttons2 = tk.Frame(self.revised_tab, bg=self.bg_color)
        revised_buttons2.pack(fill=tk.X, pady=2, padx=10)

        tk.Button(revised_buttons2, text="⚖️ Compare with Main",
                 command=self.compare_revised_with_main,
                 bg="#9C27B0", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=18).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(revised_buttons2, text="📁 Open Folder",
                 command=lambda: os.startfile(self.revised_repository_path) if os.path.exists(self.revised_repository_path) else None,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=14).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

        tk.Button(revised_buttons2, text="🔍 Find Differences",
                 command=self.find_revised_differences,
                 bg="#673AB7", fg=self.fg_color, font=("Arial", 8, "bold"),
                 width=16).pack(side=tk.LEFT, padx=2, expand=True, fill=tk.X)

    def setup_external_tab(self):
        """Setup the External/Scanned tab (external files only)"""
        # Info and action buttons
        info_frame = tk.Frame(self.external_tab, bg=self.bg_color)
        info_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(info_frame, text="External: Scanned files NOT in repository (temporary view)",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 10, "italic")).pack(side=tk.LEFT)

        # Stats button
        tk.Button(info_frame, text="📊 Stats", command=self.show_external_stats,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=10, height=1).pack(side=tk.RIGHT, padx=5)

        # External file management buttons
        external_buttons = tk.Frame(self.external_tab, bg=self.bg_color)
        external_buttons.pack(fill=tk.X, pady=5, padx=10)

        tk.Button(external_buttons, text="➕ Add to Repository", command=self.add_selected_to_repository,
                 bg="#388E3C", fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=18, height=1).pack(side=tk.LEFT, padx=3, expand=True, fill=tk.X)

        tk.Button(external_buttons, text="🗑️ Remove from DB", command=self.remove_from_database,
                 bg="#D32F2F", fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=15, height=1).pack(side=tk.LEFT, padx=3, expand=True, fill=tk.X)

        tk.Button(external_buttons, text="🔄 Refresh", command=lambda: self.refresh_results(view_mode='external'),
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                 width=12, height=1).pack(side=tk.LEFT, padx=3, expand=True, fill=tk.X)

    def on_view_mode_change(self, event=None):
        """Handle view mode dropdown change"""
        view_mode = self.view_mode_var.get()

        # Hide all tab frames
        self.all_programs_tab.pack_forget()
        self.repository_tab.pack_forget()
        self.revised_tab.pack_forget()
        self.external_tab.pack_forget()

        # Show the selected tab frame
        if view_mode == 'all':
            self.all_programs_tab.pack(fill=tk.X)
            self.refresh_results(view_mode='all')
        elif view_mode == 'repository':
            self.repository_tab.pack(fill=tk.X)
            self.refresh_results(view_mode='repository')
        elif view_mode == 'revised':
            self.revised_tab.pack(fill=tk.X)
            self.refresh_results(view_mode='revised')
        elif view_mode == 'external':
            self.external_tab.pack(fill=tk.X)
            self.refresh_results(view_mode='external')

    def toggle_filter_section(self):
        """Toggle the visibility of the filter section"""
        if self.filter_expanded:
            # Collapse the filter section
            self.filter_collapsible_frame.pack_forget()
            self.toggle_filter_btn.config(text="▶ Search & Filter (Click to expand)")
            self.filter_expanded = False
        else:
            # Expand the filter section
            self.filter_collapsible_frame.pack(fill=tk.X, pady=(5, 0))
            self.toggle_filter_btn.config(text="▼ Search & Filter")
            self.filter_expanded = True

    def create_top_section(self, parent):
        """Create top action buttons"""
        # Title
        title = tk.Label(parent, text="G-Code Database Manager",
                        font=("Arial", 16, "bold"),
                        bg=self.bg_color, fg=self.fg_color)
        title.pack(side=tk.LEFT, padx=10)

    def create_ribbon_tabs(self, parent):
        """Collapsible flat-button ribbon.

        Clicking a tab shows its panel; clicking the already-active tab
        collapses/hides the panel. Clicking it again re-expands it.
        """
        # ── Tab button bar (always visible) ──────────────────────────────
        tab_bar = tk.Frame(parent, bg=self.bg_color)
        tab_bar.pack(fill=tk.X, padx=5, pady=(4, 0))

        # ── Collapsible content area ──────────────────────────────────────
        self._ribbon_content_frame = tk.Frame(parent, bg=self.bg_color)
        self._ribbon_content_frame.pack(fill=tk.X, padx=5, pady=(0, 4))

        self._ribbon_expanded   = True
        self._ribbon_active_key = None
        self._ribbon_buttons    = {}   # key → Button
        self._ribbon_panels     = {}   # key → Frame

        # ── Helper: register one tab ──────────────────────────────────────
        def _tab(key, label, builder):
            panel = tk.Frame(self._ribbon_content_frame, bg=self.bg_color)
            builder(panel)
            self._ribbon_panels[key] = panel

            btn = tk.Button(
                tab_bar, text=label,
                command=lambda k=key: self._ribbon_tab_click(k),
                bg=self.button_bg, fg=self.fg_color,
                font=("Arial", 9, "bold"),
                relief=tk.FLAT, padx=14, pady=5, cursor="hand2"
            )
            btn.pack(side=tk.LEFT, padx=2, pady=2)
            self._ribbon_buttons[key] = btn

        # ── Panel content builders ────────────────────────────────────────
        def build_files(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            if self.has_permission('add_files'):
                tk.Button(g, text="⚡ Process New", command=self.process_new_files_workflow,
                         bg="#4CAF50", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
                tk.Button(g, text="🔍 Scan File", command=self.scan_file_before_import,
                         bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
                tk.Button(g, text="🔍 Scan Folder\nfor Issues", command=self.scan_folder_for_issues,
                         bg="#6A1B9A", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📁 Scan Folder", command=self.scan_folder,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('batch_operations'):
                tk.Button(g, text="🔄 Rescan Database", command=self.rescan_database,
                         bg="#FF6F00", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
                tk.Button(g, text="⚡ Rescan Changed", command=self.rescan_changed_files,
                         bg="#2E7D32", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('move_files'):
                tk.Button(g, text="📁 Organize by OD", command=self.organize_files_by_od,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('export_data'):
                tk.Button(g, text="📋 Copy Filtered", command=self.copy_filtered_view,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
                tk.Button(g, text="📊 Export Filtered", command=self.export_filtered_to_excel,
                         bg="#1976D2", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('add_files'):
                tk.Button(g, text="➕ Add Entry", command=self.add_entry,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)

        def build_duplicates(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            tk.Button(g, text="🔍 Find Repeats", command=self.find_and_mark_repeats,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📝 Rename Duplicates", command=self.rename_duplicate_files,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('delete_files'):
                tk.Button(g, text="🗑️ Delete Duplicates", command=self.delete_duplicates,
                         bg="#D32F2F", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📐 View Variations", command=self.show_dimensional_variations,
                     bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)

        def build_reports(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            tk.Button(g, text="📊 Export Excel", command=self.export_csv,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📈 Google Sheets", command=self.export_google_sheets,
                     bg="#34A853", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📋 Unused #s", command=self.export_unused_numbers,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔧 Tool Analysis", command=self.view_tool_statistics,
                     bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔩 Tool Positions", command=self.scan_tool_change_positions,
                     bg="#FF5722", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="❓ Legend/Help", command=self.show_legend,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)

        def build_backup(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            tk.Button(g, text="📦 Full Backup", command=self.create_full_backup,
                     bg="#2E7D32", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📂 Restore Backup", command=self.restore_from_backup,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📋 View Backups", command=self.view_backups,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📋 Manage Profiles", command=self.manage_database_profiles,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)

        def build_workflow(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            tk.Button(g, text="🧙 Workflow Wizard", command=self.show_workflow_wizard,
                     bg="#E91E63", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔄 Sync Registry", command=self.sync_registry_ui,
                     bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🎯 Detect Round Sizes", command=self.detect_round_sizes_ui,
                     bg="#673AB7", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📊 Round Size Stats", command=self.show_round_size_stats,
                     bg="#3F51B5", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔧 Fix Tool Homes", command=self.correct_tool_home_positions,
                     bg="#FF5722", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔄 Refresh All Files", command=self.refresh_all_files,
                     bg="#2196F3", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)

        def build_maintenance(f):
            g = tk.Frame(f, bg=self.bg_color)
            g.pack(fill=tk.X, padx=5, pady=5)
            tk.Button(g, text="🗑️ Clear Database", command=self.clear_database,
                     bg="#D32F2F", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="❌ Delete Filtered", command=self.delete_filtered_view,
                     bg="#D32F2F", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔍 Integrity Check", command=self.show_extended_integrity_check,
                     bg="#FF9800", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔢 Resolve Suffixes", command=self.show_resolve_suffixes,
                     bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            if self.has_permission('manage_users'):
                tk.Button(g, text="👥 User Management", command=self.show_user_management,
                         bg="#1976D2", fg=self.fg_color, font=("Arial", 9, "bold"),
                         width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔐 Change Password", command=self.show_change_password,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🗜️ Archive Cleanup", command=lambda: ArchiveCleanupWindow(self),
                     bg="#607D8B", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔄 Sync Warnings", command=self.sync_validation_status_with_warnings,
                     bg="#FF9800", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🔍 Find Duplicates", command=self.show_duplicate_browser,
                     bg="#9C27B0", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="💾 Fix Drive Letter", command=self.detect_and_fix_drive_letter,
                     bg="#2196F3", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="📦 Archive Migration", command=self.show_archive_migration_dialog,
                     bg="#00838F", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🧹 Clean Stale", command=self.clean_stale_records,
                     bg="#558B2F", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="💾 USB Sync", command=self.open_usb_sync_window,
                     bg="#673AB7", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)
            tk.Button(g, text="🗑 Deleted/Archived", command=self.open_archived_files_browser,
                     bg="#E91E63", fg=self.fg_color, font=("Arial", 9, "bold"),
                     width=14, height=2).pack(side=tk.LEFT, padx=3)

        # ── Register tabs (permission-gated) ─────────────────────────────
        _tab('files',       '📂 Files',        build_files)
        if self.has_permission('manage_duplicates'):
            _tab('duplicates',  '🔍 Duplicates',   build_duplicates)
        if self.has_permission('export_data'):
            _tab('reports',     '📊 Reports',       build_reports)
        if self.has_permission('backup_restore'):
            _tab('backup',      '💾 Backup',        build_backup)
        if self.has_permission('batch_operations'):
            _tab('workflow',    '🔄 Workflow',      build_workflow)
        if self.has_permission('clear_database'):
            _tab('maintenance', '⚙️ Maintenance',   build_maintenance)

        # ── Open Files tab by default ─────────────────────────────────────
        first = next(iter(self._ribbon_panels), None)
        if first:
            self._ribbon_tab_click(first)

    def _ribbon_tab_click(self, key):
        """Toggle ribbon: collapse if active tab clicked, else switch panels."""
        if self._ribbon_active_key == key and self._ribbon_expanded:
            # Collapse — same tab clicked while open
            self._ribbon_content_frame.pack_forget()
            self._ribbon_expanded = False
            self._ribbon_buttons[key].config(relief=tk.FLAT, bg=self.button_bg)
        else:
            # Expand or switch tab
            if not self._ribbon_expanded:
                self._ribbon_content_frame.pack(fill=tk.X, padx=5, pady=(0, 4))
                self._ribbon_expanded = True
            # Reset all panels and buttons
            for k, panel in self._ribbon_panels.items():
                panel.pack_forget()
            for k, btn in self._ribbon_buttons.items():
                btn.config(relief=tk.FLAT, bg=self.button_bg)
            # Activate selected
            self._ribbon_panels[key].pack(fill=tk.X)
            self._ribbon_buttons[key].config(relief=tk.SUNKEN, bg=self.accent_color)
            self._ribbon_active_key = key

    def create_filter_section(self, parent):
        """Create filter controls"""
        filter_container = tk.Frame(parent, bg=self.bg_color)
        filter_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Row 1 - Title search + Program # + dropdowns all on one line
        row1 = tk.Frame(filter_container, bg=self.bg_color)
        row1.pack(fill=tk.X, pady=5)

        # Title search
        tk.Label(row1, text="🔍 Title:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(5, 2))
        self.filter_title = tk.Entry(row1, bg=self.input_bg, fg=self.fg_color,
                                     font=("Arial", 10), width=25)
        self.filter_title.pack(side=tk.LEFT, padx=2)
        self.filter_title.bind('<Return>', lambda _: self.refresh_results())

        btn_clear_title = tk.Button(row1, text="✕", command=self.clear_title_search,
                                   bg=self.button_bg, fg=self.fg_color,
                                   font=("Arial", 9, "bold"), width=2)
        btn_clear_title.pack(side=tk.LEFT, padx=(1, 4))

        self.fuzzy_search_enabled = tk.BooleanVar(value=False)
        fuzzy_cb = tk.Checkbutton(row1, text="Fuzzy", variable=self.fuzzy_search_enabled,
                                 command=self.refresh_results,
                                 bg=self.bg_color, fg=self.fg_color,
                                 selectcolor=self.input_bg, activebackground=self.bg_color,
                                 font=("Arial", 9))
        fuzzy_cb.pack(side=tk.LEFT, padx=(0, 8))

        # Program Number
        tk.Label(row1, text="Prog #:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        self.filter_program = tk.Entry(row1, bg=self.input_bg, fg=self.fg_color, width=12)
        self.filter_program.pack(side=tk.LEFT, padx=(2, 5))
        self.filter_program.bind('<KeyRelease>', lambda e: self.refresh_results())
        
        # Spacer Type
        tk.Label(row1, text="Type:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        type_values = self.available_types if self.available_types else self.config["spacer_types"]
        self.filter_type = MultiSelectCombobox(row1, type_values, self.bg_color, self.fg_color,
                                              self.input_bg, self.button_bg, width=15)
        self.filter_type.pack(side=tk.LEFT, padx=5)

        # Material
        tk.Label(row1, text="Material:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        material_values = self.available_materials if self.available_materials else self.config["material_list"]
        self.filter_material = MultiSelectCombobox(row1, material_values, self.bg_color, self.fg_color,
                                                  self.input_bg, self.button_bg, width=15)
        self.filter_material.pack(side=tk.LEFT, padx=5)

        # Validation Status
        tk.Label(row1, text="Status:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        status_values = self.available_statuses if self.available_statuses else [
            "CRASH_RISK", "CRASH_WARNING", "CRITICAL", "TOOL_HOME_CRITICAL",
            "SAFETY_ERROR", "TOOL_ERROR", "BORE_WARNING", "TOOL_HOME_WARNING",
            "DIMENSIONAL", "TOOL_WARNING", "WARNING", "PASS"
        ]
        self.filter_status = MultiSelectCombobox(row1, status_values, self.bg_color, self.fg_color,
                                                self.input_bg, self.button_bg, width=18)
        self.filter_status.pack(side=tk.LEFT, padx=5)

        # Duplicate Type
        tk.Label(row1, text="Dup Type:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        dup_type_values = ["SOLID", "NAME_COLLISION", "CONTENT_DUP", "None"]
        self.filter_dup_type = MultiSelectCombobox(row1, dup_type_values, self.bg_color, self.fg_color,
                                                   self.input_bg, self.button_bg, width=15)
        self.filter_dup_type.pack(side=tk.LEFT, padx=5)

        # Crash Type
        tk.Label(row1, text="Crash Type:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        crash_type_values = ["G00 Rapid to Z", "Diagonal Rapid", "Z Before Tool Home", "Jaw Clearance", "All Crashes"]
        self.filter_crash_type = MultiSelectCombobox(row1, crash_type_values, self.bg_color, self.fg_color,
                                                     self.input_bg, self.button_bg, width=18)
        self.filter_crash_type.pack(side=tk.LEFT, padx=5)

        # Row 2 - All dimensional range filters on one row, each box flush to its longest value
        row2 = tk.Frame(filter_container, bg=self.bg_color)
        row2.pack(fill=tk.X, pady=5)

        # OD Range — longest "10.25" = 5 chars
        tk.Label(row2, text="OD:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(5, 2))
        od_values = ["", "5.75", "6.0", "6.25", "6.5", "7.0", "7.5", "8.0", "8.5", "9.5", "10.25", "10.5", "13.0"]
        self.filter_od_min = ttk.Combobox(row2, values=od_values, width=5)
        self.filter_od_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_od_max = ttk.Combobox(row2, values=od_values, width=5)
        self.filter_od_max.pack(side=tk.LEFT, padx=(1, 6))

        # Thickness — longest "0.25" = 4 chars
        tk.Label(row2, text="Thick:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        thick_values = ["", "0.25", "0.38", "0.5", "0.62", "0.75", "1.0", "1.25", "1.5", "1.75", "2.0", "2.5", "3.0"]
        self.filter_thickness_min = ttk.Combobox(row2, values=thick_values, width=4)
        self.filter_thickness_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_thickness_max = ttk.Combobox(row2, values=thick_values, width=4)
        self.filter_thickness_max.pack(side=tk.LEFT, padx=(1, 6))

        # Center Bore (mm) — longest "220" = 3 chars
        tk.Label(row2, text="CB:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        cb_values = ["", "38", "40", "50", "54", "56", "60", "63", "66", "70", "77", "78", "84", "93", "100", "106", "108", "110", "125", "130", "150", "170", "220"]
        self.filter_cb_min = ttk.Combobox(row2, values=cb_values, width=3)
        self.filter_cb_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_cb_max = ttk.Combobox(row2, values=cb_values, width=3)
        self.filter_cb_max.pack(side=tk.LEFT, padx=(1, 6))

        # Hub Diameter (mm) — longest "110" = 3 chars
        tk.Label(row2, text="Hub Dia:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        hub_dia_values = ["", "54", "56", "57", "59", "60", "63", "66", "70", "73", "74", "77", "78", "84", "87", "93", "95", "100", "106", "108", "110"]
        self.filter_hub_dia_min = ttk.Combobox(row2, values=hub_dia_values, width=3)
        self.filter_hub_dia_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_hub_dia_max = ttk.Combobox(row2, values=hub_dia_values, width=3)
        self.filter_hub_dia_max.pack(side=tk.LEFT, padx=(1, 6))

        # Hub Height (inches) — longest "1.25" = 4 chars
        tk.Label(row2, text="Hub H:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        hub_h_values = ["", "0.25", "0.33", "0.38", "0.44", "0.47", "0.5", "0.55", "0.6", "0.65", "0.7", "0.75", "1.0", "1.25", "1.5"]
        self.filter_hub_h_min = ttk.Combobox(row2, values=hub_h_values, width=4)
        self.filter_hub_h_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_hub_h_max = ttk.Combobox(row2, values=hub_h_values, width=4)
        self.filter_hub_h_max.pack(side=tk.LEFT, padx=(1, 6))

        # Step Diameter (mm) — longest "130" = 3 chars
        tk.Label(row2, text="Step D:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        step_d_values = ["", "64", "70", "74", "78", "82", "84", "85", "87", "90", "93", "95", "100", "106", "108", "110", "125", "130"]
        self.filter_step_d_min = ttk.Combobox(row2, values=step_d_values, width=3)
        self.filter_step_d_min.pack(side=tk.LEFT, padx=1)
        tk.Label(row2, text="–", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT)
        self.filter_step_d_max = ttk.Combobox(row2, values=step_d_values, width=3)
        self.filter_step_d_max.pack(side=tk.LEFT, padx=1)

        # Row 2.6 - Error type filter
        row2_6 = tk.Frame(filter_container, bg=self.bg_color)
        row2_6.pack(fill=tk.X, pady=5)

        tk.Label(row2_6, text="Error Contains:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=5)

        # Combobox with common error types (editable for custom searches)
        common_errors = [
            "",  # Empty for "all"
            # --- Crash / Safety ---
            "CRASH RISK",
            "Diagonal rapid",
            "Z before G53",
            "JAW CLEARANCE",
            "BORE CHAMFER CRASH",
            # --- Turning / OD ---
            "Hub face plunge",
            "exceeds standard depth",
            "OUT OF COMMON PRACTICE",
            # --- Work Offset ---
            "no work offset",
            # --- Dimensional / Title ---
            "THICKNESS ERROR",
            "TITLE MISLABELED",
            "P-CODE MISMATCH",
            "FILENAME MISMATCH",
            "CB TOO LARGE",
            "CB TOO SMALL",
            "OB TOO LARGE",
            "OB TOO SMALL",
            "OD MISMATCH",
            # --- 2PC ---
            "2PC ring size",
            "2PC LUG recess",
            # --- Steel Ring ---
            "Steel ring",
            # --- Hub / Bore ---
            "HUB BREAK-THROUGH",
            "Counterbore",
            "DRILL",
            "CHAMFER",
            "STEP",
            "HUB",
            "BORE",
            # --- Tool Home ---
            "G53",
            "TOOL_HOME",
            "Z-16",
            "Z-13",
            "Z-11",
            "Z-9",
            # --- Haas Validation ---
            "G00 and G01",
            "G01 without feedrate",
            "G96",
            "G50",
            "M08",
            "M09",
            "M05",
            "M30",
            "decimal point",
            "coolant",
        ]
        # Store raw keywords so _update_error_filter_counts can add (N) suffixes
        self._error_filter_keywords = common_errors
        # Longest keyword + counter suffix: "exceeds standard depth (2121)" = 29 chars
        self.filter_error_text = ttk.Combobox(row2_6, values=common_errors, width=30)
        self.filter_error_text.pack(side=tk.LEFT, padx=2)
        self.filter_error_text.set("")  # Default to empty

        # Date Imported — same row, right of error filter
        tk.Label(row2_6, text="Date:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=(12, 2))
        tk.Label(row2_6, text="From:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(0, 2))
        self.filter_date_from = tk.Entry(row2_6, width=10, bg=self.input_bg, fg=self.fg_color)
        self.filter_date_from.pack(side=tk.LEFT, padx=2)
        tk.Label(row2_6, text="To:", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=(4, 2))
        self.filter_date_to = tk.Entry(row2_6, width=10, bg=self.input_bg, fg=self.fg_color)
        self.filter_date_to.pack(side=tk.LEFT, padx=2)
        tk.Label(row2_6, text="YYYY-MM-DD",
                bg=self.bg_color, fg="#888888", font=("Arial", 8, "italic")).pack(side=tk.LEFT, padx=4)

        # Row 3 - Sort options
        row3 = tk.Frame(filter_container, bg=self.bg_color)
        row3.pack(fill=tk.X, pady=5)

        tk.Label(row3, text="Sort by:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=5)

        # Sort columns available
        sort_columns = ["", "Program #", "Dup", "Type", "Lathe", "OD", "Thick", "CB", "Hub H", "Hub D",
                       "CB Bore", "Step D", "Material", "Status"]

        # Sort 1
        self.sort1_col = ttk.Combobox(row3, values=sort_columns, state="readonly", width=10)
        self.sort1_col.pack(side=tk.LEFT, padx=2)
        self.sort1_col.set("CB")
        self.sort1_dir = ttk.Combobox(row3, values=["Low→High", "High→Low"], state="readonly", width=9)
        self.sort1_dir.pack(side=tk.LEFT, padx=2)
        self.sort1_dir.set("Low→High")

        tk.Label(row3, text="then", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=3)

        # Sort 2
        self.sort2_col = ttk.Combobox(row3, values=sort_columns, state="readonly", width=10)
        self.sort2_col.pack(side=tk.LEFT, padx=2)
        self.sort2_col.set("OD")
        self.sort2_dir = ttk.Combobox(row3, values=["Low→High", "High→Low"], state="readonly", width=9)
        self.sort2_dir.pack(side=tk.LEFT, padx=2)
        self.sort2_dir.set("Low→High")

        tk.Label(row3, text="then", bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=3)

        # Sort 3
        self.sort3_col = ttk.Combobox(row3, values=sort_columns, state="readonly", width=10)
        self.sort3_col.pack(side=tk.LEFT, padx=2)
        self.sort3_col.set("")
        self.sort3_dir = ttk.Combobox(row3, values=["Low→High", "High→Low"], state="readonly", width=9)
        self.sort3_dir.pack(side=tk.LEFT, padx=2)
        self.sort3_dir.set("Low→High")

        btn_sort = tk.Button(row3, text="↕️ Sort", command=self.apply_multi_sort,
                            bg=self.button_bg, fg=self.fg_color,
                            font=("Arial", 9, "bold"), width=8)
        btn_sort.pack(side=tk.LEFT, padx=5)

        # Row 4 - Action buttons
        row4 = tk.Frame(filter_container, bg=self.bg_color)
        row4.pack(fill=tk.X, pady=5)

        btn_search = tk.Button(row4, text="🔍 Search", command=self.refresh_results,
                              bg=self.accent_color, fg=self.fg_color,
                              font=("Arial", 10, "bold"), width=12, height=1)
        btn_search.pack(side=tk.LEFT, padx=5)

        btn_refresh = tk.Button(row4, text="🔄 Refresh", command=self.refresh_results,
                               bg="#2E7D32", fg=self.fg_color,
                               font=("Arial", 10, "bold"), width=12, height=1)
        btn_refresh.pack(side=tk.LEFT, padx=5)

        btn_clear = tk.Button(row4, text="❌ Clear Filters", command=self.clear_filters,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"), width=12, height=1)
        btn_clear.pack(side=tk.LEFT, padx=5)

        btn_batch = tk.Button(row4, text="📦 Batch Operations", command=self.show_batch_operations,
                             bg="#FF6F00", fg=self.fg_color,
                             font=("Arial", 10, "bold"), width=15, height=1)
        btn_batch.pack(side=tk.LEFT, padx=5)

        btn_2pc_match = tk.Button(row4, text="🔗 Find 2PC Match",
                                  command=self.show_2pc_cb_search_dialog,
                                  bg="#1565C0", fg=self.fg_color,
                                  font=("Arial", 10, "bold"), width=14, height=1)
        btn_2pc_match.pack(side=tk.LEFT, padx=5)

        # Duplicates only checkbox
        self.filter_duplicates = tk.BooleanVar()
        dup_check = tk.Checkbutton(row4, text="Duplicates Only", variable=self.filter_duplicates,
                                   bg=self.bg_color, fg=self.fg_color, selectcolor=self.input_bg,
                                   activebackground=self.bg_color, activeforeground=self.fg_color,
                                   font=("Arial", 9))
        dup_check.pack(side=tk.LEFT, padx=10)

        # Missing file path checkbox
        self.filter_missing_file_path = tk.BooleanVar()
        missing_path_check = tk.Checkbutton(row4, text="Missing File Path", variable=self.filter_missing_file_path,
                                           bg=self.bg_color, fg=self.fg_color, selectcolor=self.input_bg,
                                           activebackground=self.bg_color, activeforeground=self.fg_color,
                                           font=("Arial", 9))
        missing_path_check.pack(side=tk.LEFT, padx=10)

        # Results count label
        self.results_label = tk.Label(row4, text="", bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 10))
        self.results_label.pack(side=tk.RIGHT, padx=10)
        
    def create_results_section(self, parent):
        """Create results table"""
        # Create treeview with scrollbars
        tree_frame = tk.Frame(parent, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal")
        
        # Treeview
        columns = ("Program #", "Dup", "Title", "Type", "Lathe", "OD", "Thick", "CB", "Hub H", "Hub D",
                  "CB Bore", "Step D", "Material", "Tool Home", "Feasibility", "Status", "Warning Details", "File")

        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                                yscrollcommand=vsb.set, xscrollcommand=hsb.set,
                                selectmode='extended')  # Enable multi-select with Ctrl/Shift

        # Configure tags for color coding (severity-based)
        self.tree.tag_configure('crash_risk', background='#5d0f1f', foreground='#ff1744')      # BRIGHT RED/MAGENTA - Crash patterns (highest priority)
        self.tree.tag_configure('critical', background='#4d1f1f', foreground='#ff6b6b')         # RED - Critical errors
        self.tree.tag_configure('tool_home_critical', background='#5d0f0f', foreground='#ff3333')  # DARK RED - G53 Z-16 (dangerous)
        self.tree.tag_configure('safety_error', background='#3d1515', foreground='#ff4444')    # DARK RED - Safety blocks missing
        self.tree.tag_configure('tool_error', background='#4d2515', foreground='#ff7744')      # ORANGE-RED - Tool errors
        self.tree.tag_configure('crash_warning', background='#4d2a15', foreground='#ff8844')   # ORANGE - Crash warnings (jaw clearance, etc.)
        self.tree.tag_configure('bore_warning', background='#4d3520', foreground='#ffa500')    # ORANGE - Bore warnings
        self.tree.tag_configure('tool_home_warning', background='#4d3820', foreground='#ffbb44')  # AMBER - G53 Z mismatch
        self.tree.tag_configure('dimensional', background='#3d1f4d', foreground='#da77f2')     # PURPLE - P-code/thickness
        self.tree.tag_configure('tool_warning', background='#4d4015', foreground='#ffcc44')    # AMBER - Tool suggestions
        self.tree.tag_configure('warning', background='#4d3d1f', foreground='#ffd43b')         # YELLOW - General warnings
        self.tree.tag_configure('repeat', background='#3d3d3d', foreground='#909090')          # GRAY - Repeat files
        self.tree.tag_configure('pass', background='#1f4d2e', foreground='#69db7c')            # GREEN - Pass
        
        vsb.config(command=self.tree.yview)
        hsb.config(command=self.tree.xview)
        
        # Configure columns
        column_widths = {
            "Program #": 100,
            "Dup": 40,
            "Title": 250,
            "Type": 120,
            "Lathe": 60,
            "OD": 80,
            "Thick": 80,
            "CB": 80,
            "Hub H": 80,
            "Hub D": 80,
            "CB Bore": 80,
            "Step D": 70,
            "Material": 100,
            "Tool Home": 75,
            "Feasibility": 85,
            "Status": 90,
            "Warning Details": 300,
            "File": 200
        }
        
        for col in columns:
            self.tree.heading(col, text=col, command=lambda c=col: self.sort_column(c))
            # Warning Details and Title should be left-aligned for readability
            if col in ["Warning Details", "Title", "File"]:
                self.tree.column(col, width=column_widths[col], anchor="w")
            else:
                self.tree.column(col, width=column_widths[col], anchor="center")
        
        # Layout
        self.tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")
        
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)
        
        # Context menu
        self.tree.bind("<Button-3>", self.show_context_menu)
        self.tree.bind("<Double-1>", self.open_file)
        self.tree.bind("<F5>", self.refresh_selected_file)  # F5 to refresh selected file

        # Bottom action buttons - made more compact, hidden based on permissions
        action_frame = tk.Frame(parent, bg=self.bg_color)
        action_frame.pack(fill=tk.X, padx=10, pady=(0, 5))

        btn_open = tk.Button(action_frame, text="📄 Open", command=self.open_file,
                            bg=self.button_bg, fg=self.fg_color,
                            font=("Arial", 8, "bold"), width=10)
        btn_open.pack(side=tk.LEFT, padx=3)

        # Edit button - only for editors and above
        if self.has_permission('edit_files'):
            btn_edit = tk.Button(action_frame, text="✏️ Edit", command=self.edit_entry,
                                bg=self.button_bg, fg=self.fg_color,
                                font=("Arial", 8, "bold"), width=10)
            btn_edit.pack(side=tk.LEFT, padx=3)

        # Delete button - only for admins
        if self.has_permission('delete_files'):
            btn_delete = tk.Button(action_frame, text="🗑️ Delete", command=self.delete_entry,
                                  bg=self.button_bg, fg=self.fg_color,
                                  font=("Arial", 8, "bold"), width=10)
            btn_delete.pack(side=tk.LEFT, padx=3)

        btn_view = tk.Button(action_frame, text="👁️ Details", command=self.view_details,
                            bg=self.button_bg, fg=self.fg_color,
                            font=("Arial", 8, "bold"), width=10)
        btn_view.pack(side=tk.LEFT, padx=3)

        btn_compare = tk.Button(action_frame, text="🔄 Compare", command=self.compare_files,
                               bg="#FF9800", fg=self.fg_color,
                               font=("Arial", 8, "bold"), width=12)
        btn_compare.pack(side=tk.LEFT, padx=3)

        # Status label for drag-drop feedback (separate from results counter)
        self.dragdrop_label = tk.Label(action_frame, text="",
                                     bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 9))
        self.dragdrop_label.pack(side=tk.RIGHT, padx=10)

    def setup_drag_drop(self):
        """Setup drag and drop for the main window"""
        try:
            from tkinterdnd2 import DND_FILES

            # Check if root is already a TkinterDnD.Tk instance
            # If not, we'll use event bindings as fallback
            try:
                self.root.drop_target_register(DND_FILES)
                self.root.dnd_bind('<<Drop>>', self.on_drop)
                self.root.dnd_bind('<<DragEnter>>', self.on_drag_enter)
                self.root.dnd_bind('<<DragLeave>>', self.on_drag_leave)
                print("[Drag & Drop] TkinterDnD2 enabled successfully")
            except Exception:
                print("[Drag & Drop] TkinterDnD2 not available, using fallback method")
                self._setup_drag_drop_fallback()
        except ImportError:
            print("[Drag & Drop] TkinterDnD2 not installed, using fallback method")
            self._setup_drag_drop_fallback()

    def _setup_drag_drop_fallback(self):
        """Fallback drag-drop using standard tk file dialog"""
        # Add a button to manually add files if drag-drop not available
        pass  # Manual add file functionality already exists via scan_folder

    def on_drag_enter(self, _):
        """Visual feedback when files are dragged over window"""
        self.root.configure(bg="#3a4a5a")  # Slightly lighter bg
        if hasattr(self, 'dragdrop_label'):
            self.dragdrop_label.config(text="Drop files here to import...")

    def on_drag_leave(self, _):
        """Restore appearance when drag leaves"""
        self.root.configure(bg=self.bg_color)
        if hasattr(self, 'dragdrop_label'):
            self.dragdrop_label.config(text="")

    def on_drop(self, event):
        """Handle dropped files"""
        self.root.configure(bg=self.bg_color)

        # Parse the file paths from the drop event
        files = self._parse_drop_files(event.data)

        if not files:
            if hasattr(self, 'dragdrop_label'):
                self.dragdrop_label.config(text="No valid files dropped")
            return

        # Filter for gcode files only
        gcode_files = [f for f in files if self._is_gcode_file(f)]

        if not gcode_files:
            messagebox.showwarning("No G-Code Files",
                                 f"No G-Code files found in {len(files)} dropped file(s).\n\n"
                                 "G-Code files must contain pattern: o##### (4+ digits)")
            if hasattr(self, 'dragdrop_label'):
                self.dragdrop_label.config(text="")
            return

        # Process the files
        self.process_dropped_files(gcode_files)

    def _parse_drop_files(self, data):
        """Parse file paths from drag-drop event data.

        tkinterdnd2 on Windows wraps each path that contains spaces in {}.
        Examples:
          Single no-spaces : C:/repo/o75445.nc
          Single w-spaces  : {C:/Users/John Wayne/repo/o75445.nc}
          Multiple         : {C:/Users/John Wayne/a.nc} C:/simple/b.nc
        """
        if isinstance(data, list):
            return data

        data = str(data)
        files = []

        # Pull out every {…} group first (handles spaces inside paths)
        brace_paths = re.findall(r'\{([^}]+)\}', data)
        files.extend(brace_paths)

        # Remove those groups, then split whatever remains on whitespace
        remainder = re.sub(r'\{[^}]+\}', '', data).strip()
        if remainder:
            files.extend(remainder.split())

        return [f.strip() for f in files if f.strip()]

    def _is_gcode_file(self, filepath):
        """Check if file is a G-code file based on naming pattern"""
        if not os.path.isfile(filepath):
            return False

        filename = os.path.basename(filepath)
        # Match files with o##### pattern (4+ digits)
        return bool(re.search(r'[oO]\d{4,}', filename))

    def process_dropped_files(self, filepaths):
        """
        Process dropped files with smart duplicate detection and warnings.

        Features:
        - Duplicate detection (exact content match)
        - Filename collision warnings with auto-rename suggestions
        - Program number mismatch warnings
        """
        # Get existing files from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("SELECT program_number, file_path FROM programs WHERE file_path IS NOT NULL")
        db_files = cursor.fetchall()

        # Build lookup structures
        db_programs = {}  # {program_number: file_path}
        db_filenames = {}  # {filename_lower: (program_number, file_path)}
        db_contents = {}  # {content_hash: (program_number, file_path)}

        for prog_num, file_path in db_files:
            db_programs[prog_num] = file_path

            if file_path and os.path.exists(file_path):
                filename_lower = os.path.basename(file_path).lower()
                db_filenames[filename_lower] = (prog_num, file_path)

                # Read content for exact duplicate detection
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        content_hash = hash(content)
                        db_contents[content_hash] = (prog_num, file_path)
                except Exception:
                    pass

        conn.close()

        # Analyze each dropped file
        files_to_add = []
        warnings = []

        for filepath in filepaths:
            filename = os.path.basename(filepath)
            filename_lower = filename.lower()

            # Extract program number from filename
            match = re.search(r'[oO](\d{4,})', filename)
            if not match:
                warnings.append(f"⚠️ Skipped {filename}: No program number found")
                continue

            file_prog_num = 'o' + match.group(1)

            # Read file content
            try:
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    content_hash = hash(content)
            except Exception as e:
                warnings.append(f"❌ Error reading {filename}: {str(e)}")
                continue

            # Check 1: Exact content duplicate
            if content_hash in db_contents:
                existing_prog, existing_path = db_contents[content_hash]
                existing_name = os.path.basename(existing_path)
                warnings.append(f"🔁 Duplicate: {filename} is identical to {existing_name} (already in database)")
                continue

            # Check 2: Filename collision (same name, different content)
            if filename_lower in db_filenames:
                existing_prog, existing_path = db_filenames[filename_lower]

                # Offer auto-rename suggestion
                suggestion = self._suggest_unique_filename(filename, db_filenames)

                result = messagebox.askyesnocancel(
                    "Filename Collision Detected",
                    f"File already exists: {filename}\n"
                    f"In database as: {existing_prog}\n\n"
                    f"The file you're adding has DIFFERENT content.\n\n"
                    f"Options:\n"
                    f"• YES: Save with suggested name: {suggestion}\n"
                    f"• NO: Skip this file\n"
                    f"• CANCEL: Stop importing\n\n"
                    f"Suggested name will also update internal program number."
                )

                if result is None:  # Cancel
                    break
                elif result:  # Yes - rename
                    # Add with new name
                    files_to_add.append((filepath, suggestion, content))
                    warnings.append(f"✏️ Renamed: {filename} → {suggestion}")
                else:  # No - skip
                    warnings.append(f"⏭️ Skipped: {filename} (filename collision)")
                continue

            # Check 3: Program number mismatch (filename != internal program number)
            # Parse the file to get internal program number
            internal_prog_num = self._extract_program_number_from_content(content)

            if internal_prog_num and internal_prog_num != file_prog_num:
                result = messagebox.askyesno(
                    "Program Number Mismatch",
                    f"Warning: Filename and internal program number don't match!\n\n"
                    f"Filename: {filename} ({file_prog_num})\n"
                    f"Internal: {internal_prog_num}\n\n"
                    f"This file may have been renamed incorrectly.\n\n"
                    f"Add it anyway?\n"
                    f"(It will be stored as {file_prog_num} based on filename)"
                )

                if not result:
                    warnings.append(f"⏭️ Skipped: {filename} (program number mismatch)")
                    continue
                else:
                    warnings.append(f"⚠️ Added with mismatch: {filename} (internal: {internal_prog_num})")

            # Check 4: Program number already exists (different file)
            if file_prog_num in db_programs:
                existing_path = db_programs[file_prog_num]
                existing_name = os.path.basename(existing_path)

                if existing_name.lower() != filename_lower:
                    result = messagebox.askyesno(
                        "Program Number Exists",
                        f"Program number {file_prog_num} already exists!\n\n"
                        f"Existing: {existing_name}\n"
                        f"New file: {filename}\n\n"
                        f"These appear to be different files with the same program number.\n\n"
                        f"Add the new file anyway?\n"
                        f"(Will replace the existing entry)"
                    )

                    if not result:
                        warnings.append(f"⏭️ Skipped: {filename} (program number exists)")
                        continue

            # All checks passed - add file
            files_to_add.append((filepath, filename, content))

        # Process files to add
        if files_to_add:
            self._import_files(files_to_add, warnings)

        # Show summary
        if warnings:
            summary = "\n".join(warnings)
            messagebox.showinfo("Import Summary",
                              f"Processed {len(filepaths)} file(s)\n"
                              f"Added: {len(files_to_add)}\n\n"
                              f"Details:\n{summary[:500]}")

        # Refresh the display
        self.refresh_results()

        if hasattr(self, 'dragdrop_label'):
            self.dragdrop_label.config(text=f"Imported {len(files_to_add)} file(s)")

    def _suggest_unique_filename(self, original_filename, existing_filenames):
        """Suggest a unique filename by appending _v2, _v3, etc."""
        base, ext = os.path.splitext(original_filename)

        # Extract program number
        match = re.search(r'([oO]\d{4,})', base)
        if not match:
            return original_filename

        prog_prefix = match.group(1)

        counter = 2
        while True:
            # Update program number
            new_prog_num = f"{prog_prefix[0]}{int(prog_prefix[1:]) + counter - 1}"
            new_filename = base.replace(prog_prefix, new_prog_num) + ext

            if new_filename.lower() not in existing_filenames:
                return new_filename

            counter += 1

            if counter > 1000:  # Safety limit
                return f"{base}_UNIQUE{ext}"

    def _extract_program_number_from_content(self, content):
        """Extract program number from G-code content"""
        # Look for O##### pattern in first few lines
        lines = content.split('\n')[:50]  # Check first 50 lines

        for line in lines:
            match = re.search(r'[oO](\d{4,})', line)
            if match:
                return 'o' + match.group(1)

        return None

    def _import_files(self, files_to_add, warnings):
        """Import files into the database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Use repository folder by default for drag & drop imports
        target_folder = self.repository_path if hasattr(self, 'repository_path') else self.config.get("target_folder", "")
        if not target_folder or not os.path.exists(target_folder):
            # Try to create repository folder if it doesn't exist
            if hasattr(self, 'repository_path'):
                os.makedirs(self.repository_path, exist_ok=True)
                target_folder = self.repository_path
            else:
                messagebox.showerror("No Target Folder",
                                   "Repository folder not found. Please check your installation.")
                conn.close()
                return

        for original_path, suggested_filename, _ in files_to_add:
            try:
                # Determine destination path
                dest_path = os.path.join(target_folder, suggested_filename)

                # Copy file to target folder
                if original_path != dest_path:
                    shutil.copy2(original_path, dest_path)

                # Parse the file
                record = self.parse_gcode_file(dest_path)
                if not record:
                    warnings.append(f"⚠️ Failed to parse: {suggested_filename}")
                    continue

                # Insert into database (or update if exists)
                cursor.execute("""
                    INSERT OR REPLACE INTO programs (
                        program_number, title, spacer_type, outer_diameter, thickness, thickness_display,
                        center_bore, hub_height, hub_diameter, counter_bore_diameter, counter_bore_depth,
                        paired_program, material, notes, date_created, last_modified, file_path,
                        detection_confidence, detection_method, validation_status, validation_issues,
                        validation_warnings, cb_from_gcode, ob_from_gcode, bore_warnings, dimensional_issues,
                        lathe, duplicate_type, parent_file, duplicate_group, current_version, modified_by, is_managed,
                        round_size, round_size_confidence, round_size_source, in_correct_range,
                        legacy_names, last_renamed_date, rename_reason,
                        tools_used, tool_sequence, tool_validation_status, tool_validation_issues,
                        safety_blocks_status, safety_blocks_issues, content_hash,
                        tool_home_status, tool_home_issues, hub_height_display, counter_bore_depth_display,
                        feasibility_status, feasibility_issues, feasibility_warnings,
                        crash_issues, crash_warnings, date_imported
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    record.program_number,
                    record.title,
                    record.spacer_type,
                    record.outer_diameter,
                    record.thickness,
                    record.thickness_display,
                    record.center_bore,
                    record.hub_height,
                    record.hub_diameter,
                    record.counter_bore_diameter,
                    record.counter_bore_depth,
                    record.paired_program,
                    record.material,
                    record.notes,
                    record.date_created,
                    record.last_modified,
                    record.file_path,
                    record.detection_confidence,
                    record.detection_method,
                    record.validation_status,
                    record.validation_issues,
                    record.validation_warnings,
                    record.cb_from_gcode,
                    record.ob_from_gcode,
                    record.bore_warnings,
                    record.dimensional_issues,
                    record.lathe,
                    None, None, None,  # duplicate_type, parent_file, duplicate_group
                    None, None, None,  # current_version, modified_by, is_managed
                    None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                    None, None, None,  # legacy_names, last_renamed_date, rename_reason
                    None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues
                    None, None,  # safety_blocks_status, safety_blocks_issues
                    None,  # content_hash
                    None, None,  # tool_home_status, tool_home_issues
                    None, None,  # hub_height_display, counter_bore_depth_display
                    None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings
                    None, None,  # crash_issues, crash_warnings
                    datetime.now().isoformat()  # date_imported
                ))

                # Sync registry for this program
                self.sync_registry_for_operation('ADD', None, record.program_number, dest_path)

                warnings.append(f"✅ Added: {suggested_filename}")

            except Exception as e:
                warnings.append(f"❌ Error importing {suggested_filename}: {str(e)}")

        conn.commit()
        conn.close()

    def _import_single_file(self, filepath):
        """Import a single file into the database"""
        from datetime import datetime

        try:
            # Parse the file
            record = self.parse_gcode_file(filepath)
            if not record:
                logger.warning(f"Failed to parse file: {filepath}")
                return False

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Insert into database (or update if exists)
            cursor.execute("""
                INSERT OR REPLACE INTO programs (
                    program_number, title, spacer_type, outer_diameter, thickness, thickness_display,
                    center_bore, hub_height, hub_diameter, counter_bore_diameter, counter_bore_depth,
                    paired_program, material, notes, date_created, last_modified, file_path,
                    detection_confidence, detection_method, validation_status, validation_issues,
                    validation_warnings, cb_from_gcode, ob_from_gcode, bore_warnings, dimensional_issues,
                    lathe, duplicate_type, parent_file, duplicate_group, current_version, modified_by, is_managed,
                    round_size, round_size_confidence, round_size_source, in_correct_range,
                    legacy_names, last_renamed_date, rename_reason,
                    tools_used, tool_sequence, tool_validation_status, tool_validation_issues,
                    safety_blocks_status, safety_blocks_issues, content_hash,
                    tool_home_status, tool_home_issues, hub_height_display, counter_bore_depth_display,
                    feasibility_status, feasibility_issues, feasibility_warnings,
                    crash_issues, crash_warnings, date_imported
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                record.program_number,
                record.title,
                record.spacer_type,
                record.outer_diameter,
                record.thickness,
                record.thickness_display,
                record.center_bore,
                record.hub_height,
                record.hub_diameter,
                record.counter_bore_diameter,
                record.counter_bore_depth,
                record.paired_program,
                record.material,
                record.notes,
                record.date_created,
                record.last_modified,
                record.file_path,
                record.detection_confidence,
                record.detection_method,
                record.validation_status,
                record.validation_issues,
                record.validation_warnings,
                record.cb_from_gcode,
                record.ob_from_gcode,
                record.bore_warnings,
                record.dimensional_issues,
                record.lathe,
                None, None, None,  # duplicate_type, parent_file, duplicate_group
                None, None, None,  # current_version, modified_by, is_managed
                None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                None, None, None,  # legacy_names, last_renamed_date, rename_reason
                None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues
                None, None,  # safety_blocks_status, safety_blocks_issues
                None,  # content_hash
                None, None,  # tool_home_status, tool_home_issues
                None, None,  # hub_height_display, counter_bore_depth_display
                None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings
                None, None,  # crash_issues, crash_warnings
                datetime.now().isoformat()  # date_imported
            ))

            conn.commit()
            conn.close()

            # Sync registry for this program
            self.sync_registry_for_operation('ADD', None, record.program_number, filepath)

            logger.info(f"Imported single file: {record.program_number}")
            return True

        except Exception as e:
            logger.error(f"Error importing single file {filepath}: {e}", exc_info=True)
            return False

    def parse_gcode_file(self, filepath: str) -> Optional[ProgramRecord]:
        """Parse a gcode file using the improved parser"""
        try:
            # Use improved parser
            result = self.parser.parse_file(filepath)
            if not result:
                return None

            # Determine validation status (prioritized by severity)
            validation_status = "PASS"
            if result.crash_issues:
                validation_status = "CRASH_RISK"  # CRASH - Most critical, machine damage risk
            elif result.validation_issues:
                validation_status = "CRITICAL"  # RED - Critical errors
            elif result.tool_home_status == "CRITICAL":
                validation_status = "TOOL_HOME_CRITICAL"  # DARK RED - G53 Z-16 or beyond (dangerous)
            elif result.crash_warnings:
                validation_status = "CRASH_WARNING"  # Crash warnings
            elif result.bore_warnings:
                validation_status = "BORE_WARNING"  # ORANGE - Bore dimension warnings
            elif result.tool_home_status == "WARNING":
                validation_status = "TOOL_HOME_WARNING"  # AMBER - G53 Z doesn't match thickness
            elif result.dimensional_issues:
                validation_status = "DIMENSIONAL"  # PURPLE - P-code/thickness mismatches
            elif result.validation_warnings:
                validation_status = "WARNING"  # YELLOW - General warnings

            # Convert to ProgramRecord
            return ProgramRecord(
                program_number=result.program_number,
                title=result.title,
                spacer_type=result.spacer_type,
                outer_diameter=result.outer_diameter,
                thickness=result.thickness,
                thickness_display=result.thickness_display,
                center_bore=result.center_bore,
                hub_height=result.hub_height,
                hub_diameter=result.hub_diameter,
                counter_bore_diameter=result.counter_bore_diameter,
                counter_bore_depth=result.counter_bore_depth,
                paired_program=None,
                material=result.material,
                notes=None,
                date_created=result.date_created,
                last_modified=result.last_modified,
                file_path=result.file_path,
                detection_confidence=result.detection_confidence,
                detection_method=result.detection_method,
                validation_status=validation_status,
                validation_issues=json.dumps(result.validation_issues) if result.validation_issues else None,
                validation_warnings=json.dumps(result.validation_warnings) if result.validation_warnings else None,
                bore_warnings=json.dumps(result.bore_warnings) if result.bore_warnings else None,
                dimensional_issues=json.dumps(result.dimensional_issues) if result.dimensional_issues else None,
                cb_from_gcode=result.cb_from_gcode,
                ob_from_gcode=result.ob_from_gcode,
                lathe=result.lathe,
                tool_home_status=result.tool_home_status,
                tool_home_issues=result.tool_home_issues,
                crash_issues=result.crash_issues,
                crash_warnings=result.crash_warnings,
                feasibility_status=getattr(result, 'feasibility_status', None),
                feasibility_issues=getattr(result, 'feasibility_issues', None),
                feasibility_warnings=getattr(result, 'feasibility_warnings', None),
                tools_used=getattr(result, 'tools_used', None),
                tool_sequence=getattr(result, 'tool_sequence', None)
            )

        except Exception as e:
            logger.error(f"Error parsing {filepath}: {e}", exc_info=True)
            return None

    def extract_dimension(self, text: str, patterns: List[str]) -> Optional[float]:
        """Extract dimension using multiple regex patterns"""
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                try:
                    return float(match.group(1))
                except:
                    continue
        return None

    def update_gcode_program_number(self, file_path, new_program_number):
        """Update the internal O-number in a G-code file

        Args:
            file_path: Path to the G-code file
            new_program_number: New program number (e.g., "o57001" or "57001")

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Ensure program number has 'o' prefix
            if not new_program_number.lower().startswith('o'):
                new_program_number = 'o' + new_program_number

            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            # Find and update the program number line (usually first line starting with O)
            updated = False
            for i, line in enumerate(lines):
                stripped = line.strip().upper()
                # Match O##### at start of line
                if stripped.startswith('O') and re.match(r'^O\d{4,}', stripped):
                    # Replace the O-number
                    lines[i] = new_program_number.upper() + '\n'
                    updated = True
                    break

            if updated:
                # Write back to file
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                return True
            else:
                # No O-number found in file, add it at the beginning
                lines.insert(0, new_program_number.upper() + '\n')
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
                return True

        except OSError as e:
            logger.error(f"File operation error updating G-code program number: {e}")
            return False
        except Exception as e:
            logger.error(f"Error updating G-code program number: {e}", exc_info=True)
            return False

    def scan_folder(self):
        """Scan a folder for gcode files and import them - runs in background thread"""
        folder = filedialog.askdirectory(title="Select Folder with G-Code Files",
                                        initialdir=self.config.get("last_folder", ""))

        if not folder:
            return

        # Ask user: Import to repository or keep external?
        import_mode_dialog = tk.Toplevel(self.root)
        import_mode_dialog.title("Import Mode")
        import_mode_dialog.geometry("550x300")
        import_mode_dialog.configure(bg=self.bg_color)
        import_mode_dialog.transient(self.root)
        import_mode_dialog.grab_set()

        # Title
        tk.Label(import_mode_dialog, text="📁 Choose Import Mode",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=15)

        # Description
        desc = ("How would you like to handle the scanned files?\n\n"
                "• Repository: Copy files to managed repository folder\n"
                "  (Files under your control, organized, tracked)\n\n"
                "• External: Reference files in their current location\n"
                "  (Files stay where they are, temporary view)")
        tk.Label(import_mode_dialog, text=desc,
                font=("Arial", 10), bg=self.bg_color, fg=self.fg_color,
                justify=tk.LEFT).pack(padx=20, pady=10)

        # Store result
        import_to_repo = [False]  # Use list to allow modification in nested function

        def choose_repository():
            import_to_repo[0] = True
            import_mode_dialog.destroy()

        def choose_external():
            import_to_repo[0] = False
            import_mode_dialog.destroy()

        # Buttons
        btn_frame = tk.Frame(import_mode_dialog, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="📁 Repository\n(Copy to Repository)",
                 command=choose_repository,
                 bg="#388E3C", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=20, height=3).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="🔍 External\n(Keep in Place)",
                 command=choose_external,
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=20, height=3).pack(side=tk.LEFT, padx=10)

        # Wait for user choice
        self.root.wait_window(import_mode_dialog)

        # Store the choice for this scan
        add_to_repository = import_to_repo[0]

        self.config["last_folder"] = folder
        self.save_config()

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Scanning Files...")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Scanning folder...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 9),
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Cancel button and flag
        scan_cancelled = [False]

        def cancel_scan():
            scan_cancelled[0] = True
            cancel_btn.config(state=tk.DISABLED, text="Cancelling...")

        cancel_btn = tk.Button(progress_window, text="Cancel Scan",
                              command=cancel_scan,
                              bg="#D32F2F", fg=self.fg_color,
                              font=("Arial", 10, "bold"))
        cancel_btn.pack(pady=5)

        # Message queue for thread-safe GUI updates
        msg_queue = queue.Queue()

        # Capture values needed by background thread (thread safety)
        db_path = self.db_path
        current_username = self.current_username
        repository_path = self.repository_path if hasattr(self, 'repository_path') else None

        def update_gui():
            """Process messages from the background thread to update GUI"""
            try:
                while True:
                    msg = msg_queue.get_nowait()
                    if msg[0] == 'label':
                        progress_label.config(text=msg[1])
                    elif msg[0] == 'text':
                        progress_text.insert(tk.END, msg[1])
                        progress_text.see(tk.END)
                    elif msg[0] == 'done':
                        # Scan complete - show close button
                        cancel_btn.pack_forget()
                        close_btn = tk.Button(progress_window, text="Close",
                                             command=progress_window.destroy,
                                             bg=self.button_bg, fg=self.fg_color,
                                             font=("Arial", 10, "bold"))
                        close_btn.pack(pady=10)
                        # Refresh results on main thread
                        self.refresh_filter_values()
                        self.refresh_results()
                        return  # Stop the update loop
                    elif msg[0] == 'cancelled':
                        progress_label.config(text="Scan cancelled by user")
                        cancel_btn.pack_forget()
                        close_btn = tk.Button(progress_window, text="Close",
                                             command=progress_window.destroy,
                                             bg=self.button_bg, fg=self.fg_color,
                                             font=("Arial", 10, "bold"))
                        close_btn.pack(pady=10)
                        self.refresh_filter_values()
                        self.refresh_results()
                        return
            except queue.Empty:
                pass

            # Schedule next check
            if progress_window.winfo_exists():
                progress_window.after(100, update_gui)

        def scan_thread():
            """Background thread that does the actual scanning"""
            from datetime import datetime
            import json
            try:
                # Create a local parser instance for thread safety
                local_parser = ImprovedGCodeParser()

                # Scan for gcode files (with or without extension)
                all_scanned_files = []
                file_count = 0
                for root_dir, dirs, files in os.walk(folder):
                    if scan_cancelled[0]:
                        msg_queue.put(('cancelled', None))
                        return
                    for file in files:
                        # Match any file containing o##### pattern (4+ digits)
                        if re.search(r'[oO]\d{4,}', file):
                            all_scanned_files.append(os.path.join(root_dir, file))
                            file_count += 1
                            # Update progress every 50 files
                            if file_count % 50 == 0:
                                msg_queue.put(('label', f"Scanning... found {file_count} files so far"))

                if scan_cancelled[0]:
                    msg_queue.put(('cancelled', None))
                    return

                msg_queue.put(('label', f"Analyzing {len(all_scanned_files)} files..."))
                msg_queue.put(('text', f"Found {len(all_scanned_files)} total files. Analyzing...\n\n"))

                # Get existing files from database
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT file_path FROM programs WHERE file_path IS NOT NULL")
                existing_files_data = {}  # {filename_lower: [file_paths]}

                for row in cursor.fetchall():
                    file_path = row[0]
                    if file_path and os.path.exists(file_path):
                        basename = os.path.basename(file_path).lower()
                        if basename not in existing_files_data:
                            existing_files_data[basename] = []
                        existing_files_data[basename].append(file_path)

                # Detect duplicates within the scan AND against database
                files_by_name = {}  # Group scanned files by filename
                for filepath in all_scanned_files:
                    basename_lower = os.path.basename(filepath).lower()
                    if basename_lower not in files_by_name:
                        files_by_name[basename_lower] = []
                    files_by_name[basename_lower].append(filepath)

                # Categorize files
                files_to_process = []
                exact_duplicates_db = []  # Same name + content as database
                exact_duplicates_scan = []  # Same name + content within scan
                name_collisions_db = []  # Same name, different content vs database
                name_collisions_scan = []  # Same name, different content within scan

                analyzed_count = 0
                total_unique_names = len(files_by_name)

                for basename_lower, filepaths in files_by_name.items():
                    if scan_cancelled[0]:
                        conn.close()
                        msg_queue.put(('cancelled', None))
                        return

                    analyzed_count += 1
                    # Update progress every 10 unique filenames
                    if analyzed_count % 10 == 0 or analyzed_count == total_unique_names:
                        msg_queue.put(('label', f"Analyzing duplicates... {analyzed_count}/{total_unique_names}"))

                    # Check against database first
                    in_database = basename_lower in existing_files_data

                    if len(filepaths) == 1:
                        # Single file with this name in scan
                        filepath = filepaths[0]

                        if in_database:
                            # Compare content with database file(s)
                            try:
                                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                                    new_content = f.read()

                                is_exact_match = False
                                for db_path in existing_files_data[basename_lower]:
                                    try:
                                        with open(db_path, 'r', encoding='utf-8', errors='ignore') as f:
                                            db_content = f.read()
                                        if new_content == db_content:
                                            is_exact_match = True
                                            break
                                    except:
                                        continue

                                if is_exact_match:
                                    exact_duplicates_db.append(filepath)
                                else:
                                    name_collisions_db.append((filepath, existing_files_data[basename_lower][0]))
                            except:
                                name_collisions_db.append((filepath, existing_files_data[basename_lower][0]))
                        else:
                            # New file, safe to add
                            files_to_process.append(filepath)

                    else:
                        # Multiple files with same name in scan
                        # Read all contents and find unique ones
                        file_contents = {}
                        for filepath in filepaths:
                            try:
                                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                                    content = f.read()
                                if content not in file_contents:
                                    file_contents[content] = []
                                file_contents[content].append(filepath)
                            except:
                                # If can't read, treat as unique
                                file_contents[filepath] = [filepath]

                        # For each unique content, keep first file
                        for content, paths in file_contents.items():
                            first_file = paths[0]
                            duplicates_in_scan = paths[1:]

                            # Check if this content matches database
                            if in_database:
                                try:
                                    is_exact_match = False
                                    for db_path in existing_files_data[basename_lower]:
                                        try:
                                            with open(db_path, 'r', encoding='utf-8', errors='ignore') as f:
                                                db_content = f.read()
                                            if content == db_content:
                                                is_exact_match = True
                                                break
                                        except:
                                            continue

                                    if is_exact_match:
                                        exact_duplicates_db.append(first_file)
                                    else:
                                        name_collisions_db.append((first_file, existing_files_data[basename_lower][0]))
                                except:
                                    name_collisions_db.append((first_file, existing_files_data[basename_lower][0]))
                            else:
                                # New unique content, add first one
                                files_to_process.append(first_file)

                            # Mark duplicates within scan
                            for dup in duplicates_in_scan:
                                exact_duplicates_scan.append((dup, first_file))

                # Display analysis results
                msg_queue.put(('text', f"=== SCAN ANALYSIS ===\n"))
                msg_queue.put(('text', f"Files to process: {len(files_to_process)}\n"))
                msg_queue.put(('text', f"Exact duplicates (vs database): {len(exact_duplicates_db)}\n"))
                msg_queue.put(('text', f"Exact duplicates (within scan): {len(exact_duplicates_scan)}\n"))
                msg_queue.put(('text', f"Name collisions (vs database): {len(name_collisions_db)}\n"))
                msg_queue.put(('text', f"Name collisions (within scan): {len(name_collisions_scan)}\n\n"))

                # Show details
                if exact_duplicates_db:
                    msg_queue.put(('text', f"=== SKIPPING - Already in Database (Exact Match) ===\n"))
                    for dup in exact_duplicates_db[:10]:
                        msg_queue.put(('text', f"  SKIP: {os.path.basename(dup)}\n"))
                    if len(exact_duplicates_db) > 10:
                        msg_queue.put(('text', f"  ... and {len(exact_duplicates_db) - 10} more\n"))
                    msg_queue.put(('text', "\n"))

                if exact_duplicates_scan:
                    msg_queue.put(('text', f"=== SKIPPING - Duplicates Within Scan ===\n"))
                    for dup, kept in exact_duplicates_scan[:10]:
                        msg_queue.put(('text', f"  SKIP: {os.path.basename(dup)} (same as {os.path.basename(kept)})\n"))
                    if len(exact_duplicates_scan) > 10:
                        msg_queue.put(('text', f"  ... and {len(exact_duplicates_scan) - 10} more\n"))
                    msg_queue.put(('text', "\n"))

                if name_collisions_db:
                    msg_queue.put(('text', f"⚠️  WARNING - Name Collisions vs Database ===\n"))
                    msg_queue.put(('text', f"These files will be SKIPPED. Rename them first!\n\n"))
                    for new_file, db_file in name_collisions_db[:5]:
                        msg_queue.put(('text', f"  ⚠️  {os.path.basename(new_file)}\n"))
                        msg_queue.put(('text', f"     Scan: {new_file}\n"))
                        msg_queue.put(('text', f"     Database: {db_file}\n\n"))
                    if len(name_collisions_db) > 5:
                        msg_queue.put(('text', f"  ... and {len(name_collisions_db) - 5} more\n"))
                    msg_queue.put(('text', "\n"))

                msg_queue.put(('text', f"Processing {len(files_to_process)} files...\n\n"))

                # Process only the unique files
                added = 0
                updated = 0
                errors = 0
                duplicates_within_processing = 0  # Track duplicates found during processing

                # Track which program numbers we've seen during processing
                seen_in_scan = {}  # program_number -> filepath
                gcode_files = files_to_process  # Use filtered list
                total_to_process = len(gcode_files)

                for idx, filepath in enumerate(gcode_files, 1):
                    if scan_cancelled[0]:
                        commit_with_retry(conn)
                        conn.close()
                        msg_queue.put(('text', f"\n\nScan cancelled after processing {idx-1} files.\n"))
                        msg_queue.put(('text', f"Added: {added}, Updated: {updated}, Errors: {errors}\n"))
                        msg_queue.put(('cancelled', None))
                        return

                    filename = os.path.basename(filepath)
                    msg_queue.put(('label', f"Processing {idx}/{total_to_process}: {filename}"))
                    msg_queue.put(('text', f"[{idx}/{total_to_process}] Processing: {filename}\n"))

                    try:
                        # Parse using local parser (thread-safe)
                        result = local_parser.parse_file(filepath)
                        if not result:
                            errors += 1
                            msg_queue.put(('text', f"  PARSE ERROR: Could not extract data\n"))
                            continue

                        # Determine validation status
                        validation_status = "PASS"
                        if result.validation_issues:
                            validation_status = "CRITICAL"
                        elif result.tool_home_status == "CRITICAL":
                            validation_status = "TOOL_HOME_CRITICAL"
                        elif result.bore_warnings:
                            validation_status = "BORE_WARNING"
                        elif result.tool_home_status == "WARNING":
                            validation_status = "TOOL_HOME_WARNING"
                        elif result.dimensional_issues:
                            validation_status = "DIMENSIONAL"
                        elif result.validation_warnings:
                            validation_status = "WARNING"

                        # Convert to ProgramRecord
                        record = ProgramRecord(
                            program_number=result.program_number,
                            title=result.title,
                            spacer_type=result.spacer_type,
                            outer_diameter=result.outer_diameter,
                            thickness=result.thickness,
                            thickness_display=result.thickness_display,
                            center_bore=result.center_bore,
                            hub_height=result.hub_height,
                            hub_diameter=result.hub_diameter,
                            counter_bore_diameter=result.counter_bore_diameter,
                            counter_bore_depth=result.counter_bore_depth,
                            paired_program=None,
                            material=result.material,
                            notes=None,
                            date_created=result.date_created,
                            last_modified=result.last_modified,
                            file_path=result.file_path,
                            detection_confidence=result.detection_confidence,
                            detection_method=result.detection_method,
                            validation_status=validation_status,
                            validation_issues=json.dumps(result.validation_issues) if result.validation_issues else None,
                            validation_warnings=json.dumps(result.validation_warnings) if result.validation_warnings else None,
                            bore_warnings=json.dumps(result.bore_warnings) if result.bore_warnings else None,
                            dimensional_issues=json.dumps(result.dimensional_issues) if result.dimensional_issues else None,
                            cb_from_gcode=result.cb_from_gcode,
                            ob_from_gcode=result.ob_from_gcode,
                            lathe=result.lathe,
                            tool_home_status=result.tool_home_status,
                            tool_home_issues=result.tool_home_issues
                        )
                    except Exception as e:
                        errors += 1
                        msg_queue.put(('text', f"  PARSE EXCEPTION: {str(e)[:100]}\n"))
                        continue

                    try:
                        # Check for duplicate in this scan and assign unique suffix
                        original_prog_num = record.program_number
                        if record.program_number in seen_in_scan:
                            # Find next available suffix
                            suffix = 1
                            while f"{original_prog_num}({suffix})" in seen_in_scan:
                                suffix += 1
                            record.program_number = f"{original_prog_num}({suffix})"
                            msg_queue.put(('text', f"  DUPLICATE: {original_prog_num} -> saved as {record.program_number}\n"))
                            duplicates_within_processing += 1

                        # Track this file with its (possibly modified) program number
                        seen_in_scan[record.program_number] = filepath

                        # Check if exists in database
                        cursor.execute("SELECT program_number FROM programs WHERE program_number = ?",
                                     (record.program_number,))
                        exists = cursor.fetchone()

                        if exists:
                            # Update existing
                            cursor.execute('''
                                UPDATE programs SET
                                    title = ?, spacer_type = ?, outer_diameter = ?, thickness = ?, thickness_display = ?,
                                    center_bore = ?, hub_height = ?, hub_diameter = ?,
                                    counter_bore_diameter = ?, counter_bore_depth = ?,
                                    material = ?, last_modified = ?, file_path = ?,
                                    detection_confidence = ?, detection_method = ?,
                                    validation_status = ?, validation_issues = ?,
                                    validation_warnings = ?, bore_warnings = ?, dimensional_issues = ?,
                                    cb_from_gcode = ?, ob_from_gcode = ?, lathe = ?,
                                    tool_home_status = ?, tool_home_issues = ?
                                WHERE program_number = ?
                            ''', (record.title, record.spacer_type, record.outer_diameter, record.thickness, record.thickness_display,
                                 record.center_bore, record.hub_height, record.hub_diameter,
                                 record.counter_bore_diameter, record.counter_bore_depth,
                                 record.material, record.last_modified, record.file_path,
                                 record.detection_confidence, record.detection_method,
                                 record.validation_status, record.validation_issues,
                                 record.validation_warnings, record.bore_warnings, record.dimensional_issues,
                                 record.cb_from_gcode, record.ob_from_gcode, record.lathe,
                                 record.tool_home_status,
                                 json.dumps(record.tool_home_issues) if record.tool_home_issues else None,
                                 record.program_number))
                            updated += 1
                        else:
                            # If user chose repository mode, import the file first
                            final_file_path = record.file_path
                            is_managed_file = 0

                            if add_to_repository and record.file_path and os.path.exists(record.file_path) and repository_path:
                                # Copy file to repository (inline to avoid calling self methods from thread)
                                try:
                                    prog_num = record.program_number.lower()
                                    if not prog_num.startswith('o'):
                                        prog_num = 'o' + prog_num
                                    new_filename = prog_num + '.nc'
                                    dest_path = os.path.join(repository_path, new_filename)
                                    if not os.path.exists(dest_path):
                                        shutil.copy2(record.file_path, dest_path)
                                        final_file_path = dest_path
                                        is_managed_file = 1
                                        msg_queue.put(('text', f"  → Imported to repository\n"))
                                except Exception as copy_err:
                                    msg_queue.put(('text', f"  → Import failed: {str(copy_err)[:50]}\n"))

                            # Insert new
                            cursor.execute('''
                                INSERT INTO programs VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                            ''', (record.program_number, record.title, record.spacer_type, record.outer_diameter,
                                 record.thickness, record.thickness_display, record.center_bore, record.hub_height,
                                 record.hub_diameter, record.counter_bore_diameter,
                                 record.counter_bore_depth, record.paired_program,
                                 record.material, record.notes, record.date_created,
                                 record.last_modified, final_file_path, record.detection_confidence,
                                 record.detection_method, record.validation_status,
                                 record.validation_issues, record.validation_warnings,
                                 record.cb_from_gcode, record.ob_from_gcode,
                                 record.bore_warnings, record.dimensional_issues, record.lathe,
                                 None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings (CREATE TABLE positions 28-30)
                                 None, None,  # crash_issues, crash_warnings (CREATE TABLE positions 31-32)
                                 datetime.now().isoformat(),  # date_imported (CREATE TABLE position 33)
                                 None, None, None,  # duplicate_type, parent_file, duplicate_group
                                 None, current_username, is_managed_file,  # current_version, modified_by, is_managed
                                 None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                                 None, None, None,  # legacy_names, last_renamed_date, rename_reason
                                 None, None, None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues, safety_blocks_status, safety_blocks_issues
                                 None,  # content_hash
                                 record.tool_home_status, json.dumps(record.tool_home_issues) if record.tool_home_issues else None,  # tool_home_status, tool_home_issues
                                 None, None,  # hub_height_display, counter_bore_depth_display
                                 0, None))  # is_deleted, deleted_date
                            added += 1

                    except Exception as e:
                        errors += 1
                        msg_queue.put(('text', f"  DATABASE ERROR: {str(e)[:100]}\n"))

                commit_with_retry(conn)
                conn.close()

                # Calculate total duplicates (both exact duplicates and name collisions)
                total_duplicates = len(exact_duplicates_db) + len(exact_duplicates_scan) + len(name_collisions_db) + len(name_collisions_scan)

                # Show results
                msg_queue.put(('label', "Complete!"))
                msg_queue.put(('text', f"\n{'='*50}\n"))
                msg_queue.put(('text', f"SCAN SUMMARY\n"))
                msg_queue.put(('text', f"{'='*50}\n"))
                msg_queue.put(('text', f"Total files scanned: {len(all_scanned_files)}\n"))
                msg_queue.put(('text', f"Files to process: {len(files_to_process)}\n"))
                msg_queue.put(('text', f"Duplicates skipped: {total_duplicates}\n"))
                msg_queue.put(('text', f"  - Exact match (DB): {len(exact_duplicates_db)}\n"))
                msg_queue.put(('text', f"  - Exact match (scan): {len(exact_duplicates_scan)}\n"))
                msg_queue.put(('text', f"  - Name collision (DB): {len(name_collisions_db)}\n"))
                msg_queue.put(('text', f"  - Name collision (scan): {len(name_collisions_scan)}\n"))
                msg_queue.put(('text', f"Added: {added}\n"))
                msg_queue.put(('text', f"Updated: {updated}\n"))
                msg_queue.put(('text', f"Errors: {errors}\n"))
                if duplicates_within_processing > 0:
                    msg_queue.put(('text', f"Program number conflicts (saved with suffix): {duplicates_within_processing}\n"))
                msg_queue.put(('text', f"Unique programs: {len(seen_in_scan)}\n"))

                msg_queue.put(('done', None))

            except Exception as e:
                logger.error(f"Scan thread error: {e}", exc_info=True)
                msg_queue.put(('text', f"\nERROR: {str(e)}\n"))
                msg_queue.put(('done', None))

        # Start the background thread
        thread = threading.Thread(target=scan_thread, daemon=True)
        thread.start()

        # Start GUI update loop
        update_gui()

    def process_new_files_workflow(self):
        """
        One-click workflow to process new files:
        1. Scan folder for new files
        2. Import to repository
        3. Detect round sizes
        4. Check for duplicates
        5. Resolve any suffix placeholders
        6. Sync filenames if needed
        7. Refresh display
        """
        from datetime import datetime
        import json

        # Select folder to scan
        folder = filedialog.askdirectory(
            title="Select Folder with New G-Code Files",
            initialdir=self.config.get("last_folder", "")
        )

        if not folder:
            return

        self.config["last_folder"] = folder
        self.save_config()

        # Create auto-backup before processing
        backup_path = self.create_auto_backup("process_new_files")
        if backup_path:
            logger.info("Auto-backup created before processing new files")

        # Create workflow window
        workflow_win = tk.Toplevel(self.root)
        workflow_win.title("Processing New Files")
        workflow_win.geometry("900x700")
        workflow_win.configure(bg=self.bg_color)
        workflow_win.transient(self.root)

        # Header
        tk.Label(workflow_win, text="⚡ Processing New Files Workflow",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=10)

        # Progress frame with steps
        steps_frame = tk.Frame(workflow_win, bg=self.bg_color)
        steps_frame.pack(fill=tk.X, padx=20, pady=10)

        steps = [
            "1. Scanning folder for G-code files",
            "2. Checking for duplicates",
            "3. Importing to repository",
            "4. Detecting round sizes",
            "5. Resolving suffix placeholders",
            "6. Syncing filenames",
            "7. Refreshing display"
        ]

        step_labels = []
        for step in steps:
            lbl = tk.Label(steps_frame, text=f"⏳ {step}",
                          bg=self.bg_color, fg="#888888",
                          font=("Arial", 10), anchor='w')
            lbl.pack(fill=tk.X, pady=2)
            step_labels.append(lbl)

        # Progress bar
        progress_var = tk.DoubleVar()
        progress_bar = ttk.Progressbar(workflow_win, variable=progress_var,
                                       maximum=100, length=800)
        progress_bar.pack(pady=10, padx=20)

        # Log text
        log_frame = tk.Frame(workflow_win, bg=self.bg_color)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        log_text = scrolledtext.ScrolledText(log_frame, bg=self.input_bg, fg=self.fg_color,
                                            font=("Consolas", 9), wrap=tk.WORD)
        log_text.pack(fill=tk.BOTH, expand=True)

        def log(message):
            try:
                if log_text.winfo_exists():
                    log_text.insert(tk.END, message + "\n")
                    log_text.see(tk.END)
                    workflow_win.update()
            except tk.TclError:
                # Widget was destroyed, ignore logging
                pass

        def update_step(step_idx, status='done'):
            """Update step status: 'done', 'active', 'error', 'skip'"""
            colors = {'done': '#4CAF50', 'active': '#2196F3', 'error': '#F44336', 'skip': '#FF9800'}
            icons = {'done': '✓', 'active': '▶', 'error': '✗', 'skip': '⏭'}
            step_labels[step_idx].config(
                text=f"{icons[status]} {steps[step_idx]}",
                fg=colors[status]
            )
            workflow_win.update()

        # Statistics
        stats = {
            'files_found': 0,
            'duplicates_skipped': 0,
            'files_imported': 0,
            'round_sizes_detected': 0,
            'suffixes_resolved': 0,
            'filenames_synced': 0,
            'errors': []
        }

        try:
            # Step 1: Scan folder
            update_step(0, 'active')
            log("=" * 60)
            log("STEP 1: Scanning folder for G-code files...")
            log("=" * 60)

            import glob
            import re

            # Standard G-code file extensions
            gcode_patterns = ['*.nc', '*.NC', '*.tap', '*.TAP', '*.txt', '*.TXT', '*.gcode']
            all_files = []
            for pattern in gcode_patterns:
                all_files.extend(glob.glob(os.path.join(folder, pattern)))
                all_files.extend(glob.glob(os.path.join(folder, '**', pattern), recursive=True))

            # Also find O-number files without extension (e.g., o13006, O57500)
            log(f"Checking for extensionless O-number files...")
            all_items = glob.glob(os.path.join(folder, '*'))
            all_items.extend(glob.glob(os.path.join(folder, '**', '*'), recursive=True))
            o_number_pattern = re.compile(r'^[oO]\d{4,}$')  # Matches o12345, O57600, etc. (no extension)
            extensionless_count = 0
            for item in all_items:
                if os.path.isfile(item):
                    basename = os.path.basename(item)
                    if o_number_pattern.match(basename):
                        all_files.append(item)
                        extensionless_count += 1
            log(f"Found {extensionless_count} extensionless O-number files")

            # Remove duplicates
            all_files = list(set(all_files))
            stats['files_found'] = len(all_files)
            log(f"Found {len(all_files)} total G-code files")
            progress_var.set(10)
            update_step(0, 'done')

            if not all_files:
                log("\nNo G-code files found in the selected folder.")
                update_step(1, 'skip')
                update_step(2, 'skip')
                update_step(3, 'skip')
                update_step(4, 'skip')
                update_step(5, 'skip')
                update_step(6, 'done')
                progress_var.set(100)
                return

            # Step 2: Check for duplicates
            update_step(1, 'active')
            log("\n" + "=" * 60)
            log("STEP 2: Checking for duplicates...")
            log("=" * 60)

            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            files_to_import = []
            for filepath in all_files:
                filename = os.path.basename(filepath)
                prog_num = os.path.splitext(filename)[0].lower()

                # Check if already in database
                cursor.execute("SELECT program_number FROM programs WHERE program_number = ?", (prog_num,))
                if cursor.fetchone():
                    stats['duplicates_skipped'] += 1
                    log(f"  Skip (exists): {filename}")
                else:
                    # Check content hash if we have it
                    file_hash = self.compute_file_hash(filepath)
                    cursor.execute("SELECT program_number FROM programs WHERE content_hash = ?", (file_hash,))
                    existing = cursor.fetchone()
                    if existing:
                        stats['duplicates_skipped'] += 1
                        log(f"  Skip (content match with {existing[0]}): {filename}")
                    else:
                        files_to_import.append(filepath)

            conn.close()
            log(f"\nFiles to import: {len(files_to_import)}")
            log(f"Duplicates skipped: {stats['duplicates_skipped']}")
            progress_var.set(25)
            update_step(1, 'done')

            if not files_to_import:
                log("\nNo new files to import.")
                update_step(2, 'skip')
                update_step(3, 'skip')
                update_step(4, 'skip')
                update_step(5, 'skip')
                update_step(6, 'done')
                progress_var.set(100)
                self.refresh_results()
                return

            # Step 3: Import to repository
            update_step(2, 'active')
            log("\n" + "=" * 60)
            log("STEP 3: Importing files to repository...")
            log("=" * 60)

            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            imported_programs = []
            for i, filepath in enumerate(files_to_import):
                try:
                    # Parse the file
                    record = self.parse_gcode_file(filepath)
                    if not record:
                        log(f"  Error parsing: {os.path.basename(filepath)}")
                        stats['errors'].append(f"Parse error: {os.path.basename(filepath)}")
                        continue

                    # Import to repository
                    imported_path = self.import_to_repository(filepath, record.program_number)
                    if imported_path:
                        record.file_path = imported_path
                        is_managed = 1
                    else:
                        is_managed = 0

                    # Compute hash
                    file_hash = self.compute_file_hash(record.file_path or filepath)

                    # Insert into database
                    # Convert tool_home_issues list to JSON
                    import json
                    tool_home_issues_json = json.dumps(record.tool_home_issues) if record.tool_home_issues else None

                    cursor.execute('''
                        INSERT OR REPLACE INTO programs VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (record.program_number, record.title, record.spacer_type, record.outer_diameter,
                         record.thickness, record.thickness_display, record.center_bore, record.hub_height,
                         record.hub_diameter, record.counter_bore_diameter,
                         record.counter_bore_depth, record.paired_program,
                         record.material, record.notes, record.date_created,
                         record.last_modified, record.file_path, record.detection_confidence,
                         record.detection_method, record.validation_status,
                         record.validation_issues, record.validation_warnings,
                         record.cb_from_gcode, record.ob_from_gcode,
                         record.bore_warnings, record.dimensional_issues, record.lathe,
                         None, None, None,  # duplicate_type, parent_file, duplicate_group
                         None, self.current_username, is_managed,  # current_version, modified_by, is_managed
                         None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                         None, None, None,  # legacy_names, last_renamed_date, rename_reason
                         None, None, None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues, safety_blocks_status, safety_blocks_issues
                         file_hash,  # content_hash
                         record.tool_home_status, tool_home_issues_json,  # tool_home_status, tool_home_issues
                         None, None,  # hub_height_display, counter_bore_depth_display
                         None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings
                         None, None,  # crash_issues, crash_warnings
                         datetime.now().isoformat(),  # date_imported
                         0, None))  # is_deleted, deleted_date

                    imported_programs.append((record.program_number, record.file_path))
                    stats['files_imported'] += 1
                    log(f"  Imported: {record.program_number} - {record.title or 'No title'}")

                except Exception as e:
                    log(f"  Error: {os.path.basename(filepath)} - {str(e)}")
                    stats['errors'].append(f"{os.path.basename(filepath)}: {str(e)}")

                # Update progress
                progress_var.set(25 + (i / len(files_to_import)) * 25)
                workflow_win.update()

            conn.commit()
            conn.close()

            # Batch sync registry for all imported programs (single connection)
            if imported_programs:
                log(f"\nSyncing registry for {len(imported_programs)} programs...")
                try:
                    from datetime import datetime
                    reg_conn = sqlite3.connect(self.db_path, timeout=30.0)
                    reg_cursor = reg_conn.cursor()
                    now = datetime.now().isoformat()
                    ranges = self.get_round_size_ranges()

                    for prog_num, file_path in imported_programs:
                        # Update or insert registry entry
                        reg_cursor.execute("""
                            UPDATE program_number_registry
                            SET status = 'IN_USE', file_path = ?, last_checked = ?
                            WHERE program_number = ?
                        """, (file_path, now, prog_num))

                        if reg_cursor.rowcount == 0:
                            try:
                                num = int(prog_num.replace('o', '').replace('O', ''))
                                round_size = None
                                range_start = range_end = 0
                                for rs, (start, end, _) in ranges.items():
                                    if start <= num <= end:
                                        round_size = rs
                                        range_start = start
                                        range_end = end
                                        break
                                reg_cursor.execute("""
                                    INSERT INTO program_number_registry
                                    (program_number, round_size, range_start, range_end, status, file_path, last_checked)
                                    VALUES (?, ?, ?, ?, 'IN_USE', ?, ?)
                                """, (prog_num, round_size, range_start, range_end, file_path, now))
                            except:
                                pass

                    reg_conn.commit()
                    reg_conn.close()
                    log("Registry sync complete")
                except Exception as e:
                    log(f"Registry sync error: {e}")

            log(f"\nImported {stats['files_imported']} files")
            progress_var.set(50)
            update_step(2, 'done')

            # Step 4: Detect round sizes (batched with single connection)
            update_step(3, 'active')
            log("\n" + "=" * 60)
            log("STEP 4: Detecting round sizes...")
            log("=" * 60)

            # Use single connection for all round size updates
            rs_conn = sqlite3.connect(self.db_path, timeout=30.0)
            rs_cursor = rs_conn.cursor()

            for prog_num, _ in imported_programs:
                try:
                    # detect_round_size returns tuple: (round_size, confidence, source)
                    round_size, confidence, source = self.detect_round_size(prog_num)
                    if round_size:
                        stats['round_sizes_detected'] += 1
                        log(f"  {prog_num}: {round_size}\" round ({confidence} from {source})")
                        # Update directly with existing connection
                        in_correct_range = 1 if self.is_in_correct_range(prog_num, round_size) else 0
                        rs_cursor.execute("""
                            UPDATE programs
                            SET round_size = ?, round_size_confidence = ?, round_size_source = ?, in_correct_range = ?
                            WHERE program_number = ?
                        """, (round_size, confidence, source, in_correct_range, prog_num))
                except Exception as e:
                    log(f"  {prog_num}: Error detecting round size - {e}")

            commit_with_retry(rs_conn)
            rs_conn.close()

            log(f"\nRound sizes detected: {stats['round_sizes_detected']} of {len(imported_programs)}")
            progress_var.set(65)
            update_step(3, 'done')

            # Step 5: Resolve suffix placeholders
            update_step(4, 'active')
            log("\n" + "=" * 60)
            log("STEP 5: Checking for suffix placeholders...")
            log("=" * 60)

            suffix_programs = self.find_suffix_programs()
            if suffix_programs:
                log(f"Found {len(suffix_programs)} programs with suffixes")
                resolve_stats = self.resolve_all_suffix_programs(dry_run=False)
                stats['suffixes_resolved'] = resolve_stats['resolved']
                log(f"Resolved: {resolve_stats['resolved']}")
                if resolve_stats['errors']:
                    for err in resolve_stats['errors'][:5]:
                        log(f"  Error: {err['program']} - {err['error']}")
            else:
                log("No suffix placeholders found")

            progress_var.set(80)
            update_step(4, 'done')

            # Step 6: Sync filenames (check only, don't auto-sync)
            update_step(5, 'active')
            log("\n" + "=" * 60)
            log("STEP 6: Checking filename sync status...")
            log("=" * 60)

            # Check for mismatches
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT program_number, file_path FROM programs
                WHERE is_managed = 1 AND file_path IS NOT NULL
            """)

            mismatches = 0
            for prog_num, file_path in cursor.fetchall():
                if prog_num and file_path and os.path.exists(file_path):
                    filename = os.path.splitext(os.path.basename(file_path))[0].lower()
                    if filename != prog_num.lower():
                        mismatches += 1

            conn.close()

            if mismatches > 0:
                log(f"Found {mismatches} filename mismatches")
                log("Use 'Sync Filenames' button to fix these")
            else:
                log("All filenames are in sync")

            progress_var.set(90)
            update_step(5, 'done')

            # Step 7: Refresh display
            update_step(6, 'active')
            log("\n" + "=" * 60)
            log("STEP 7: Refreshing display...")
            log("=" * 60)

            self.refresh_filter_values()
            self.refresh_results()

            progress_var.set(100)
            update_step(6, 'done')

            # Summary
            log("\n" + "=" * 60)
            log("WORKFLOW COMPLETE")
            log("=" * 60)
            log(f"Files found: {stats['files_found']}")
            log(f"Duplicates skipped: {stats['duplicates_skipped']}")
            log(f"Files imported: {stats['files_imported']}")
            log(f"Round sizes detected: {stats['round_sizes_detected']}")
            log(f"Suffixes resolved: {stats['suffixes_resolved']}")
            if stats['errors']:
                log(f"Errors: {len(stats['errors'])}")
            log("\nDone!")

        except Exception as e:
            log(f"\nERROR: {str(e)}")
            import traceback
            log(traceback.format_exc())

        # Close button - check if window still exists
        if workflow_win.winfo_exists():
            tk.Button(workflow_win, text="Close", command=workflow_win.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold"), width=15).pack(pady=10)

    def scan_for_new_files(self):
        """Scan a folder for gcode files and import only NEW files not already in database"""
        folder = filedialog.askdirectory(title="Select Folder to Scan for New Files",
                                        initialdir=self.config.get("last_folder", ""))

        if not folder:
            return

        self.config["last_folder"] = folder
        self.save_config()

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Scanning for New Files...")
        progress_window.geometry("600x400")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Scanning...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 width=70, height=15)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get all existing files from database (filename and content hash)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Scan for gcode files (with or without extension)
        gcode_files = []

        # Scan for new files is always in external mode (not adding to repository)
        # Check for duplicates to avoid re-importing existing files
        if True:  # External mode
            cursor.execute("SELECT file_path FROM programs WHERE file_path IS NOT NULL AND (is_deleted IS NULL OR is_deleted = 0)")
            existing_files_data = {}  # {filename_lower: [file_paths]}

            # PERFORMANCE FIX: Don't check os.path.exists() for every file
            # This was very slow on network drives (Google Drive). Instead, trust
            # the database and only verify existence when we need to compare content.
            for row in cursor.fetchall():
                file_path = row[0]
                if file_path:
                    basename = os.path.basename(file_path).lower()
                    if basename not in existing_files_data:
                        existing_files_data[basename] = []
                    existing_files_data[basename].append(file_path)

            name_collisions = []  # Files with same name but need content check

            for root, dirs, files in os.walk(folder):
                for file in files:
                    # Match any file containing o##### pattern (4+ digits)
                    if re.search(r'[oO]\d{4,}', file):
                        filepath = os.path.join(root, file)
                        basename_lower = file.lower()

                        # Check if filename exists in database
                        if basename_lower in existing_files_data:
                            # Need to check content to see if it's exact duplicate
                            name_collisions.append((filepath, existing_files_data[basename_lower]))
                        else:
                            # New filename, safe to add
                            gcode_files.append(filepath)

            # Check name collisions for exact duplicates vs different content
            # Use file size + hash comparison for better performance
            exact_duplicates = []
            different_content = []

            import hashlib

            def calculate_file_hash(filepath):
                """Calculate SHA256 hash of a file efficiently"""
                sha256_hash = hashlib.sha256()
                try:
                    with open(filepath, 'rb') as f:
                        # Read in 4KB chunks to handle large files
                        for byte_block in iter(lambda: f.read(4096), b""):
                            sha256_hash.update(byte_block)
                    return sha256_hash.hexdigest()
                except:
                    return None

            for new_file, existing_paths in name_collisions:
                try:
                    # Step 1: Quick file size check
                    new_size = os.path.getsize(new_file)

                    # Compare with existing file(s) - filter to only existing files
                    is_exact_match = False
                    valid_existing_paths = [p for p in existing_paths if os.path.exists(p)]

                    if not valid_existing_paths:
                        # Database has this filename but file doesn't exist - treat as new
                        gcode_files.append(new_file)
                        continue

                    for existing_path in valid_existing_paths:
                        try:
                            existing_size = os.path.getsize(existing_path)

                            # If sizes are different, definitely different files
                            if new_size != existing_size:
                                continue

                            # Step 2: Sizes match - calculate hashes for accurate comparison
                            new_hash = calculate_file_hash(new_file)
                            existing_hash = calculate_file_hash(existing_path)

                            if new_hash and existing_hash and new_hash == existing_hash:
                                is_exact_match = True
                                break
                        except:
                            continue

                    if is_exact_match:
                        exact_duplicates.append(new_file)
                    else:
                        different_content.append((new_file, valid_existing_paths[0]))
                except:
                    # If can't read, treat as different content (to be safe)
                    if existing_paths:
                        different_content.append((new_file, existing_paths[0]))

            progress_label.config(text=f"Analyzing files...")
            progress_text.insert(tk.END, f"Total files scanned: {len(gcode_files) + len(name_collisions)}\n")
            progress_text.insert(tk.END, f"New files (unique names): {len(gcode_files)}\n")
            progress_text.insert(tk.END, f"Exact duplicates (ignored): {len(exact_duplicates)}\n")
            progress_text.insert(tk.END, f"Name collisions (different content): {len(different_content)}\n\n")

            # Show exact duplicates being skipped
            if exact_duplicates:
                progress_text.insert(tk.END, f"=== SKIPPING EXACT DUPLICATES ===\n")
                for dup_file in exact_duplicates[:10]:
                    progress_text.insert(tk.END, f"  SKIP: {os.path.basename(dup_file)} (exact match already in database)\n")
                if len(exact_duplicates) > 10:
                    progress_text.insert(tk.END, f"  ... and {len(exact_duplicates) - 10} more\n")
                progress_text.insert(tk.END, f"\n")

            # Warn about name collisions
            if different_content:
                progress_text.insert(tk.END, f"⚠️  WARNING - NAME COLLISIONS DETECTED ===\n")
                progress_text.insert(tk.END, f"The following files have the same name as files in the database\n")
                progress_text.insert(tk.END, f"but DIFFERENT CONTENT. You must rename them before adding!\n\n")
                for new_file, existing_file in different_content[:10]:
                    progress_text.insert(tk.END, f"  ⚠️  {os.path.basename(new_file)}\n")
                    progress_text.insert(tk.END, f"     New: {new_file}\n")
                    progress_text.insert(tk.END, f"     Existing: {existing_file}\n\n")
                if len(different_content) > 10:
                    progress_text.insert(tk.END, f"  ... and {len(different_content) - 10} more\n")
                progress_text.insert(tk.END, f"\nPlease rename these files and scan again.\n\n")
        else:
            # Repository mode - skip duplicate checking, just add all files
            progress_text.insert(tk.END, "Repository mode: Skipping duplicate checks for faster import...\n\n")
            for root, dirs, files in os.walk(folder):
                for file in files:
                    # Match any file containing o##### pattern (4+ digits)
                    if re.search(r'[oO]\d{4,}', file):
                        filepath = os.path.join(root, file)
                        gcode_files.append(filepath)

        progress_text.insert(tk.END, f"Processing {len(gcode_files)} new files...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        if len(gcode_files) == 0:
            progress_label.config(text="No new files found!")
            close_btn = tk.Button(progress_window, text="Close",
                                 command=progress_window.destroy,
                                 bg=self.button_bg, fg=self.fg_color,
                                 font=("Arial", 10, "bold"))
            close_btn.pack(pady=10)
            conn.close()  # Close the database connection
            return

        # Process files
        added = 0
        errors = 0
        duplicates = 0
        duplicates_within_processing = 0  # Track duplicates found during processing

        # Track which program numbers we've seen in this scan
        seen_in_scan = {}  # program_number -> filepath

        for idx, filepath in enumerate(gcode_files, 1):
            filename = os.path.basename(filepath)

            # Check file size
            try:
                file_size = os.path.getsize(filepath)
                size_kb = file_size / 1024
            except:
                size_kb = 0

            # Update UI only every 10 files or on first/last file for better performance
            update_ui = (idx % 10 == 0) or (idx == 1) or (idx == len(gcode_files))

            if update_ui:
                progress_label.config(text=f"Processing {idx}/{len(gcode_files)}: {filename}")

            progress_text.insert(tk.END, f"[{idx}/{len(gcode_files)}] Processing: {filename} ({size_kb:.1f} KB)\n")

            try:
                record = self.parse_gcode_file(filepath)
            except Exception as e:
                errors += 1
                progress_text.insert(tk.END, f"  PARSE EXCEPTION: {str(e)[:100]}\n")
                if update_ui:
                    progress_text.see(tk.END)
                    self.root.update()
                continue

            if record:
                try:
                    # Check for duplicate in this scan and assign unique suffix
                    original_prog_num = record.program_number
                    if record.program_number in seen_in_scan:
                        # Find next available suffix
                        suffix = 1
                        while f"{original_prog_num}({suffix})" in seen_in_scan:
                            suffix += 1
                        record.program_number = f"{original_prog_num}({suffix})"
                        progress_text.insert(tk.END, f"  DUPLICATE: {original_prog_num} -> saved as {record.program_number}\n")
                        duplicates_within_processing += 1

                    # Track this file with its (possibly modified) program number
                    seen_in_scan[record.program_number] = filepath

                    # Insert new record
                    cursor.execute('''
                        INSERT INTO programs (
                            program_number, title, spacer_type, outer_diameter, thickness, thickness_display,
                            center_bore, hub_height, hub_diameter,
                            counter_bore_diameter, counter_bore_depth,
                            paired_program, material, notes, date_created, last_modified, file_path,
                            detection_confidence, detection_method,
                            validation_status, validation_issues,
                            validation_warnings, bore_warnings, dimensional_issues,
                            cb_from_gcode, ob_from_gcode, lathe,
                            duplicate_type, parent_file, duplicate_group,
                            current_version, modified_by, is_managed,
                            round_size, round_size_confidence, round_size_source, in_correct_range,
                            legacy_names, last_renamed_date, rename_reason,
                            tools_used, tool_sequence, tool_validation_status, tool_validation_issues,
                            safety_blocks_status, safety_blocks_issues, content_hash,
                            tool_home_status, tool_home_issues, hub_height_display, counter_bore_depth_display,
                            feasibility_status, feasibility_issues, feasibility_warnings,
                            crash_issues, crash_warnings, date_imported,
                            is_deleted, deleted_date
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        record.program_number,
                        record.title,
                        record.spacer_type,
                        record.outer_diameter,
                        record.thickness,
                        record.thickness_display,
                        record.center_bore,
                        record.hub_height,
                        record.hub_diameter,
                        record.counter_bore_diameter,
                        record.counter_bore_depth,
                        record.paired_program,
                        record.material,
                        record.notes,
                        datetime.now().isoformat(),
                        datetime.now().isoformat(),
                        filepath,
                        record.detection_confidence,
                        record.detection_method,
                        record.validation_status,
                        record.validation_issues,
                        record.validation_warnings,
                        record.bore_warnings,
                        record.dimensional_issues,
                        record.cb_from_gcode,
                        record.ob_from_gcode,
                        record.lathe,
                        None,  # duplicate_type
                        None,  # parent_file
                        None,  # duplicate_group
                        None, None, None,  # current_version, modified_by, is_managed
                        None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                        None, None, None,  # legacy_names, last_renamed_date, rename_reason
                        None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues
                        None, None,  # safety_blocks_status, safety_blocks_issues
                        None,  # content_hash
                        None, None,  # tool_home_status, tool_home_issues
                        None, None,  # hub_height_display, counter_bore_depth_display
                        None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings
                        None, None,  # crash_issues, crash_warnings
                        datetime.now().isoformat(),  # date_imported
                        0, None  # is_deleted, deleted_date
                    ))
                    added += 1
                    progress_text.insert(tk.END, f"  ADDED: {record.program_number}\n")

                    # Batch commit every 100 files for much better performance
                    if added % 100 == 0:
                        commit_with_retry(conn)
                        progress_text.insert(tk.END, f"\n[Database] Committed {added} files...\n\n")

                    # Update UI every 10 files for better performance
                    if update_ui:
                        progress_text.see(tk.END)
                        self.root.update()
                except sqlite3.Error as e:
                    errors += 1
                    progress_text.insert(tk.END, f"  DATABASE ERROR: {str(e)[:100]}\n")
                    if update_ui:
                        progress_text.see(tk.END)
                        self.root.update()
            else:
                errors += 1
                progress_text.insert(tk.END, f"  PARSE ERROR: Could not extract data\n")
                if update_ui:
                    progress_text.see(tk.END)
                    self.root.update()

        # Final commit for remaining files
        commit_with_retry(conn)
        conn.close()

        # Show results
        progress_label.config(text="Complete!")
        progress_text.insert(tk.END, f"\n{'='*50}\n")
        progress_text.insert(tk.END, f"New files found: {len(gcode_files)}\n")
        progress_text.insert(tk.END, f"Duplicates: {duplicates}\n")
        if duplicates_within_processing > 0:
            progress_text.insert(tk.END, f"Program number conflicts (saved with suffix): {duplicates_within_processing}\n")
        progress_text.insert(tk.END, f"Added: {added}\n")
        progress_text.insert(tk.END, f"Errors: {errors}\n")
        progress_text.see(tk.END)

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        # Refresh filter dropdowns with new values
        self.refresh_filter_values()
        self.refresh_results()

    def _predict_dimension_fallback(self, fallback_extractor, dimension, parse_result, program_number):
        """Helper method to predict a single dimension using secondary fallback"""
        try:
            import numpy as np

            # Extract features from title
            title = parse_result.title if parse_result.title else ""
            features = fallback_extractor.extract_title_features(title)

            # Add G-code features
            features['cb_from_gcode'] = parse_result.cb_from_gcode if parse_result.cb_from_gcode else 0
            features['ob_from_gcode'] = parse_result.ob_from_gcode if parse_result.ob_from_gcode else 0

            # Add known dimensions for cross-prediction
            features['known_od'] = parse_result.outer_diameter if (dimension != 'outer_diameter' and parse_result.outer_diameter) else 0
            features['known_cb'] = parse_result.center_bore if (dimension != 'center_bore' and parse_result.center_bore) else 0
            features['known_thickness'] = parse_result.thickness if (dimension != 'thickness' and parse_result.thickness) else 0

            # Create feature vector matching training
            feature_vector = [features.get(fn, 0) for fn in fallback_extractor.feature_names]
            feature_vector = np.array(feature_vector).reshape(1, -1)

            # Predict
            model = fallback_extractor.models.get(dimension)
            if model:
                prediction = model.predict(feature_vector)[0]
                return prediction
            return None
        except Exception as e:
            return None

    def rescan_database(self):
        """Re-parse all files already in database to refresh with latest parser improvements"""
        # Create custom dialog with secondary fallback option
        dialog = tk.Toplevel(self.root)
        dialog.title("Rescan Database")
        dialog.geometry("500x300")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Center the dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (500 // 2)
        y = (dialog.winfo_screenheight() // 2) - (300 // 2)
        dialog.geometry(f"500x300+{x}+{y}")

        # Message
        msg_frame = tk.Frame(dialog, bg=self.bg_color)
        msg_frame.pack(pady=20, padx=20, fill=tk.BOTH, expand=True)

        msg_label = tk.Label(msg_frame,
                            text="This will re-parse ALL files in the database to refresh their data.\n\n"
                                 "This is useful after parser improvements.\n\n"
                                 "Files will be re-analyzed but NOT moved or renamed.",
                            bg=self.bg_color, fg=self.fg_color,
                            font=("Arial", 10),
                            justify=tk.LEFT,
                            wraplength=450)
        msg_label.pack(anchor='w')

        # Secondary fallback checkbox
        use_fallback_var = tk.BooleanVar(value=False)  # Default to OFF for speed

        fallback_frame = tk.Frame(dialog, bg=self.bg_color)
        fallback_frame.pack(pady=10, padx=20, fill=tk.X)

        fallback_check = tk.Checkbutton(fallback_frame,
                                 text="Use secondary fallback for missing dimensions",
                                 variable=use_fallback_var,
                                 bg=self.bg_color, fg=self.fg_color,
                                 selectcolor=self.input_bg,
                                 activebackground=self.bg_color,
                                 activeforeground=self.fg_color,
                                 font=("Arial", 10, "bold"),
                                 cursor='hand2')
        fallback_check.pack(anchor='w')

        fallback_note = tk.Label(fallback_frame,
                          text="(Slower but fills all missing dimensions automatically)",
                          bg=self.bg_color, fg=self.fg_color,
                          font=("Arial", 8, "italic"),
                          justify=tk.LEFT)
        fallback_note.pack(anchor='w', padx=25)

        # Buttons
        button_frame = tk.Frame(dialog, bg=self.bg_color)
        button_frame.pack(pady=20)

        result = {'proceed': False, 'use_fallback': False}

        def on_proceed():
            result['proceed'] = True
            result['use_fallback'] = use_fallback_var.get()
            dialog.destroy()

        def on_cancel():
            result['proceed'] = False
            dialog.destroy()

        proceed_btn = tk.Button(button_frame, text="Proceed",
                               command=on_proceed,
                               bg=self.button_bg, fg=self.fg_color,
                               font=("Arial", 10, "bold"),
                               width=15, height=2)
        proceed_btn.pack(side=tk.LEFT, padx=10)

        cancel_btn = tk.Button(button_frame, text="Cancel",
                              command=on_cancel,
                              bg=self.bg_color, fg=self.fg_color,
                              font=("Arial", 10),
                              width=15, height=2)
        cancel_btn.pack(side=tk.LEFT, padx=10)

        # Wait for dialog to close
        self.root.wait_window(dialog)

        if not result['proceed']:
            return

        use_secondary_fallback = result['use_fallback']

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Rescanning Database...")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Rescanning files...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 9),
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get all files from database (exclude soft-deleted records)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT program_number, file_path FROM programs WHERE file_path IS NOT NULL AND (is_deleted IS NULL OR is_deleted = 0)")
        all_files = cursor.fetchall()

        total_files = len(all_files)
        progress_text.insert(tk.END, f"Found {total_files} files in database\n")
        progress_text.insert(tk.END, f"Starting re-scan...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        # Import parser
        from improved_gcode_parser import ImprovedGCodeParser
        parser = ImprovedGCodeParser()

        # Try to initialize secondary fallback (only if user enabled it)
        fallback_extractor = None
        fallback_available = False
        if use_secondary_fallback:
            try:
                from analysis_tools.ml_dimension_extractor import MLDimensionExtractor
                fallback_extractor = MLDimensionExtractor(self.db_path)
                if fallback_extractor.load_models():
                    fallback_available = True
                    progress_text.insert(tk.END, "[Secondary Fallback] Loaded models for missing dimensions\n\n")
                else:
                    progress_text.insert(tk.END, "[Secondary Fallback] Training models...\n")
                    fallback_extractor.load_data()
                    fallback_extractor.train_all_models()
                    fallback_extractor.save_models()
                    fallback_available = True
                    progress_text.insert(tk.END, "[Secondary Fallback] Models trained successfully\n\n")
                progress_text.see(tk.END)
                self.root.update()
            except ImportError:
                progress_text.insert(tk.END, "[Secondary Fallback] Libraries not installed - skipping predictions\n")
                progress_text.insert(tk.END, "              Install with: pip install pandas scikit-learn numpy\n\n")
                progress_text.see(tk.END)
                self.root.update()
            except Exception as e:
                progress_text.insert(tk.END, f"[Secondary Fallback] Error initializing: {str(e)[:80]}\n\n")
                progress_text.see(tk.END)
                self.root.update()
        else:
            progress_text.insert(tk.END, "Secondary Fallback disabled (for faster scanning)\n\n")
            progress_text.see(tk.END)
            self.root.update()

        updated = 0
        skipped = 0
        errors = 0
        fallback_predictions = 0

        for idx, (prog_num, file_path) in enumerate(all_files, 1):
            filename = os.path.basename(file_path)

            # Update progress
            if idx % 50 == 0 or idx == total_files:
                progress_label.config(text=f"Rescanning... {idx}/{total_files} files")
                self.root.update()

            # Check if file exists
            if not os.path.exists(file_path):
                skipped += 1
                if idx <= 10 or idx % 100 == 0:  # Show first 10 and every 100th
                    progress_text.insert(tk.END, f"[{idx}/{total_files}] {filename} - SKIP (file not found)\n")
                    progress_text.see(tk.END)
                    self.root.update()
                continue

            # Parse the file
            try:
                parse_result = parser.parse_file(file_path)

                if not parse_result:
                    errors += 1
                    if idx <= 10 or idx % 100 == 0:
                        progress_text.insert(tk.END, f"[{idx}/{total_files}] {filename} - ERROR (parse failed)\n")
                        progress_text.see(tk.END)
                        self.root.update()
                    continue

                # Apply secondary fallback for missing dimensions
                if fallback_available and fallback_extractor:
                    # Check and predict Outer Diameter
                    if not parse_result.outer_diameter:
                        fallback_od = self._predict_dimension_fallback(fallback_extractor, 'outer_diameter', parse_result, prog_num)
                        if fallback_od:
                            parse_result.outer_diameter = fallback_od
                            if parse_result.detection_confidence != 'SECONDARY_FALLBACK':
                                parse_result.detection_confidence = 'SECONDARY_FALLBACK'
                            parse_result.detection_notes.append(f'OD from secondary: {fallback_od:.2f}"')
                            fallback_predictions += 1

                    # Check and predict Thickness
                    if not parse_result.thickness:
                        fallback_thickness = self._predict_dimension_fallback(fallback_extractor, 'thickness', parse_result, prog_num)
                        if fallback_thickness:
                            parse_result.thickness = fallback_thickness
                            if parse_result.detection_confidence != 'SECONDARY_FALLBACK':
                                parse_result.detection_confidence = 'SECONDARY_FALLBACK'
                            parse_result.detection_notes.append(f'Thickness from secondary: {fallback_thickness:.3f}"')
                            fallback_predictions += 1

                    # Check and predict Center Bore
                    if not parse_result.center_bore:
                        fallback_cb = self._predict_dimension_fallback(fallback_extractor, 'center_bore', parse_result, prog_num)
                        if fallback_cb:
                            parse_result.center_bore = fallback_cb
                            if parse_result.detection_confidence != 'SECONDARY_FALLBACK':
                                parse_result.detection_confidence = 'SECONDARY_FALLBACK'
                            parse_result.detection_notes.append(f'CB from secondary: {fallback_cb:.1f}mm')
                            fallback_predictions += 1

                # Calculate validation status (prioritized by severity)
                # NOTE: Safety and tool validation disabled for now - too many false positives
                validation_status = "PASS"
                if parse_result.crash_issues:
                    validation_status = "CRASH_RISK"  # BRIGHT RED - Crash risk detected
                elif parse_result.validation_issues:
                    validation_status = "CRITICAL"  # RED - Critical errors
                elif parse_result.tool_home_status == "CRITICAL":
                    validation_status = "TOOL_HOME_CRITICAL"  # DARK RED - G53 Z-16 or beyond (dangerous)
                # elif parse_result.safety_blocks_status == "MISSING":
                #     validation_status = "SAFETY_ERROR"  # DARK RED - Missing safety blocks (DISABLED - too strict)
                # elif parse_result.tool_validation_status == "ERROR":
                #     validation_status = "TOOL_ERROR"  # ORANGE-RED - Wrong/missing tools (DISABLED - needs tuning)
                elif parse_result.crash_warnings:
                    validation_status = "CRASH_WARNING"  # ORANGE - Crash warnings
                elif parse_result.bore_warnings:
                    validation_status = "BORE_WARNING"  # ORANGE - Bore dimension warnings
                elif parse_result.tool_home_status == "WARNING":
                    validation_status = "TOOL_HOME_WARNING"  # AMBER - G53 Z doesn't match thickness
                elif parse_result.dimensional_issues:
                    validation_status = "DIMENSIONAL"  # PURPLE - P-code/thickness mismatches
                # elif parse_result.tool_validation_status == "WARNING":
                #     validation_status = "TOOL_WARNING"  # AMBER - Tool suggestions (DISABLED - needs tuning)
                elif parse_result.validation_warnings:
                    validation_status = "WARNING"  # YELLOW - General warnings

                # Update database with refreshed data
                # Note: paired_program not updated (not in parser result)
                notes = '|'.join(parse_result.detection_notes) if parse_result.detection_notes else None

                cursor.execute("""
                    UPDATE programs
                    SET title = ?,
                        spacer_type = ?,
                        outer_diameter = ?,
                        thickness = ?,
                        thickness_display = ?,
                        center_bore = ?,
                        hub_height = ?,
                        hub_diameter = ?,
                        counter_bore_diameter = ?,
                        counter_bore_depth = ?,
                        material = ?,
                        detection_confidence = ?,
                        detection_method = ?,
                        validation_status = ?,
                        validation_issues = ?,
                        validation_warnings = ?,
                        cb_from_gcode = ?,
                        ob_from_gcode = ?,
                        bore_warnings = ?,
                        dimensional_issues = ?,
                        lathe = ?,
                        notes = ?,
                        tools_used = ?,
                        tool_sequence = ?,
                        tool_validation_status = ?,
                        tool_validation_issues = ?,
                        safety_blocks_status = ?,
                        safety_blocks_issues = ?,
                        tool_home_status = ?,
                        tool_home_issues = ?,
                        crash_issues = ?,
                        crash_warnings = ?
                    WHERE program_number = ?
                """, (
                    parse_result.title,
                    parse_result.spacer_type,
                    parse_result.outer_diameter,
                    parse_result.thickness,
                    parse_result.thickness_display,
                    parse_result.center_bore,
                    parse_result.hub_height,
                    parse_result.hub_diameter,
                    parse_result.counter_bore_diameter,
                    parse_result.counter_bore_depth,
                    parse_result.material,
                    parse_result.detection_confidence,
                    parse_result.detection_method,
                    validation_status,
                    '|'.join(parse_result.validation_issues) if parse_result.validation_issues else None,
                    '|'.join(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                    parse_result.cb_from_gcode,
                    parse_result.ob_from_gcode,
                    '|'.join(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                    '|'.join(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                    parse_result.lathe,
                    notes,
                    json.dumps(parse_result.tools_used) if parse_result.tools_used else None,
                    json.dumps(parse_result.tool_sequence) if parse_result.tool_sequence else None,
                    None,  # tool_validation_status - DISABLED
                    None,  # tool_validation_issues - DISABLED
                    None,  # safety_blocks_status - DISABLED
                    None,  # safety_blocks_issues - DISABLED
                    parse_result.tool_home_status,
                    json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                    json.dumps(parse_result.crash_issues) if parse_result.crash_issues else None,
                    json.dumps(parse_result.crash_warnings) if parse_result.crash_warnings else None,
                    prog_num
                ))

                updated += 1

                # Show first 10, then every 100th, and last 10
                if idx <= 10 or idx % 100 == 0 or idx > total_files - 10:
                    progress_text.insert(tk.END, f"[{idx}/{total_files}] {filename} - OK Updated\n")
                    progress_text.see(tk.END)
                    self.root.update()

            except Exception as e:
                errors += 1
                if idx <= 10 or idx % 100 == 0:
                    progress_text.insert(tk.END, f"[{idx}/{total_files}] {filename} - ERROR: {str(e)}\n")
                    progress_text.see(tk.END)
                    self.root.update()

        # Commit all changes
        conn.commit()
        conn.close()

        # Summary
        progress_label.config(text="Rescan Complete!")
        progress_text.insert(tk.END, f"\n{'='*60}\n")
        progress_text.insert(tk.END, f"RESCAN COMPLETE\n")
        progress_text.insert(tk.END, f"{'='*60}\n")
        progress_text.insert(tk.END, f"Total files: {total_files}\n")
        progress_text.insert(tk.END, f"Updated: {updated}\n")
        progress_text.insert(tk.END, f"Skipped (not found): {skipped}\n")
        if fallback_available and fallback_predictions > 0:
            progress_text.insert(tk.END, f"\n[Secondary Fallback] {fallback_predictions} dimensions predicted\n")
            progress_text.insert(tk.END, f"              (Programs marked as 'SECONDARY_FALLBACK')\n")
        progress_text.insert(tk.END, f"Errors: {errors}\n")
        progress_text.see(tk.END)

        # Close button — also opens details for the selected program so the
        # user can immediately see the updated validation results
        def _close_rescan():
            progress_window.destroy()
            if self.tree.selection():
                self.view_details()

        close_btn = tk.Button(progress_window, text="Close",
                             command=_close_rescan,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        # Refresh the display
        self.refresh_results()

    def rescan_changed_files(self):
        """Re-scan only files that have been modified since last database update"""
        # Confirmation dialog
        if not messagebox.askyesno("Rescan Changed Files",
                                   "This will re-parse only files that have been modified\n"
                                   "since their last database update.\n\n"
                                   "This is much faster than full rescan.\n\n"
                                   "Continue?"):
            return

        # Create backup first
        if not self.backup_database():
            messagebox.showerror("Backup Failed", "Could not create backup before rescan.\nOperation cancelled.")
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Rescanning Changed Files...")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Checking for modified files...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 9),
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get all files from database with last_modified timestamps (exclude soft-deleted records)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT program_number, file_path, last_modified FROM programs WHERE file_path IS NOT NULL AND (is_deleted IS NULL OR is_deleted = 0)")
        all_files = cursor.fetchall()

        total_files = len(all_files)
        progress_text.insert(tk.END, f"Checking {total_files} files for modifications...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        # Import parser
        from improved_gcode_parser import ImprovedGCodeParser
        parser = ImprovedGCodeParser()

        updated = 0
        skipped = 0
        errors = 0
        not_found = 0
        modified_files = []

        # First pass: identify modified files
        for idx, (prog_num, file_path, db_modified) in enumerate(all_files, 1):
            if idx % 100 == 0:
                progress_label.config(text=f"Checking... {idx}/{total_files} files")
                self.root.update()

            # Check if file exists
            if not os.path.exists(file_path):
                not_found += 1
                continue

            # Get file modification time
            try:
                file_mtime = datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat()

                # Compare timestamps - only re-parse if file is newer than DB record
                if db_modified is None or file_mtime > db_modified:
                    modified_files.append((prog_num, file_path))
            except Exception as e:
                errors += 1
                continue

        # Report findings
        progress_text.insert(tk.END, f"Found {len(modified_files)} modified files (out of {total_files} total)\n")
        if not_found > 0:
            progress_text.insert(tk.END, f"  {not_found} files not found (skipped)\n")
        progress_text.insert(tk.END, f"\n")

        if len(modified_files) == 0:
            progress_text.insert(tk.END, "OK All files are up to date!\n")
            progress_label.config(text="No changes detected")
        else:
            progress_text.insert(tk.END, f"Re-parsing {len(modified_files)} modified files...\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Second pass: re-parse modified files
            for idx, (prog_num, file_path) in enumerate(modified_files, 1):
                filename = os.path.basename(file_path)

                # Update progress
                if idx % 10 == 0 or idx == len(modified_files):
                    progress_label.config(text=f"Updating... {idx}/{len(modified_files)} modified files")
                    self.root.update()

                # Parse the file
                try:
                    parse_result = parser.parse_file(file_path)

                    if not parse_result:
                        errors += 1
                        if idx <= 5 or idx % 50 == 0:
                            progress_text.insert(tk.END, f"[{idx}/{len(modified_files)}] {filename} - ERROR (parse failed)\n")
                            progress_text.see(tk.END)
                            self.root.update()
                        continue

                    # Calculate validation status
                    # NOTE: Safety and tool validation disabled for now - too many false positives
                    validation_status = "PASS"
                    if parse_result.crash_issues:
                        validation_status = "CRASH_RISK"  # BRIGHT RED - Crash risk detected
                    elif parse_result.validation_issues:
                        validation_status = "CRITICAL"
                    elif parse_result.tool_home_status == "CRITICAL":
                        validation_status = "TOOL_HOME_CRITICAL"  # G53 Z-16 or beyond (dangerous)
                    # elif parse_result.safety_blocks_status == "MISSING":
                    #     validation_status = "SAFETY_ERROR"  # DISABLED - too strict
                    # elif parse_result.tool_validation_status == "ERROR":
                    #     validation_status = "TOOL_ERROR"  # DISABLED - needs tuning
                    elif parse_result.crash_warnings:
                        validation_status = "CRASH_WARNING"  # ORANGE - Crash warnings
                    elif parse_result.bore_warnings:
                        validation_status = "BORE_WARNING"
                    elif parse_result.tool_home_status == "WARNING":
                        validation_status = "TOOL_HOME_WARNING"  # G53 Z doesn't match thickness
                    elif parse_result.dimensional_issues:
                        validation_status = "DIMENSIONAL"
                    # elif parse_result.tool_validation_status == "WARNING":
                    #     validation_status = "TOOL_WARNING"  # DISABLED - needs tuning
                    elif parse_result.validation_warnings:
                        validation_status = "WARNING"

                    # Update database with refreshed data
                    notes = '|'.join(parse_result.detection_notes) if parse_result.detection_notes else None

                    cursor.execute("""
                        UPDATE programs
                        SET title = ?,
                            spacer_type = ?,
                            outer_diameter = ?,
                            thickness = ?,
                            thickness_display = ?,
                            center_bore = ?,
                            hub_height = ?,
                            hub_diameter = ?,
                            counter_bore_diameter = ?,
                            counter_bore_depth = ?,
                            material = ?,
                            detection_confidence = ?,
                            detection_method = ?,
                            validation_status = ?,
                            validation_issues = ?,
                            validation_warnings = ?,
                            cb_from_gcode = ?,
                            ob_from_gcode = ?,
                            bore_warnings = ?,
                            dimensional_issues = ?,
                            lathe = ?,
                            notes = ?,
                            tools_used = ?,
                            tool_sequence = ?,
                            tool_validation_status = ?,
                            tool_validation_issues = ?,
                            safety_blocks_status = ?,
                            safety_blocks_issues = ?,
                            tool_home_status = ?,
                            tool_home_issues = ?,
                            crash_issues = ?,
                            crash_warnings = ?,
                            last_modified = ?
                        WHERE program_number = ?
                    """, (
                        parse_result.title,
                        parse_result.spacer_type,
                        parse_result.outer_diameter,
                        parse_result.thickness,
                        parse_result.thickness_display,
                        parse_result.center_bore,
                        parse_result.hub_height,
                        parse_result.hub_diameter,
                        parse_result.counter_bore_diameter,
                        parse_result.counter_bore_depth,
                        parse_result.material,
                        parse_result.detection_confidence,
                        parse_result.detection_method,
                        validation_status,
                        '|'.join(parse_result.validation_issues) if parse_result.validation_issues else None,
                        '|'.join(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                        parse_result.cb_from_gcode,
                        parse_result.ob_from_gcode,
                        '|'.join(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                        '|'.join(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                        parse_result.lathe,
                        notes,
                        json.dumps(parse_result.tools_used) if parse_result.tools_used else None,
                        json.dumps(parse_result.tool_sequence) if parse_result.tool_sequence else None,
                        None,  # tool_validation_status - DISABLED
                        None,  # tool_validation_issues - DISABLED
                        None,  # safety_blocks_status - DISABLED
                        None,  # safety_blocks_issues - DISABLED
                        parse_result.tool_home_status,
                        json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                        json.dumps(parse_result.crash_issues) if parse_result.crash_issues else None,
                        json.dumps(parse_result.crash_warnings) if parse_result.crash_warnings else None,
                        datetime.now().isoformat(),
                        prog_num
                    ))

                    updated += 1

                    # Show progress for first few and periodically
                    if idx <= 5 or idx % 50 == 0 or idx == len(modified_files):
                        progress_text.insert(tk.END, f"[{idx}/{len(modified_files)}] {filename} - OK Updated\n")
                        progress_text.see(tk.END)
                        self.root.update()

                except Exception as e:
                    errors += 1
                    if idx <= 5 or idx % 50 == 0:
                        progress_text.insert(tk.END, f"[{idx}/{len(modified_files)}] {filename} - ERROR: {str(e)[:60]}\n")
                        progress_text.see(tk.END)
                        self.root.update()

        # Commit all changes
        conn.commit()
        conn.close()

        # Summary
        progress_label.config(text="Scan Complete!")
        progress_text.insert(tk.END, f"\n{'='*60}\n")
        progress_text.insert(tk.END, f"RESCAN CHANGED FILES COMPLETE\n")
        progress_text.insert(tk.END, f"{'='*60}\n")
        progress_text.insert(tk.END, f"Total files in database: {total_files}\n")
        progress_text.insert(tk.END, f"Modified files found: {len(modified_files)}\n")
        progress_text.insert(tk.END, f"Successfully updated: {updated}\n")
        progress_text.insert(tk.END, f"Skipped (unchanged): {skipped}\n")
        if not_found > 0:
            progress_text.insert(tk.END, f"Not found: {not_found}\n")
        if errors > 0:
            progress_text.insert(tk.END, f"Errors: {errors}\n")
        progress_text.insert(tk.END, f"\n✓ Much faster than full rescan!\n")
        progress_text.see(tk.END)

        # Close button — also opens details for the selected program so the
        # user can immediately see the updated validation results
        def _close_rescan_changed():
            progress_window.destroy()
            if self.tree.selection():
                self.view_details()

        close_btn = tk.Button(progress_window, text="Close",
                             command=_close_rescan_changed,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        # Refresh the display
        self.refresh_results()

    def view_tool_statistics(self):
        """Display tool usage statistics across all programs"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Get all programs with tool data
        cursor.execute("""
            SELECT program_number, spacer_type, outer_diameter, tools_used, tool_sequence,
                   tool_validation_status, tool_validation_issues, safety_blocks_status, safety_blocks_issues
            FROM programs
            WHERE tools_used IS NOT NULL AND tools_used != 'null'
        """)
        results = cursor.fetchall()

        if not results:
            messagebox.showinfo("No Tool Data",
                              "No tool usage data found.\n\n"
                              "Run a rescan to extract tool information from your G-code files.")
            conn.close()
            return

        # Create statistics window
        stats_window = tk.Toplevel(self.root)
        stats_window.title("Tool Usage Statistics")
        stats_window.geometry("1000x700")
        stats_window.configure(bg=self.bg_color)

        # Title
        title_label = tk.Label(stats_window, text="🔧 Tool Usage Statistics & Safety Analysis",
                              bg=self.bg_color, fg=self.fg_color,
                              font=("Arial", 14, "bold"))
        title_label.pack(pady=10)

        # Create notebook for tabs
        notebook = ttk.Notebook(stats_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Tab 1: Tool Usage Summary
        summary_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(summary_frame, text="Tool Summary")

        summary_text = scrolledtext.ScrolledText(summary_frame,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 10),
                                                 wrap=tk.WORD)
        summary_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Calculate statistics
        tool_counts = {}
        tool_by_part_type = {}
        tool_sequences_common = {}
        tool_issues_count = 0
        safety_issues_count = 0

        for row in results:
            prog_num, spacer_type, od, tools_json, sequence_json, tool_status, tool_issues_json, safety_status, safety_issues_json = row

            # Parse JSON
            try:
                tools = json.loads(tools_json) if tools_json else []
                sequence = json.loads(sequence_json) if sequence_json else []
                tool_issues = json.loads(tool_issues_json) if tool_issues_json else []
                safety_issues = json.loads(safety_issues_json) if safety_issues_json else []

                # Count tools
                for tool in tools:
                    tool_counts[tool] = tool_counts.get(tool, 0) + 1

                    # By part type
                    if spacer_type not in tool_by_part_type:
                        tool_by_part_type[spacer_type] = {}
                    tool_by_part_type[spacer_type][tool] = tool_by_part_type[spacer_type].get(tool, 0) + 1

                # Count sequences
                seq_str = " → ".join(sequence)
                if seq_str:
                    tool_sequences_common[seq_str] = tool_sequences_common.get(seq_str, 0) + 1

                # Count issues
                if tool_issues:
                    tool_issues_count += 1
                if safety_issues:
                    safety_issues_count += 1

            except:
                continue

        # Write summary
        summary_text.insert(tk.END, f"{'='*80}\n")
        summary_text.insert(tk.END, f"TOOL USAGE SUMMARY\n")
        summary_text.insert(tk.END, f"{'='*80}\n\n")

        summary_text.insert(tk.END, f"Total programs analyzed: {len(results)}\n")
        summary_text.insert(tk.END, f"Programs with tool issues: {tool_issues_count}\n")
        summary_text.insert(tk.END, f"Programs with safety issues: {safety_issues_count}\n\n")

        summary_text.insert(tk.END, f"{'='*80}\n")
        summary_text.insert(tk.END, f"MOST COMMON TOOLS (All Parts)\n")
        summary_text.insert(tk.END, f"{'='*80}\n\n")

        for tool, count in sorted(tool_counts.items(), key=lambda x: x[1], reverse=True):
            pct = (count / len(results)) * 100
            summary_text.insert(tk.END, f"{tool:6s}: {count:5d} programs ({pct:5.1f}%)\n")

        summary_text.insert(tk.END, f"\n{'='*80}\n")
        summary_text.insert(tk.END, f"TOOLS BY PART TYPE\n")
        summary_text.insert(tk.END, f"{'='*80}\n\n")

        for part_type in sorted(tool_by_part_type.keys()):
            summary_text.insert(tk.END, f"{part_type}:\n")
            for tool, count in sorted(tool_by_part_type[part_type].items(), key=lambda x: x[1], reverse=True)[:5]:
                summary_text.insert(tk.END, f"  {tool}: {count} programs\n")
            summary_text.insert(tk.END, "\n")

        summary_text.insert(tk.END, f"{'='*80}\n")
        summary_text.insert(tk.END, f"MOST COMMON TOOL SEQUENCES (Top 10)\n")
        summary_text.insert(tk.END, f"{'='*80}\n\n")

        for seq, count in sorted(tool_sequences_common.items(), key=lambda x: x[1], reverse=True)[:10]:
            summary_text.insert(tk.END, f"{count:4d}x: {seq}\n")

        summary_text.config(state=tk.DISABLED)

        # Tab 2: Tool Issues
        issues_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(issues_frame, text="Tool Issues")

        issues_text = scrolledtext.ScrolledText(issues_frame,
                                                bg=self.input_bg, fg=self.fg_color,
                                                font=("Courier", 9),
                                                wrap=tk.WORD)
        issues_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        issues_text.insert(tk.END, f"{'='*80}\n")
        issues_text.insert(tk.END, f"TOOL VALIDATION ISSUES\n")
        issues_text.insert(tk.END, f"{'='*80}\n\n")

        for row in results:
            prog_num, spacer_type, od, tools_json, sequence_json, tool_status, tool_issues_json, safety_status, safety_issues_json = row

            try:
                tool_issues = json.loads(tool_issues_json) if tool_issues_json else []

                if tool_issues:
                    issues_text.insert(tk.END, f"{prog_num} ({spacer_type}):\n")
                    for issue in tool_issues:
                        issues_text.insert(tk.END, f"  ⚠ {issue}\n")
                    issues_text.insert(tk.END, "\n")
            except:
                continue

        if tool_issues_count == 0:
            issues_text.insert(tk.END, "✓ No tool issues found!\n")

        issues_text.config(state=tk.DISABLED)

        # Tab 3: Safety Issues
        safety_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(safety_frame, text="Safety Issues")

        safety_text = scrolledtext.ScrolledText(safety_frame,
                                                bg=self.input_bg, fg=self.fg_color,
                                                font=("Courier", 9),
                                                wrap=tk.WORD)
        safety_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        safety_text.insert(tk.END, f"{'='*80}\n")
        safety_text.insert(tk.END, f"SAFETY BLOCK VALIDATION ISSUES\n")
        safety_text.insert(tk.END, f"{'='*80}\n\n")

        for row in results:
            prog_num, spacer_type, od, tools_json, sequence_json, tool_status, tool_issues_json, safety_status, safety_issues_json = row

            try:
                safety_issues = json.loads(safety_issues_json) if safety_issues_json else []

                if safety_issues:
                    safety_text.insert(tk.END, f"{prog_num} ({spacer_type}):\n")
                    for issue in safety_issues:
                        safety_text.insert(tk.END, f"  ⚠ {issue}\n")
                    safety_text.insert(tk.END, "\n")
            except:
                continue

        if safety_issues_count == 0:
            safety_text.insert(tk.END, "✓ No safety issues found!\n")

        safety_text.config(state=tk.DISABLED)

        # Close button
        close_btn = tk.Button(stats_window, text="Close",
                             command=stats_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        conn.close()

    def scan_tool_change_positions(self):
        """Scan G-code files to find all G53 X Z tool change position lines"""
        # Ask user which files to scan
        scan_choice = messagebox.askyesnocancel(
            "Scan Tool Positions",
            "Scan for G53 X Z tool change position lines?\n\n"
            "YES = Scan repository files only\n"
            "NO = Scan a specific folder\n"
            "CANCEL = Cancel"
        )

        if scan_choice is None:
            return

        files_to_scan = []

        if scan_choice:  # YES - scan repository
            if os.path.exists(self.repository_path):
                for file in os.listdir(self.repository_path):
                    file_path = os.path.join(self.repository_path, file)
                    if os.path.isfile(file_path):
                        files_to_scan.append(file_path)
            # Also scan revised repository
            if os.path.exists(self.revised_repository_path):
                for file in os.listdir(self.revised_repository_path):
                    file_path = os.path.join(self.revised_repository_path, file)
                    if os.path.isfile(file_path):
                        files_to_scan.append(file_path)
        else:  # NO - scan specific folder
            folder = filedialog.askdirectory(title="Select folder to scan for tool positions")
            if not folder:
                return
            for root, _, files in os.walk(folder):
                for file in files:
                    if file.lower().endswith(('.nc', '.txt', '.tap', '.gcode', '')) and not file.startswith('.'):
                        files_to_scan.append(os.path.join(root, file))

        if not files_to_scan:
            messagebox.showinfo("No Files", "No files found to scan.")
            return

        # Progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Scanning Tool Positions...")
        progress_window.geometry("400x150")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="Scanning for G53 X Z lines...",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 11)).pack(pady=20)

        progress_label = tk.Label(progress_window, text="0 / 0",
                                 bg=self.bg_color, fg=self.fg_color, font=("Arial", 10))
        progress_label.pack(pady=10)

        progress_window.update()

        # Count unique G53 X Z lines - once per file only
        line_counts = {}  # {normalized_line: number of files}

        total_files = len(files_to_scan)
        scanned = 0

        for file_path in files_to_scan:
            scanned += 1
            if scanned % 50 == 0:
                progress_label.config(text=f"{scanned} / {total_files}")
                progress_window.update()

            try:
                with open(file_path, 'r', errors='ignore') as f:
                    lines = f.readlines()

                # Track lines found in THIS file (count once per file)
                lines_in_this_file = set()

                for line in lines:
                    line_stripped = line.strip().upper()

                    # Skip comments and empty lines
                    if not line_stripped or line_stripped.startswith('(') or line_stripped.startswith(';'):
                        continue

                    # Check if line contains G53 with X and Z (tool change position)
                    if 'G53' in line_stripped and 'X' in line_stripped and 'Z' in line_stripped:
                        # Normalize whitespace for counting
                        normalized = ' '.join(line_stripped.split())
                        lines_in_this_file.add(normalized)

                # Count each unique line once per file
                for normalized in lines_in_this_file:
                    line_counts[normalized] = line_counts.get(normalized, 0) + 1

            except Exception as e:
                logger.error(f"Error scanning {file_path}: {e}")
                continue

        progress_window.destroy()

        # Create results window
        results_window = tk.Toplevel(self.root)
        results_window.title("Tool Change Position Lines")
        results_window.geometry("800x600")
        results_window.configure(bg=self.bg_color)

        # Title
        tk.Label(results_window, text="G53 X Z Tool Change Position Lines",
                font=("Arial", 16, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        tk.Label(results_window, text=f"Scanned {total_files} files | Found {len(line_counts)} unique lines",
                font=("Arial", 10), bg=self.bg_color, fg="#888888").pack()

        # Results text area
        text_frame = tk.Frame(results_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        results_text = scrolledtext.ScrolledText(text_frame, bg=self.input_bg, fg=self.fg_color,
                                                 font=("Consolas", 10), wrap=tk.NONE)
        results_text.pack(fill=tk.BOTH, expand=True)

        # Sort by count descending
        sorted_lines = sorted(line_counts.items(), key=lambda x: x[1], reverse=True)

        results_text.insert(tk.END, f"{'FILES':<10} LINE\n")
        results_text.insert(tk.END, "=" * 70 + "\n")

        for line, count in sorted_lines:
            results_text.insert(tk.END, f"{count:<10} {line}\n")

        results_text.insert(tk.END, "\n" + "=" * 70 + "\n")
        results_text.insert(tk.END, f"Total unique position lines: {len(line_counts)}\n")

        # Button frame
        btn_frame = tk.Frame(results_window, bg=self.bg_color)
        btn_frame.pack(pady=10)

        def export_lines():
            export_path = filedialog.asksaveasfilename(
                title="Export Tool Position Lines",
                defaultextension=".txt",
                filetypes=[("Text Files", "*.txt"), ("CSV Files", "*.csv")]
            )
            if export_path:
                try:
                    with open(export_path, 'w') as f:
                        f.write("COUNT\tLINE\n")
                        for line, count in sorted_lines:
                            f.write(f"{count}\t{line}\n")
                    messagebox.showinfo("Exported", f"Exported to:\n{export_path}")
                except Exception as e:
                    messagebox.showerror("Error", f"Export failed:\n{e}")

        tk.Button(btn_frame, text="Export", command=export_lines,
                 bg="#4CAF50", fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=10)

        tk.Button(btn_frame, text="Close", command=results_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=10)

    def fix_program_numbers(self):
        """Update internal O-numbers to match filenames - FILTERED VIEW ONLY"""
        # Get currently displayed items (respects filters)
        displayed_items = self.tree.get_children()

        if not displayed_items:
            messagebox.showwarning("No Files",
                "No files in current view.\n\n"
                "Apply filters to show the files you want to fix.")
            return

        # Get program numbers and file info from filtered view
        filtered_files = []
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        for item in displayed_items:
            values = self.tree.item(item)['values']
            if values:
                prog_num = values[0]
                # Get file path from database
                cursor.execute("""
                    SELECT program_number, file_path
                    FROM programs
                    WHERE program_number = ?
                """, (prog_num,))
                row = cursor.fetchone()
                if row and row[1]:  # Has file_path
                    filtered_files.append(row)

        conn.close()

        if not filtered_files:
            messagebox.showwarning("No Files with Paths",
                "No files in filtered view have physical file paths.\n\n"
                "Only files with linked physical files can be fixed.")
            return

        # Confirm operation
        msg = f"Fix program numbers for {len(filtered_files)} file(s) in filtered view?\n\n"
        msg += "This will:\n"
        msg += "• Read the O-number from each filename\n"
        msg += "• Update the internal O-number in the G-code file to match\n"
        msg += "• Update database program_number to match filename\n\n"
        msg += "Use this AFTER renaming files with 'Rename Duplicates'\n"
        msg += "to synchronize internal content with filenames.\n\n"
        msg += "Database backup will be created automatically."

        result = messagebox.askyesno("Confirm Fix Program Numbers", msg)
        if not result:
            return

        # Create backup
        if not self.backup_database():
            messagebox.showerror("Backup Failed",
                "Database backup failed. Operation canceled for safety.")
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Fixing Program Numbers (Filtered View)")
        progress_window.geometry("700x600")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Processing filtered files...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 9),
                                                 wrap=tk.WORD)
        progress_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.root.update()

        progress_text.insert(tk.END, f"Processing {len(filtered_files)} file(s) from filtered view...\n\n")

        # Process files from filtered view
        fixed = 0
        skipped = 0
        errors = 0
        total_files = len(filtered_files)

        # Open single database connection for all updates (prevents locking issues)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        for file_idx, file_info in enumerate(filtered_files, 1):
            old_prog_num, filepath = file_info
            filename = os.path.basename(filepath)

            progress_label.config(text=f"Processing {file_idx}/{total_files}: {filename}")
            progress_text.insert(tk.END, f"[{file_idx}/{total_files}] {filename}\n")
            progress_text.see(tk.END)
            self.root.update()

            try:
                # Check if file exists
                if not os.path.exists(filepath):
                    progress_text.insert(tk.END, f"  SKIP: File not found\n\n")
                    skipped += 1
                    continue

                # Extract O-number from filename (e.g., o80556.txt -> O80556)
                match = re.search(r'[oO](\d+)', filename)
                if not match:
                    progress_text.insert(tk.END, f"  SKIP: Cannot extract O-number from filename\n\n")
                    skipped += 1
                    continue

                file_onumber = int(match.group(1))
                new_prog_str = f"O{file_onumber:05d}"  # Always 5 digits with leading zeros
                new_prog_str_lower = new_prog_str.lower()

                # Check if already correct
                if old_prog_num.lower() == new_prog_str_lower:
                    progress_text.insert(tk.END, f"  ✓ Already correct: {new_prog_str_lower}\n\n")
                    skipped += 1
                    continue

                # Read file content
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()

                # Update internal program number (first line with O#####)
                updated = False
                for i, line in enumerate(lines):
                    stripped = line.strip()
                    match_line = re.match(r'^([oO]\d{4,})\s*(\(.*)?$', stripped)
                    if match_line:
                        title_part = match_line.group(2) if match_line.group(2) else ""
                        if title_part:
                            lines[i] = f"{new_prog_str} {title_part}\n"
                        else:
                            lines[i] = f"{new_prog_str}\n"
                        updated = True
                        break

                if not updated:
                    progress_text.insert(tk.END, f"  ⚠️  WARNING: No O-number line found in file to update\n")

                # Write updated content
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.writelines(lines)

                # Update database with new program number
                cursor.execute("""
                    UPDATE programs
                    SET program_number = ?
                    WHERE program_number = ?
                """, (new_prog_str_lower, old_prog_num))
                conn.commit()

                progress_text.insert(tk.END, f"  ✓ {old_prog_num} → {new_prog_str_lower}\n\n")
                fixed += 1
                progress_text.see(tk.END)

            except Exception as e:
                progress_text.insert(tk.END, f"  ❌ ERROR: {str(e)[:100]}\n\n")
                progress_text.see(tk.END)
                errors += 1

        # Close database connection
        conn.close()

        # Show results
        progress_label.config(text="Complete!")
        progress_text.insert(tk.END, f"\n{'='*50}\n")
        progress_text.insert(tk.END, f"FIX PROGRAM NUMBERS - SUMMARY\n")
        progress_text.insert(tk.END, f"{'='*50}\n")
        progress_text.insert(tk.END, f"Files processed: {total_files}\n")
        progress_text.insert(tk.END, f"Successfully fixed: {fixed}\n")
        progress_text.insert(tk.END, f"Already correct/Skipped: {skipped}\n")
        progress_text.insert(tk.END, f"Errors: {errors}\n\n")
        progress_text.insert(tk.END, f"Internal O-numbers now match filenames.\n")
        progress_text.insert(tk.END, f"Database updated.\n")
        progress_text.see(tk.END)

        # Refresh the view to show new program numbers
        self.refresh_filter_values()
        self.refresh_results()

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def clear_database(self):
        """Clear all records from the database and backup repository"""
        # Permission check
        if not self.require_permission('clear_database', 'clear the database'):
            return

        # Count files in repository
        repo_file_count = 0
        if os.path.exists(self.repository_path):
            repo_file_count = len([f for f in os.listdir(self.repository_path) if os.path.isfile(os.path.join(self.repository_path, f))])

        # Confirm with user
        result = messagebox.askyesno(
            "Clear Database & Repository",
            f"This will:\n\n"
            f"1. Backup the repository folder ({repo_file_count} files) with timestamp\n"
            f"2. Clear all database records\n"
            f"3. Reset all program numbers to AVAILABLE\n"
            f"4. Create a fresh empty repository\n\n"
            f"The backup will be saved in 'repository_backups' folder.\n\n"
            f"Continue?",
            icon='warning'
        )

        if not result:
            return

        # Double confirm
        result2 = messagebox.askyesno(
            "Confirm Clear",
            "This will move ALL files to backup and start fresh.\n\n"
            "Are you absolutely sure?",
            icon='warning'
        )

        if not result2:
            return

        # Create auto-backup of database before destructive operation
        backup_path = self.create_auto_backup("clear_database")
        if backup_path:
            logger.info("Auto-backup created before clearing database")

        try:
            from datetime import datetime
            import shutil

            # Step 1: Backup repository folder
            if os.path.exists(self.repository_path) and repo_file_count > 0:
                # Create repository_backups directory
                backups_base = os.path.join(os.path.dirname(self.repository_path), "repository_backups")
                os.makedirs(backups_base, exist_ok=True)

                # Create timestamped backup folder
                timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                backup_folder = os.path.join(backups_base, f"repository_{timestamp}")

                logger.info(f"Moving repository to backup: {backup_folder}")

                # Move entire repository to backup
                shutil.move(self.repository_path, backup_folder)

                logger.info(f"Repository backed up: {repo_file_count} files moved to {backup_folder}")

            # Step 2: Create fresh empty repository
            os.makedirs(self.repository_path, exist_ok=True)
            logger.info("Created fresh empty repository folder")

            # Step 3: Clear database and reset registry
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get count before deletion
            cursor.execute("SELECT COUNT(*) FROM programs")
            db_count = cursor.fetchone()[0]

            # Delete all program records
            cursor.execute("DELETE FROM programs")

            # Reset all registry entries to AVAILABLE
            cursor.execute("""
                UPDATE program_number_registry
                SET status = 'AVAILABLE', file_path = NULL, last_checked = ?
            """, (datetime.now().isoformat(),))
            registry_reset_count = cursor.rowcount

            conn.commit()
            conn.close()

            logger.info(f"Database cleared: {db_count} records deleted, {registry_reset_count} registry entries reset")

            # Refresh the display
            self.refresh_filter_values()
            self.refresh_results()

            messagebox.showinfo(
                "Database & Repository Cleared",
                f"Successfully completed:\n\n"
                f"• Repository backed up: {repo_file_count} files\n"
                f"  Location: repository_backups/repository_{timestamp}\n\n"
                f"• Database cleared: {db_count} records deleted\n\n"
                f"• Registry reset: {registry_reset_count} numbers now available\n\n"
                f"Ready for fresh scan."
            )

        except Exception as e:
            logger.error(f"Error clearing database: {e}", exc_info=True)
            messagebox.showerror("Error", f"Failed to clear database:\n{str(e)}")

    def clean_stale_records(self):
        """Find and soft-delete records where file no longer exists"""
        from datetime import datetime

        # Find stale records
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        try:
            # Get all records with file paths (excluding already deleted)
            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE file_path IS NOT NULL
                AND (is_deleted IS NULL OR is_deleted = 0)
            """)

            all_records = cursor.fetchall()
            stale_records = []

            # Check which files no longer exist
            for program_number, file_path in all_records:
                if not os.path.exists(file_path):
                    stale_records.append((program_number, file_path))

            if not stale_records:
                messagebox.showinfo(
                    "Clean Stale Records",
                    "No stale records found!\n\n"
                    "All file paths in the database point to existing files."
                )
                return

            # Show confirmation dialog with details
            stale_list = "\n".join([f"  - {prog}: {os.path.basename(path)}"
                                   for prog, path in stale_records[:10]])
            if len(stale_records) > 10:
                stale_list += f"\n  ... and {len(stale_records) - 10} more"

            result = messagebox.askyesno(
                "Clean Stale Records",
                f"Found {len(stale_records)} records with missing files:\n\n"
                f"{stale_list}\n\n"
                f"These records will be:\n"
                f"• Marked as deleted (is_deleted=1)\n"
                f"• Hidden from normal views\n"
                f"• Kept in database for future restore\n\n"
                f"Continue?",
                icon='warning'
            )

            if not result:
                return

            # Soft-delete stale records
            current_time = datetime.now().isoformat()
            deleted_count = 0

            for program_number, file_path in stale_records:
                cursor.execute("""
                    UPDATE programs
                    SET is_deleted = 1,
                        deleted_date = ?
                    WHERE program_number = ?
                """, (current_time, program_number))
                deleted_count += 1

            conn.commit()

            # Refresh the display
            self.refresh_filter_values()
            self.refresh_results()

            messagebox.showinfo(
                "Stale Records Cleaned",
                f"Successfully marked {deleted_count} stale records as deleted.\n\n"
                f"These records are now hidden from normal views but can be\n"
                f"restored using 'View Archived/Deleted Files' feature."
            )

            logger.info(f"Cleaned {deleted_count} stale records (files not found)")

        except Exception as e:
            logger.error(f"Error cleaning stale records: {e}", exc_info=True)
            messagebox.showerror("Error", f"Failed to clean stale records:\n{str(e)}")
        finally:
            conn.close()

    def save_database_profile(self):
        """Save current database as a named profile"""
        import shutil
        from datetime import datetime

        # Create profiles directory if it doesn't exist
        profiles_dir = os.path.join(os.path.dirname(self.db_path), "database_profiles")
        os.makedirs(profiles_dir, exist_ok=True)

        # Prompt for profile name
        profile_window = tk.Toplevel(self.root)
        profile_window.title("Save Database Profile")
        profile_window.geometry("450x200")
        profile_window.configure(bg=self.bg_color)
        profile_window.transient(self.root)
        profile_window.grab_set()

        tk.Label(profile_window,
                text="Save current database state as a profile",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=15)

        tk.Label(profile_window,
                text="Profile Name:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        # Suggest default name with timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M")
        default_name = f"Profile_{timestamp}"

        entry = tk.Entry(profile_window, bg=self.input_bg, fg=self.fg_color,
                        font=("Arial", 11), width=40)
        entry.insert(0, default_name)
        entry.pack(pady=10)
        entry.focus()
        entry.select_range(0, tk.END)

        result = [None]

        def save():
            profile_name = entry.get().strip()
            if not profile_name:
                messagebox.showwarning("Invalid Name", "Please enter a profile name.")
                return

            # Remove any invalid filename characters
            profile_name = "".join(c for c in profile_name if c.isalnum() or c in (' ', '-', '_'))

            profile_path = os.path.join(profiles_dir, f"{profile_name}.db")

            # Check if profile already exists
            if os.path.exists(profile_path):
                overwrite = messagebox.askyesno(
                    "Profile Exists",
                    f"Profile '{profile_name}' already exists.\n\nOverwrite?"
                )
                if not overwrite:
                    return

            try:
                # Copy current database to profile
                shutil.copy2(self.db_path, profile_path)

                # Get record count
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM programs")
                count = cursor.fetchone()[0]
                conn.close()

                result[0] = profile_name
                messagebox.showinfo(
                    "Profile Saved",
                    f"Database profile '{profile_name}' saved successfully!\n\n"
                    f"Records: {count}\n"
                    f"Location: {profile_path}"
                )
                profile_window.destroy()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to save profile:\n{str(e)}")

        def cancel():
            profile_window.destroy()

        btn_frame = tk.Frame(profile_window, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="💾 Save", command=save,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Cancel", command=cancel,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

        self.root.wait_window(profile_window)

    def load_database_profile(self):
        """Load a saved database profile"""
        import shutil

        profiles_dir = os.path.join(os.path.dirname(self.db_path), "database_profiles")

        # Check if profiles directory exists
        if not os.path.exists(profiles_dir):
            messagebox.showinfo(
                "No Profiles",
                "No saved profiles found.\n\n"
                "Use 'Save Profile' to create your first database profile."
            )
            return

        # Get list of profile files
        profile_files = [f for f in os.listdir(profiles_dir) if f.endswith('.db')]

        if not profile_files:
            messagebox.showinfo(
                "No Profiles",
                "No saved profiles found.\n\n"
                "Use 'Save Profile' to create your first database profile."
            )
            return

        # Create selection window
        select_window = tk.Toplevel(self.root)
        select_window.title("Load Database Profile")
        select_window.geometry("600x500")
        select_window.configure(bg=self.bg_color)
        select_window.transient(self.root)
        select_window.grab_set()

        tk.Label(select_window,
                text="Select a profile to load",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=15)

        # Listbox with profile info
        list_frame = tk.Frame(select_window, bg=self.bg_color)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        scrollbar = tk.Scrollbar(list_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        listbox = tk.Listbox(list_frame, bg=self.input_bg, fg=self.fg_color,
                            font=("Courier", 10), yscrollcommand=scrollbar.set,
                            selectmode=tk.SINGLE)
        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=listbox.yview)

        # Populate listbox with profile info
        profile_data = []
        for profile_file in sorted(profile_files, reverse=True):
            profile_path = os.path.join(profiles_dir, profile_file)
            profile_name = profile_file[:-3]  # Remove .db extension

            # Get file stats
            stat = os.stat(profile_path)
            size_mb = stat.st_size / (1024 * 1024)
            modified = datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M")

            # Get record count
            try:
                conn = sqlite3.connect(profile_path)
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM programs")
                count = cursor.fetchone()[0]
                conn.close()
            except:
                count = "?"

            display = f"{profile_name:<35} | {count:>6} records | {modified} | {size_mb:.1f} MB"
            listbox.insert(tk.END, display)
            profile_data.append((profile_name, profile_path, count))

        def load_selected():
            selection = listbox.curselection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a profile to load.")
                return

            idx = selection[0]
            profile_name, profile_path, count = profile_data[idx]

            # Confirm load
            result = messagebox.askyesno(
                "Confirm Load Profile",
                f"Load profile '{profile_name}'?\n\n"
                f"This will replace your current database with:\n"
                f"  • {count} records\n"
                f"  • From: {os.path.basename(profile_path)}\n\n"
                f"⚠️  Your current database will be backed up first.",
                icon='warning'
            )

            if not result:
                return

            try:
                # Backup current database
                backup_name = f"before_load_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
                backup_path = os.path.join(os.path.dirname(self.db_path), "backups", backup_name)
                os.makedirs(os.path.dirname(backup_path), exist_ok=True)
                shutil.copy2(self.db_path, backup_path)

                # Load profile
                shutil.copy2(profile_path, self.db_path)

                # Refresh display
                self.refresh_filter_values()
                self.refresh_results()

                messagebox.showinfo(
                    "Profile Loaded",
                    f"Successfully loaded profile '{profile_name}'!\n\n"
                    f"Records loaded: {count}\n"
                    f"Previous database backed up to:\n{backup_name}"
                )

                select_window.destroy()

            except Exception as e:
                messagebox.showerror("Error", f"Failed to load profile:\n{str(e)}")

        def cancel():
            select_window.destroy()

        btn_frame = tk.Frame(select_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="📂 Load Selected", command=load_selected,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Cancel", command=cancel,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.LEFT, padx=5)

    def manage_database_profiles(self):
        """Manage saved database profiles - view, delete, rename"""
        import shutil
        from datetime import datetime

        profiles_dir = os.path.join(os.path.dirname(self.db_path), "database_profiles")

        # Check if profiles directory exists
        if not os.path.exists(profiles_dir):
            os.makedirs(profiles_dir, exist_ok=True)

        # Create management window
        manage_window = tk.Toplevel(self.root)
        manage_window.title("Manage Database Profiles")
        manage_window.geometry("800x600")
        manage_window.configure(bg=self.bg_color)

        tk.Label(manage_window,
                text="Database Profile Manager",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=15)

        # Treeview for profile list
        tree_frame = tk.Frame(manage_window, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        columns = ('name', 'records', 'date', 'size')
        tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)

        tree.heading('name', text='Profile Name')
        tree.heading('records', text='Records')
        tree.heading('date', text='Date Modified')
        tree.heading('size', text='Size (MB)')

        tree.column('name', width=300)
        tree.column('records', width=100)
        tree.column('date', width=200)
        tree.column('size', width=100)

        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscroll=scrollbar.set)

        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        def refresh_profile_list():
            # Clear existing items
            for item in tree.get_children():
                tree.delete(item)

            # Get profile files
            profile_files = [f for f in os.listdir(profiles_dir) if f.endswith('.db')]

            if not profile_files:
                tree.insert('', tk.END, values=("No profiles found - use 'Save Profile' to create one", "", "", ""))
                return

            for profile_file in sorted(profile_files, reverse=True):
                profile_path = os.path.join(profiles_dir, profile_file)
                profile_name = profile_file[:-3]

                # Get stats
                stat = os.stat(profile_path)
                size_mb = f"{stat.st_size / (1024 * 1024):.2f}"
                modified = datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")

                # Get record count
                try:
                    conn = sqlite3.connect(profile_path)
                    cursor = conn.cursor()
                    cursor.execute("SELECT COUNT(*) FROM programs")
                    count = cursor.fetchone()[0]
                    conn.close()
                except:
                    count = "Error"

                tree.insert('', tk.END, values=(profile_name, count, modified, size_mb))

        def delete_profile():
            selection = tree.selection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a profile to delete.")
                return

            item = selection[0]
            profile_name = tree.item(item)['values'][0]

            if profile_name == "No profiles found - use 'Save Profile' to create one":
                return

            result = messagebox.askyesno(
                "Confirm Delete",
                f"Delete profile '{profile_name}'?\n\n"
                f"This cannot be undone!",
                icon='warning'
            )

            if result:
                try:
                    profile_path = os.path.join(profiles_dir, f"{profile_name}.db")
                    os.remove(profile_path)
                    refresh_profile_list()
                    messagebox.showinfo("Deleted", f"Profile '{profile_name}' deleted successfully.")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to delete profile:\n{str(e)}")

        def export_profile():
            selection = tree.selection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a profile to export.")
                return

            item = selection[0]
            profile_name = tree.item(item)['values'][0]

            if profile_name == "No profiles found - use 'Save Profile' to create one":
                return

            # Ask where to save
            export_path = filedialog.asksaveasfilename(
                defaultextension=".db",
                initialfile=f"{profile_name}.db",
                filetypes=[("Database files", "*.db"), ("All files", "*.*")],
                title="Export Profile"
            )

            if export_path:
                try:
                    profile_path = os.path.join(profiles_dir, f"{profile_name}.db")
                    shutil.copy2(profile_path, export_path)
                    messagebox.showinfo("Exported", f"Profile exported to:\n{export_path}")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to export profile:\n{str(e)}")

        # Initial load
        refresh_profile_list()

        # Button frame
        btn_frame = tk.Frame(manage_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="🗑️ Delete", command=delete_profile,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="📤 Export", command=export_profile,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="🔄 Refresh", command=refresh_profile_list,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Close", command=manage_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=5)

    def fix_duplicates(self):
        """Fix duplicate program numbers by assigning new unique o##### values based on OD"""
        # Find duplicates in database (entries with (##) suffix)
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Find all programs with duplicate suffix pattern
        cursor.execute("""
            SELECT program_number, file_path, outer_diameter
            FROM programs
            WHERE program_number LIKE '%(%)'
            ORDER BY program_number
        """)
        duplicates = cursor.fetchall()

        if not duplicates:
            messagebox.showinfo("No Duplicates", "No duplicate programs found in the database.\n\n"
                              "Duplicates have a (1), (2), etc. suffix.")
            conn.close()
            return

        # Confirm with user
        result = messagebox.askyesno(
            "Fix Duplicates",
            f"Found {len(duplicates)} duplicate programs.\n\n"
            "This will:\n"
            "1. Assign new unique o##### program numbers based on OD\n"
            "2. Rename the files\n"
            "3. Update the internal program number in each file\n"
            "4. Update the database\n\n"
            "Proceed?"
        )

        if not result:
            conn.close()
            return

        # Get all existing program numbers (to avoid collisions)
        cursor.execute("SELECT program_number FROM programs")
        existing_programs = set(row[0] for row in cursor.fetchall())

        # Also check the filesystem for any o##### files
        # Get unique directories from duplicates
        directories = set()
        for _, file_path, _ in duplicates:
            if file_path:
                directories.add(os.path.dirname(file_path))

        # Scan directories for existing program numbers
        for directory in directories:
            if os.path.exists(directory):
                for file in os.listdir(directory):
                    match = re.search(r'[oO](\d{4,})', file)
                    if match:
                        existing_programs.add(f"o{match.group(1)}")

        conn.close()

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Fixing Duplicates...")
        progress_window.geometry("600x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Processing duplicates...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 width=70, height=20)
        progress_text.pack(padx=10, pady=10)

        self.root.update()

        # Process each duplicate
        fixed = 0
        errors = 0

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        for old_program_number, file_path, outer_diameter in duplicates:
            progress_text.insert(tk.END, f"\nProcessing: {old_program_number}\n")
            progress_text.see(tk.END)
            self.root.update()

            # Determine OD range for new program number
            new_program_number = self._get_next_available_program_number(
                outer_diameter, existing_programs
            )

            if not new_program_number:
                progress_text.insert(tk.END, f"  ERROR: Could not find available program number\n")
                errors += 1
                continue

            # Add to existing set to prevent reuse
            existing_programs.add(new_program_number)

            progress_text.insert(tk.END, f"  New program number: {new_program_number}\n")

            # Update file if it exists
            if file_path and os.path.exists(file_path):
                try:
                    # Read file content (preserve original encoding and line endings)
                    with open(file_path, 'rb') as f:
                        content_bytes = f.read()

                    # Detect line ending style
                    if b'\r\n' in content_bytes:
                        line_ending = '\r\n'
                    elif b'\r' in content_bytes:
                        line_ending = '\r'
                    else:
                        line_ending = '\n'

                    # Decode content
                    try:
                        content = content_bytes.decode('utf-8')
                    except UnicodeDecodeError:
                        content = content_bytes.decode('latin-1')

                    # Split into lines (normalize first, then restore)
                    lines = content.replace('\r\n', '\n').replace('\r', '\n').split('\n')

                    # Update internal program number
                    new_lines = []
                    internal_updated = False
                    for line in lines:
                        stripped = line.strip()
                        # Check if line is a program number (O followed by digits)
                        if re.match(r'^[oO]\d{4,}\s*$', stripped):
                            new_lines.append(f"O{new_program_number[1:]}")  # Use uppercase O
                            internal_updated = True
                        else:
                            new_lines.append(line)

                    # Write back to file with original line endings
                    with open(file_path, 'w', newline='') as f:
                        f.write(line_ending.join(new_lines))

                    if internal_updated:
                        progress_text.insert(tk.END, f"  Updated internal program number\n")

                    # Rename file
                    directory = os.path.dirname(file_path)
                    old_filename = os.path.basename(file_path)

                    # Determine new filename (preserve extension if any)
                    if '.' in old_filename:
                        ext = old_filename[old_filename.rfind('.'):]
                        new_filename = f"{new_program_number}{ext}"
                    else:
                        new_filename = new_program_number

                    new_file_path = os.path.join(directory, new_filename)

                    # Check if target file already exists
                    if os.path.exists(new_file_path):
                        progress_text.insert(tk.END, f"  WARNING: Target file already exists: {new_filename}\n")
                        errors += 1
                        continue

                    os.rename(file_path, new_file_path)
                    progress_text.insert(tk.END, f"  Renamed: {old_filename} -> {new_filename}\n")

                    # Update database
                    cursor.execute("""
                        UPDATE programs
                        SET program_number = ?, file_path = ?
                        WHERE program_number = ?
                    """, (new_program_number, new_file_path, old_program_number))

                    progress_text.insert(tk.END, f"  Database updated\n")
                    fixed += 1

                except Exception as e:
                    progress_text.insert(tk.END, f"  ERROR: {str(e)}\n")
                    errors += 1
            else:
                # File doesn't exist, just update database
                progress_text.insert(tk.END, f"  WARNING: File not found, updating database only\n")
                cursor.execute("""
                    UPDATE programs
                    SET program_number = ?
                    WHERE program_number = ?
                """, (new_program_number, old_program_number))
                fixed += 1

            progress_text.see(tk.END)
            self.root.update()

        conn.commit()
        conn.close()

        # Show results
        progress_label.config(text="Complete!")
        progress_text.insert(tk.END, f"\n{'='*50}\n")
        progress_text.insert(tk.END, f"Fixed: {fixed}\n")
        progress_text.insert(tk.END, f"Errors: {errors}\n")
        progress_text.see(tk.END)

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        # Refresh display
        self.refresh_filter_values()
        self.refresh_results()

    def _get_next_available_program_number(self, outer_diameter: float, existing: set) -> str:
        """
        Get next available program number based on OD.

        OD-based ranges:
        - 7.0", 7.5", 8.0", 8.5" -> o7####
        - 6.0", 6.25", 6.5" -> o6####
        - 5.75" -> o5####
        - All others -> any available
        """
        # Determine preferred range based on OD
        if outer_diameter:
            if outer_diameter >= 7.0:
                preferred_ranges = [(70000, 79999), (80000, 89999), (60000, 69999), (50000, 59999)]
            elif outer_diameter >= 6.0:
                preferred_ranges = [(60000, 69999), (70000, 79999), (50000, 59999), (80000, 89999)]
            elif outer_diameter >= 5.5:
                preferred_ranges = [(50000, 59999), (60000, 69999), (70000, 79999), (80000, 89999)]
            else:
                preferred_ranges = [(50000, 59999), (60000, 69999), (70000, 79999), (80000, 89999)]
        else:
            # No OD info, try all ranges
            preferred_ranges = [(50000, 59999), (60000, 69999), (70000, 79999), (80000, 89999)]

        # Search for available number in preferred order
        for start, end in preferred_ranges:
            for num in range(start, end + 1):
                candidate = f"o{num}"
                if candidate not in existing and candidate.upper() not in existing:
                    return candidate

        # If all preferred ranges are full, search extended ranges
        for num in range(10000, 99999):
            candidate = f"o{num}"
            if candidate not in existing and candidate.upper() not in existing:
                return candidate

        return None

    def refresh_filter_values(self):
        """Refresh available filter values from database"""
        # Update available values from database
        new_types = self.get_available_values("spacer_type")
        new_materials = self.get_available_values("material")
        new_statuses = self.get_available_values("validation_status")

        # Update filter widgets if values changed
        if new_types != self.available_types:
            self.available_types = new_types
            self.filter_type.values = new_types
            self.filter_type.clear()

        if new_materials != self.available_materials:
            self.available_materials = new_materials
            self.filter_material.values = new_materials
            self.filter_material.clear()

        if new_statuses != self.available_statuses:
            self.available_statuses = new_statuses
            self.filter_status.values = new_statuses
            self.filter_status.clear()

    def refresh_results(self, view_mode='all', external_only=False):
        """Refresh the results table based on current filters

        Args:
            view_mode: 'all' (default), 'repository', 'revised', or 'external'
            external_only: Deprecated, use view_mode='external' instead
        """
        # Handle deprecated parameter
        if external_only:
            view_mode = 'external'

        # Clear existing - PERFORMANCE: Use delete('') to clear all at once
        children = self.tree.get_children()
        if children:
            self.tree.delete(*children)

        # Build query
        query = "SELECT * FROM programs WHERE 1=1"
        params = []

        # Exclude soft-deleted records from normal views
        query += " AND (is_deleted IS NULL OR is_deleted = 0)"

        # Add view mode filter
        if view_mode == 'repository':
            # Only show managed files in MAIN repository (not revised)
            query += " AND is_managed = 1 AND file_path NOT LIKE ?"
            params.append("%revised_repository%")
        elif view_mode == 'revised':
            # Only show files in revised repository
            query += " AND file_path LIKE ?"
            params.append("%revised_repository%")
        elif view_mode == 'external':
            # Only show external files (NOT in any repository)
            query += " AND (is_managed = 0 OR is_managed IS NULL)"
        # 'all' mode shows everything (no additional filter)

        # Title search filter - supports multiple terms with + and fuzzy search
        if self.filter_title.get():
            search_text = self.filter_title.get().strip()

            # Check if fuzzy search is enabled
            if hasattr(self, 'fuzzy_search_enabled') and self.fuzzy_search_enabled.get():
                # Fuzzy search mode - we'll filter results after query
                # For now, don't add title filter to SQL query
                # We'll apply fuzzy matching to results later
                pass
            else:
                # Standard exact search
                # Check if using + operator for multi-term search
                if '+' in search_text:
                    # Split by + and strip whitespace from each term
                    search_terms = [term.strip() for term in search_text.split('+') if term.strip()]

                    # Each term must be present (AND logic)
                    for term in search_terms:
                        query += " AND title LIKE ?"
                        params.append(f"%{term}%")
                else:
                    # Single term search
                    query += " AND title LIKE ?"
                    params.append(f"%{search_text}%")

        # Program number filter - supports comma-separated values
        if self.filter_program.get():
            program_filter = self.filter_program.get().strip()

            # Check if using comma-separated list
            if ',' in program_filter:
                # Split by comma and strip whitespace from each program number
                program_numbers = [prog.strip() for prog in program_filter.split(',') if prog.strip()]

                # Build OR condition for exact matches
                placeholders = ','.join('?' * len(program_numbers))
                query += f" AND program_number IN ({placeholders})"
                params.extend(program_numbers)
            else:
                # Single program number search
                # Use exact match if no wildcards, otherwise use LIKE
                if '*' in program_filter or '%' in program_filter or '_' in program_filter:
                    # Has wildcards - use LIKE (convert * to %)
                    wildcard_filter = program_filter.replace('*', '%')
                    query += " AND program_number LIKE ?"
                    params.append(wildcard_filter)
                else:
                    # Exact match - use = for PRIMARY KEY index optimization
                    query += " AND program_number = ?"
                    params.append(program_filter)
        
        # Type filter (multi-select)
        selected_types = self.filter_type.get_selected()
        if selected_types and len(selected_types) < len(self.filter_type.values):
            placeholders = ','.join('?' * len(selected_types))
            query += f" AND spacer_type IN ({placeholders})"
            params.extend(selected_types)

        # Material filter (multi-select)
        selected_materials = self.filter_material.get_selected()
        if selected_materials and len(selected_materials) < len(self.filter_material.values):
            placeholders = ','.join('?' * len(selected_materials))
            query += f" AND material IN ({placeholders})"
            params.extend(selected_materials)

        # Validation Status filter (multi-select)
        selected_statuses = self.filter_status.get_selected()
        if selected_statuses and len(selected_statuses) < len(self.filter_status.values):
            placeholders = ','.join('?' * len(selected_statuses))
            query += f" AND validation_status IN ({placeholders})"
            params.extend(selected_statuses)

        # Duplicate Type filter (multi-select)
        selected_dup_types = self.filter_dup_type.get_selected()
        if selected_dup_types and len(selected_dup_types) < len(self.filter_dup_type.values):
            # Handle "None" selection (files with no duplicate_type)
            if "None" in selected_dup_types:
                other_types = [t for t in selected_dup_types if t != "None"]
                if other_types:
                    placeholders = ','.join('?' * len(other_types))
                    query += f" AND (duplicate_type IN ({placeholders}) OR duplicate_type IS NULL)"
                    params.extend(other_types)
                else:
                    query += " AND duplicate_type IS NULL"
            else:
                placeholders = ','.join('?' * len(selected_dup_types))
                query += f" AND duplicate_type IN ({placeholders})"
                params.extend(selected_dup_types)

        # OD range
        if self.filter_od_min.get():
            query += " AND outer_diameter >= ?"
            params.append(float(self.filter_od_min.get()))
        if self.filter_od_max.get():
            query += " AND outer_diameter <= ?"
            params.append(float(self.filter_od_max.get()))
        
        # Thickness range
        if self.filter_thickness_min.get():
            query += " AND thickness >= ?"
            params.append(float(self.filter_thickness_min.get()))
        if self.filter_thickness_max.get():
            query += " AND thickness <= ?"
            params.append(float(self.filter_thickness_max.get()))
        
        # CB range
        if self.filter_cb_min.get():
            query += " AND center_bore >= ?"
            params.append(float(self.filter_cb_min.get()))
        if self.filter_cb_max.get():
            query += " AND center_bore <= ?"
            params.append(float(self.filter_cb_max.get()))

        # Hub Diameter range
        if self.filter_hub_dia_min.get():
            query += " AND hub_diameter >= ?"
            params.append(float(self.filter_hub_dia_min.get()))
        if self.filter_hub_dia_max.get():
            query += " AND hub_diameter <= ?"
            params.append(float(self.filter_hub_dia_max.get()))

        # Hub Height range
        if self.filter_hub_h_min.get():
            query += " AND hub_height >= ?"
            params.append(float(self.filter_hub_h_min.get()))
        if self.filter_hub_h_max.get():
            query += " AND hub_height <= ?"
            params.append(float(self.filter_hub_h_max.get()))

        # Step Diameter range
        if self.filter_step_d_min.get():
            query += " AND counter_bore_diameter >= ?"
            params.append(float(self.filter_step_d_min.get()))
        if self.filter_step_d_max.get():
            query += " AND counter_bore_diameter <= ?"
            params.append(float(self.filter_step_d_max.get()))

        # Error text filter — searches all error/warning columns including crash
        if self.filter_error_text.get():
            # Strip count suffix added by _update_error_filter_counts, e.g. " (14)"
            _raw_term = re.sub(r'\s*\(\d+\)$', '', self.filter_error_text.get())
            error_search = f"%{_raw_term}%"
            query += (
                " AND (validation_issues LIKE ? OR validation_warnings LIKE ?"
                " OR bore_warnings LIKE ? OR dimensional_issues LIKE ?"
                " OR tool_home_issues LIKE ? OR crash_issues LIKE ?"
                " OR crash_warnings LIKE ?)"
            )
            params.extend([error_search] * 7)

        # Date Imported filter
        if hasattr(self, 'filter_date_from') and self.filter_date_from.get():
            try:
                # Accept YYYY-MM-DD format and convert to ISO timestamp for comparison
                date_from = self.filter_date_from.get().strip()
                # Add time component to make it start of day
                query += " AND date_imported >= ?"
                params.append(f"{date_from}T00:00:00")
            except:
                pass  # Ignore invalid date format

        if hasattr(self, 'filter_date_to') and self.filter_date_to.get():
            try:
                # Accept YYYY-MM-DD format and convert to ISO timestamp for comparison
                date_to = self.filter_date_to.get().strip()
                # Add time component to make it end of day
                query += " AND date_imported <= ?"
                params.append(f"{date_to}T23:59:59")
            except:
                pass  # Ignore invalid date format

        # Crash Type filter
        if hasattr(self, 'filter_crash_type'):
            selected_crash_types = self.filter_crash_type.get_selected()
            if selected_crash_types and len(selected_crash_types) < len(self.filter_crash_type.values):
                # Build conditions based on selected crash types
                crash_conditions = []

                if "G00 Rapid to Z" in selected_crash_types:
                    crash_conditions.append("crash_issues LIKE '%G00 rapid to Z%'")

                if "Diagonal Rapid" in selected_crash_types:
                    crash_conditions.append("crash_issues LIKE '%diagonal%'")

                if "Z Before Tool Home" in selected_crash_types:
                    crash_conditions.append("crash_issues LIKE '%Z before G53%' OR crash_issues LIKE '%negative Z before tool home%'")

                if "Jaw Clearance" in selected_crash_types:
                    crash_conditions.append("crash_warnings LIKE '%jaw clearance%'")

                if "All Crashes" in selected_crash_types:
                    crash_conditions.append("(crash_issues IS NOT NULL AND crash_issues != 'null' AND crash_issues != '[]')")

                if crash_conditions:
                    query += f" AND ({' OR '.join(crash_conditions)})"

        # Missing file path filter
        if self.filter_missing_file_path.get():
            query += " AND (file_path IS NULL OR file_path = '')"

        query += " ORDER BY program_number"

        # Note: Duplicates filter is applied after query in the display logic
        # since it requires checking for duplicate filenames across all results

        # Execute query
        logger.debug(f"refresh_results: Executing query...")
        conn = None
        column_names = []
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute(query, params)
            results = cursor.fetchall()
            # Get column names for dynamic index lookup
            column_names = [desc[0] for desc in cursor.description] if cursor.description else []
            logger.debug(f"refresh_results: Query returned {len(results)} records")
        except Exception as e:
            logger.error(f"refresh_results: Query failed: {e}", exc_info=True)
            results = []
        finally:
            if conn:
                conn.close()

        # Helper function to get column index by name
        def get_col_idx(name, default=-1):
            try:
                return column_names.index(name)
            except ValueError:
                return default

        # Get dynamic column indices for tool_home, feasibility, and crash fields
        tool_home_status_idx = get_col_idx('tool_home_status')
        tool_home_issues_idx = get_col_idx('tool_home_issues')
        feasibility_status_idx = get_col_idx('feasibility_status')
        crash_issues_idx = get_col_idx('crash_issues')
        crash_warnings_idx = get_col_idx('crash_warnings')

        # Apply fuzzy search filter if enabled
        if hasattr(self, 'fuzzy_search_enabled') and self.fuzzy_search_enabled.get() and self.filter_title.get():
            search_text = self.filter_title.get().strip()
            logger.debug(f"Applying fuzzy search for: {search_text}")

            # Get program number and title column indices
            prog_idx = get_col_idx('program_number', 0)
            title_idx = get_col_idx('title', 1)

            # Build list of (program_number, title) for fuzzy search
            programs = [(r[prog_idx], r[title_idx]) for r in results if r[title_idx]]

            # Perform fuzzy search (if module available)
            if hasattr(self, 'fuzzy_search'):
                fuzzy_matches = self.fuzzy_search.search_programs(search_text, programs, limit=len(programs))

                # Create set of matching program numbers
                matching_progs = {prog for prog, title, score in fuzzy_matches}

                # Filter results to only include fuzzy matches
                results = [r for r in results if r[prog_idx] in matching_progs]
            logger.debug(f"Fuzzy search filtered to {len(results)} results")

        # Populate tree
        # Column indices (based on database schema):
        # 0:program_number, 1:title, 2:spacer_type, 3:outer_diameter, 4:thickness, 5:thickness_display,
        # 6:center_bore, 7:hub_height, 8:hub_diameter, 9:counter_bore_diameter, 10:counter_bore_depth,
        # 11:paired_program, 12:material, 13:notes, 14:date_created, 15:last_modified, 16:file_path,
        # 17:detection_confidence, 18:detection_method, 19:validation_status, ...

        # PERFORMANCE: Show loading message for large datasets
        if len(results) > 1000:
            if hasattr(self, 'results_label'):
                self.results_label.config(text=f"Loading {len(results)} programs... Please wait...")
            if hasattr(self, 'results_counter_label'):
                self.results_counter_label.config(text=f"Loading {len(results)} programs... Please wait...")
            self.root.update()

        # Build set of duplicate filenames (exact filenames that appear more than once)
        filename_counts = {}
        for row in results:
            if row[16]:  # file_path
                filename = os.path.basename(row[16]).lower()  # Case-insensitive
                filename_counts[filename] = filename_counts.get(filename, 0) + 1

        # Filenames that appear more than once are duplicates
        duplicate_filenames = {fn for fn, count in filename_counts.items() if count > 1}

        # Assign occurrence numbers to duplicates
        occurrence_tracker = {}
        filename_occurrences = {}  # Maps file_path to its occurrence number
        for row in results:
            if row[16]:  # file_path
                filename = os.path.basename(row[16]).lower()
                if filename in duplicate_filenames:
                    occurrence_tracker[filename] = occurrence_tracker.get(filename, 0) + 1
                    filename_occurrences[row[16]] = occurrence_tracker[filename]

        # Count status breakdown
        status_counts = {
            'CRASH_RISK': 0,
            'CRASH_WARNING': 0,
            'CRITICAL': 0,
            'TOOL_HOME_CRITICAL': 0,
            'SAFETY_ERROR': 0,
            'TOOL_ERROR': 0,
            'BORE_WARNING': 0,
            'TOOL_HOME_WARNING': 0,
            'DIMENSIONAL': 0,
            'TOOL_WARNING': 0,
            'WARNING': 0,
            'PASS': 0,
            'REPEAT': 0
        }

        # PERFORMANCE: Batch tree inserts to reduce UI redraws
        # Collect all items first, then insert in batches
        tree_items = []

        for row in results:
            program_number = row[0]
            # Check if this filename is a duplicate and get its occurrence number
            is_dup = ""
            dup_num = ""
            if row[16]:  # file_path
                filename = os.path.basename(row[16]).lower()
                if filename in duplicate_filenames:
                    dup_num = filename_occurrences.get(row[16], 1)
                    is_dup = f"({dup_num})"

            # Apply duplicates filter - skip non-duplicates if filter is checked
            if self.filter_duplicates.get() and not is_dup:
                continue

            title = row[1] if row[1] else "-"  # NEW: Title from G-code
            spacer_type = row[2]  # Shifted from row[1]
            od = f"{row[3]:.3f}" if row[3] else "-"  # Shifted from row[2]

            # Use thickness_display (row[5]) if available, otherwise fall back to formatted thickness (row[4])
            thick = row[5] if row[5] else (f"{row[4]:.3f}" if row[4] else "-")  # Shifted from row[4]/row[3]

            cb = f"{row[6]:.1f}" if row[6] else "-"  # Shifted from row[5]

            # Hub Height - only applicable for hub_centric
            if spacer_type == 'hub_centric':
                hub_h = f"{row[7]:.2f}" if row[7] else "-"  # Shifted from row[6]
            else:
                hub_h = "N/A"

            # Hub Diameter (OB) - only applicable for hub_centric
            if spacer_type == 'hub_centric':
                hub_d = f"{row[8]:.1f}" if row[8] else "-"  # Shifted from row[7]
            else:
                hub_d = "N/A"

            # Counter Bore - only applicable for STEP parts
            if spacer_type == 'step':
                cb_bore = f"{row[9]:.1f}" if row[9] else "-"  # Shifted from row[8]
            else:
                cb_bore = "N/A"

            # Step Depth - only applicable for STEP parts (row[10] = counter_bore_depth)
            if spacer_type == 'step':
                step_d = f"{row[10]:.2f}" if row[10] else "-"
            else:
                step_d = "N/A"

            material = row[12] if row[12] else "-"  # Shifted from row[11]
            filename = os.path.basename(row[16]) if row[16] else "-"  # Shifted from row[15]

            # Lathe (index 26)
            lathe = row[26] if len(row) > 26 and row[26] else "-"

            # Validation status (index 19 - validation_status)
            validation_status = row[19] if len(row) > 19 and row[19] else "N/A"  # Shifted from row[18]

            # Tool Home status (dynamic index)
            tool_home = "-"
            if tool_home_status_idx >= 0 and len(row) > tool_home_status_idx and row[tool_home_status_idx]:
                tool_home = row[tool_home_status_idx]

            # Feasibility status (dynamic index)
            feasibility_status = "-"
            if feasibility_status_idx >= 0 and len(row) > feasibility_status_idx and row[feasibility_status_idx]:
                feas_status = row[feasibility_status_idx]
                # Display with icon
                if feas_status == 'FEASIBLE':
                    feasibility_status = "✅ FEASIBLE"
                elif feas_status == 'NOT_FEASIBLE':
                    feasibility_status = "❌ NOT FEASIBLE"
                elif feas_status == 'UNKNOWN':
                    feasibility_status = "❓ UNKNOWN"
                else:
                    feasibility_status = feas_status

            # Extract warning details based on status type
            # PERFORMANCE FIX: json is already imported at top of file - removed redundant imports
            warning_details = "-"
            if validation_status == 'CRASH_RISK' and crash_issues_idx >= 0 and len(row) > crash_issues_idx and row[crash_issues_idx]:  # crash_issues
                # Parse CRASH RISK issues (highest priority - machine damage possible)
                try:
                    if isinstance(row[crash_issues_idx], str):
                        issues = json.loads(row[crash_issues_idx])
                    else:
                        issues = row[crash_issues_idx] if isinstance(row[crash_issues_idx], list) else []
                    warning_details = "; ".join(str(x) for x in issues[:2]) if issues else ""
                except:
                    try:
                        issues = [i.strip() for i in str(row[crash_issues_idx]).split('|') if i.strip()]
                        warning_details = "; ".join(issues[:2]) if issues else str(row[crash_issues_idx])[:100]
                    except:
                        warning_details = str(row[crash_issues_idx])[:100] if row[crash_issues_idx] else ""
            elif validation_status == 'CRASH_WARNING' and crash_warnings_idx >= 0 and len(row) > crash_warnings_idx and row[crash_warnings_idx]:  # crash_warnings
                # Parse CRASH WARNING issues
                try:
                    if isinstance(row[crash_warnings_idx], str):
                        warns = json.loads(row[crash_warnings_idx])
                    else:
                        warns = row[crash_warnings_idx] if isinstance(row[crash_warnings_idx], list) else []
                    warning_details = "; ".join(str(x) for x in warns[:2]) if warns else ""
                except:
                    try:
                        warns = [i.strip() for i in str(row[crash_warnings_idx]).split('|') if i.strip()]
                        warning_details = "; ".join(warns[:2]) if warns else str(row[crash_warnings_idx])[:100]
                    except:
                        warning_details = str(row[crash_warnings_idx])[:100] if row[crash_warnings_idx] else ""
            elif validation_status == 'CRITICAL' and len(row) > 20 and row[20]:  # validation_issues
                # Parse CRITICAL issues
                try:
                    if isinstance(row[20], str):
                        issues = json.loads(row[20])
                    else:
                        issues = row[20] if isinstance(row[20], list) else []
                    warning_details = "; ".join(str(x) for x in issues[:2]) if issues else ""
                except:
                    try:
                        issues = [i.strip() for i in str(row[20]).split('|') if i.strip()]
                        warning_details = "; ".join(issues[:2]) if issues else str(row[20])[:100]
                    except:
                        warning_details = str(row[20])[:100] if row[20] else ""
            elif validation_status == 'BORE_WARNING' and len(row) > 24 and row[24]:  # bore_warnings
                # Parse BORE warnings
                try:
                    if isinstance(row[24], str):
                        warns = json.loads(row[24])
                    else:
                        warns = row[24] if isinstance(row[24], list) else []
                    warning_details = "; ".join(str(x) for x in warns[:2]) if warns else ""
                except:
                    try:
                        warns = [i.strip() for i in str(row[24]).split('|') if i.strip()]
                        warning_details = "; ".join(warns[:2]) if warns else str(row[24])[:100]
                    except:
                        warning_details = str(row[24])[:100] if row[24] else ""
            elif validation_status == 'DIMENSIONAL' and len(row) > 25 and row[25]:  # dimensional_issues
                # Parse DIMENSIONAL issues
                try:
                    if isinstance(row[25], str):
                        dim_issues = json.loads(row[25])
                    else:
                        dim_issues = row[25] if isinstance(row[25], list) else []
                    warning_details = "; ".join(str(x) for x in dim_issues[:2]) if dim_issues else ""
                except:
                    try:
                        dim_issues = [i.strip() for i in str(row[25]).split('|') if i.strip()]
                        warning_details = "; ".join(dim_issues[:2]) if dim_issues else str(row[25])[:100]
                    except:
                        warning_details = str(row[25])[:100] if row[25] else ""
            elif validation_status == 'SAFETY_ERROR' and len(row) > 33 and row[33]:  # safety_blocks_issues
                # Parse SAFETY_ERROR issues
                try:
                    if isinstance(row[33], str):
                        issues = json.loads(row[33])
                    else:
                        issues = row[33] if isinstance(row[33], list) else []
                    warning_details = "; ".join(str(x) for x in issues[:2]) if issues else ""
                except:
                    try:
                        issues = [i.strip() for i in str(row[33]).split('|') if i.strip()]
                        warning_details = "; ".join(issues[:2]) if issues else str(row[33])[:100]
                    except:
                        warning_details = str(row[33])[:100] if row[33] else ""
            elif validation_status in ('TOOL_ERROR', 'TOOL_WARNING') and len(row) > 31 and row[31]:  # tool_validation_issues
                # Parse TOOL_ERROR and TOOL_WARNING issues
                try:
                    if isinstance(row[31], str):
                        issues = json.loads(row[31])
                    else:
                        issues = row[31] if isinstance(row[31], list) else []
                    warning_details = "; ".join(str(x) for x in issues[:2]) if issues else ""
                except:
                    try:
                        issues = [i.strip() for i in str(row[31]).split('|') if i.strip()]
                        warning_details = "; ".join(issues[:2]) if issues else str(row[31])[:100]
                    except:
                        warning_details = str(row[31])[:100] if row[31] else ""
            elif (validation_status in ('TOOL_HOME_CRITICAL', 'TOOL_HOME_WARNING') or tool_home in ('CRITICAL', 'WARNING')) and tool_home_issues_idx >= 0 and len(row) > tool_home_issues_idx and row[tool_home_issues_idx]:  # tool_home_issues
                # Parse TOOL_HOME issues (G53 Z position)
                # Check both validation_status and tool_home since tool home status is stored separately
                try:
                    if isinstance(row[tool_home_issues_idx], str):
                        issues = json.loads(row[tool_home_issues_idx])
                    else:
                        issues = row[tool_home_issues_idx] if isinstance(row[tool_home_issues_idx], list) else []
                    warning_details = "; ".join(str(x) for x in issues[:2]) if issues else ""
                except:
                    try:
                        issues = [i.strip() for i in str(row[tool_home_issues_idx]).split('|') if i.strip()]
                        warning_details = "; ".join(issues[:2]) if issues else str(row[tool_home_issues_idx])[:100]
                    except:
                        warning_details = str(row[tool_home_issues_idx])[:100] if row[tool_home_issues_idx] else ""
            elif validation_status == 'WARNING' and len(row) > 21 and row[21]:  # validation_warnings
                # Parse general WARNING
                try:
                    if isinstance(row[21], str):
                        warns = json.loads(row[21])
                    else:
                        warns = row[21] if isinstance(row[21], list) else []
                    warning_details = "; ".join(str(x) for x in warns[:2]) if warns else ""
                except:
                    try:
                        warns = [i.strip() for i in str(row[21]).split('|') if i.strip()]
                        warning_details = "; ".join(warns[:2]) if warns else str(row[21])[:100]
                    except:
                        warning_details = str(row[21])[:100] if row[21] else ""

            # Count status
            if validation_status in status_counts:
                status_counts[validation_status] += 1
            elif validation_status == 'ERROR':  # Old status name
                status_counts['CRITICAL'] += 1

            # Determine color tag (prioritized by severity)
            tag = ''
            if validation_status == 'CRASH_RISK':
                tag = 'crash_risk'  # BRIGHT RED/MAGENTA - Crash patterns detected (highest priority)
            elif validation_status == 'CRITICAL':
                tag = 'critical'  # RED - Critical errors (CB/OB way off)
            elif validation_status == 'TOOL_HOME_CRITICAL' or tool_home == 'CRITICAL':
                tag = 'tool_home_critical'  # DARK RED - G53 Z-16 or beyond (dangerous)
            elif validation_status == 'SAFETY_ERROR':
                tag = 'safety_error'  # DARK RED - Missing safety blocks
            elif validation_status == 'TOOL_ERROR':
                tag = 'tool_error'  # ORANGE-RED - Wrong/missing tools
            elif validation_status == 'CRASH_WARNING':
                tag = 'crash_warning'  # ORANGE - Crash warnings (jaw clearance, etc.)
            elif validation_status == 'BORE_WARNING':
                tag = 'bore_warning'  # ORANGE - Bore dimensions at tolerance limit
            elif validation_status == 'TOOL_HOME_WARNING' or tool_home == 'WARNING':
                tag = 'tool_home_warning'  # AMBER - G53 Z doesn't match thickness
            elif validation_status == 'DIMENSIONAL':
                tag = 'dimensional'  # PURPLE - P-code/thickness mismatches
            elif validation_status == 'TOOL_WARNING':
                tag = 'tool_warning'  # AMBER - Tool suggestions
            elif validation_status == 'WARNING':
                tag = 'warning'  # YELLOW - General warnings
            elif validation_status == 'REPEAT':
                tag = 'repeat'  # GRAY - Duplicate files
            elif validation_status == 'PASS':
                tag = 'pass'  # GREEN - Pass
            # Old status names for backward compatibility
            elif validation_status == 'ERROR':
                tag = 'critical'

            # PERFORMANCE: Collect items instead of inserting immediately
            tree_items.append((
                program_number, is_dup, title, spacer_type, lathe, od, thick, cb,
                hub_h, hub_d, cb_bore, step_d, material, tool_home, feasibility_status, validation_status, warning_details, filename,
                tag
            ))

        # PERFORMANCE: Batch insert all items at once - much faster than individual inserts
        for item in tree_items:
            *values, tag = item
            self.tree.insert("", "end", values=values, tags=(tag,))

        # Update count with status breakdown and view mode indicator
        # Add view mode label
        if view_mode == 'repository':
            view_label = "Repository"
        elif view_mode == 'external':
            view_label = "External"
        else:
            view_label = "All Programs"

        status_text = f"{view_label}: {len(results)} programs  |  "
        status_parts = []
        if status_counts['CRASH_RISK'] > 0:
            status_parts.append(f"⛔ CRASH: {status_counts['CRASH_RISK']}")
        if status_counts['CRASH_WARNING'] > 0:
            status_parts.append(f"⚠️ CRASH_WARN: {status_counts['CRASH_WARNING']}")
        if status_counts['CRITICAL'] > 0:
            status_parts.append(f"CRITICAL: {status_counts['CRITICAL']}")
        if status_counts['TOOL_HOME_CRITICAL'] > 0:
            status_parts.append(f"TOOL_HOME: {status_counts['TOOL_HOME_CRITICAL']}")
        if status_counts['SAFETY_ERROR'] > 0:
            status_parts.append(f"SAFETY: {status_counts['SAFETY_ERROR']}")
        if status_counts['TOOL_ERROR'] > 0:
            status_parts.append(f"TOOL_ERR: {status_counts['TOOL_ERROR']}")
        if status_counts['BORE_WARNING'] > 0:
            status_parts.append(f"BORE: {status_counts['BORE_WARNING']}")
        if status_counts['TOOL_HOME_WARNING'] > 0:
            status_parts.append(f"TOOL_HOME_WARN: {status_counts['TOOL_HOME_WARNING']}")
        if status_counts['DIMENSIONAL'] > 0:
            status_parts.append(f"DIM: {status_counts['DIMENSIONAL']}")
        if status_counts['TOOL_WARNING'] > 0:
            status_parts.append(f"TOOL_WARN: {status_counts['TOOL_WARNING']}")
        if status_counts['WARNING'] > 0:
            status_parts.append(f"WARN: {status_counts['WARNING']}")
        if status_counts['REPEAT'] > 0:
            status_parts.append(f"REPEAT: {status_counts['REPEAT']}")
        if status_counts['PASS'] > 0:
            status_parts.append(f"PASS: {status_counts['PASS']}")

        status_text += "  ".join(status_parts) if status_parts else "No status data"

        # Update both labels (one in filter section, one in results header)
        if hasattr(self, 'results_label'):
            self.results_label.config(text=status_text)
        if hasattr(self, 'results_counter_label'):
            self.results_counter_label.config(text=status_text)
        
    def clear_title_search(self):
        """Clear just the title search field"""
        self.filter_title.delete(0, tk.END)
        self.refresh_results()

    def clear_filters(self):
        """Clear all filter fields"""
        # PERFORMANCE: Check if any filters are actually set before clearing
        # This avoids unnecessary refresh if filters are already empty
        has_filters = (
            self.filter_title.get() or
            self.filter_program.get() or
            len(self.filter_type.get_selected()) < len(self.filter_type.values) or
            len(self.filter_material.get_selected()) < len(self.filter_material.values) or
            len(self.filter_status.get_selected()) < len(self.filter_status.values) or
            len(self.filter_dup_type.get_selected()) < len(self.filter_dup_type.values) or
            self.filter_od_min.get() or self.filter_od_max.get() or
            self.filter_thickness_min.get() or self.filter_thickness_max.get() or
            self.filter_cb_min.get() or self.filter_cb_max.get() or
            self.filter_hub_dia_min.get() or self.filter_hub_dia_max.get() or
            self.filter_hub_h_min.get() or self.filter_hub_h_max.get() or
            self.filter_step_d_min.get() or self.filter_step_d_max.get() or
            self.filter_error_text.get() or
            self.filter_duplicates.get() or
            self.filter_missing_file_path.get()
        )

        # Only clear and refresh if there are actually filters to clear
        if not has_filters:
            return

        self.filter_title.delete(0, tk.END)
        self.filter_program.delete(0, tk.END)
        self.filter_type.clear()
        self.filter_material.clear()
        self.filter_status.clear()
        self.filter_dup_type.clear()
        # All dimensional filters are now comboboxes - use .set("")
        self.filter_od_min.set("")
        self.filter_od_max.set("")
        self.filter_thickness_min.set("")
        self.filter_thickness_max.set("")
        self.filter_cb_min.set("")
        self.filter_cb_max.set("")
        self.filter_hub_dia_min.set("")
        self.filter_hub_dia_max.set("")
        self.filter_hub_h_min.set("")
        self.filter_hub_h_max.set("")
        self.filter_step_d_min.set("")
        self.filter_step_d_max.set("")
        self.filter_error_text.set("")
        self.filter_duplicates.set(False)
        self.filter_missing_file_path.set(False)
        self.refresh_results()
        
    def sort_column(self, col):
        """Sort treeview by column with toggle support"""
        # Initialize sort state if not exists
        if not hasattr(self, '_sort_state'):
            self._sort_state = {'column': None, 'reverse': False}

        # Toggle direction if same column, otherwise new sort
        if self._sort_state['column'] == col:
            self._sort_state['reverse'] = not self._sort_state['reverse']
        else:
            self._sort_state['column'] = col
            self._sort_state['reverse'] = False

        # Get all data
        children = self.tree.get_children('')

        def get_sort_value(child):
            """Get sortable value from column"""
            val = self.tree.set(child, col)
            # Handle empty/N/A values - put at end
            if val in ('-', 'N/A', ''):
                return (1, 0)  # (is_empty, value) - empty values sort last
            try:
                return (0, float(val))
            except:
                return (0, val.lower() if isinstance(val, str) else val)

        # Sort data
        data = sorted(
            children,
            key=get_sort_value,
            reverse=self._sort_state['reverse']
        )

        # Rearrange
        for index, child in enumerate(data):
            self.tree.move(child, '', index)

        # Update column header to show sort direction
        direction = "▼" if self._sort_state['reverse'] else "▲"
        for column in self.tree['columns']:
            # Reset all headers
            base_name = column.replace(" ▲", "").replace(" ▼", "")
            if column == col or column.replace(" ▲", "").replace(" ▼", "") == col:
                self.tree.heading(column, text=f"{base_name} {direction}",
                                 command=lambda c=base_name: self.sort_column(c))
            else:
                self.tree.heading(column, text=base_name,
                                 command=lambda c=base_name: self.sort_column(c))

    def apply_multi_sort(self):
        """Apply multi-column sorting based on dropdown selections"""
        # Get sort configurations
        sort_configs = []

        for col_combo, dir_combo in [(self.sort1_col, self.sort1_dir),
                                     (self.sort2_col, self.sort2_dir),
                                     (self.sort3_col, self.sort3_dir)]:
            col = col_combo.get()
            if col:  # Only add if column is selected
                reverse = dir_combo.get() == "High→Low"
                sort_configs.append((col, reverse))

        if not sort_configs:
            return

        # Get all children
        children = list(self.tree.get_children(''))

        def get_sort_value(child, column):
            """Get sortable value from column"""
            val = self.tree.set(child, column)
            # Handle empty/N/A values - put at end
            if val in ('-', 'N/A', ''):
                return (1, 0)  # (is_empty, value) - empty values sort last
            try:
                return (0, float(val))
            except:
                return (0, val.lower() if isinstance(val, str) else val)

        # Sort using stable sort - apply in reverse order of priority
        # (last sort first, then earlier sorts override while preserving order)
        sorted_children = children

        # Apply sorts in reverse order (last sort first, then override with earlier sorts)
        for col, reverse in reversed(sort_configs):
            sorted_children = sorted(
                sorted_children,
                key=lambda child: get_sort_value(child, col),
                reverse=reverse
            )

        # Rearrange
        for index, child in enumerate(sorted_children):
            self.tree.move(child, '', index)

    def open_file(self, event=None):
        """Open selected gcode file"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to open")
            return
        
        program_number = self.tree.item(selected[0])['values'][0]
        
        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()
        
        if result and result[0]:
            filepath = result[0]
            if os.path.exists(filepath):
                # AUTO-BACKUP: Create version archive before opening file for editing
                try:
                    # Only backup managed repository files (not external files)
                    if hasattr(self, 'repository_path') and self.repository_path in filepath:
                        from repository_manager import RepositoryManager
                        repo_mgr = RepositoryManager(self.db_path, self.repository_path)
                        backup_path = repo_mgr.archive_old_file(
                            old_file_path=filepath,
                            program_number=program_number,
                            reason='edit_backup'
                        )
                        if backup_path:
                            logger.info(f"Auto-backup created before editing: {backup_path}")
                except Exception as e:
                    # Don't block file opening if backup fails
                    logger.warning(f"Auto-backup failed for {program_number}: {e}")

                # Open in integrated editor
                from gui.gcode_text_editor import GCodeTextEditor
                from repository_manager import RepositoryManager

                # Get repository manager for backup
                repo_mgr = None
                if hasattr(self, 'repository_path') and self.repository_path in filepath:
                    repo_mgr = RepositoryManager(self.db_path, self.repository_path)

                # Launch integrated text editor
                editor = GCodeTextEditor(
                    parent=self.root,
                    file_path=filepath,
                    program_number=program_number,
                    on_save_callback=lambda: self.refresh_selected_file(),
                    bg_color=self.bg_color,
                    fg_color=self.fg_color,
                    repository_manager=repo_mgr
                )
            else:
                messagebox.showerror("File Not Found", f"File not found:\n{filepath}")
        else:
            messagebox.showerror("Error", "No file path in database")

    def show_toolpath_plotter(self, event=None):
        """Show toolpath plotter for selected program"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to visualize")
            return

        program_number = self.tree.item(selected[0])['values'][0]
        self.show_toolpath_plotter_for_program(program_number)

    def show_toolpath_plotter_for_program(self, program_number: str):
        """Show toolpath plotter for specific program"""
        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?",
                      (program_number,))
        result = cursor.fetchone()
        conn.close()

        if result and result[0]:
            filepath = result[0]
            if os.path.exists(filepath):
                from gui.gcode_toolpath_plotter import ToolpathPlotter
                plotter = ToolpathPlotter(
                    parent=self.root,
                    file_path=filepath,
                    program_number=program_number,
                    bg_color=self.bg_color,
                    fg_color=self.fg_color
                )
            else:
                messagebox.showerror("File Not Found", f"File not found:\n{filepath}")
        else:
            messagebox.showerror("Error", "No file path in database")

    def show_3d_spacer_model(self):
        """Render a 3D surface-of-revolution model for the selected spacer."""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program first")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT title, outer_diameter, thickness, center_bore, "
            "hub_height, hub_diameter, counter_bore_diameter, counter_bore_depth "
            "FROM programs WHERE program_number = ?",
            (program_number,)
        )
        row = cursor.fetchone()
        conn.close()

        if not row:
            messagebox.showerror("Error", "Program not found in database")
            return

        title, od, thickness, cb_mm, hub_h, hub_d_mm, cbd_mm, cbd_depth = row

        if not od or not thickness:
            messagebox.showwarning("Insufficient Data",
                                   "Part requires OD and thickness to render 3D model")
            return

        # Unit conversions (CB/hub diameters stored in mm, spacer dims in inches)
        od_in    = float(od)
        t_in     = float(thickness)
        cb_in    = float(cb_mm) / 25.4 if cb_mm else od_in * 0.35
        hub_h_in = float(hub_h) if hub_h else 0.0
        hub_d_in = float(hub_d_mm) / 25.4 if hub_d_mm else None
        cbd_in   = float(cbd_mm) / 25.4 if cbd_mm else None
        cbd_dep  = float(cbd_depth) if cbd_depth else None

        try:
            import numpy as np
            from matplotlib.figure import Figure
            from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
            from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 – registers '3d' projection
        except ImportError as exc:
            messagebox.showerror("Import Error",
                                 f"matplotlib / numpy required for 3D model:\n{exc}")
            return

        win = tk.Toplevel(self.root)
        win.title(f"3D Model — {program_number}")
        win.geometry("820x680")
        win.configure(bg=self.bg_color)

        fig = Figure(figsize=(8, 6.2), dpi=100, facecolor='#1a1a2e')
        ax  = fig.add_subplot(111, projection='3d')
        ax.set_facecolor('#16213e')

        theta = np.linspace(0, 2 * np.pi, 72, endpoint=True)

        body_color = '#4fc3f7'   # sky blue — main spacer body
        hub_color  = '#81c784'   # green    — protruding hub ring
        bore_color = '#ff8a65'   # orange   — counter-bore shelf

        def _cyl(r, z_bot, z_top, color, alpha=0.82):
            """Cylindrical wall surface."""
            z = np.array([z_bot, z_top])
            T, Z = np.meshgrid(theta, z)
            ax.plot_surface(r * np.cos(T), r * np.sin(T), Z,
                            color=color, alpha=alpha, linewidth=0, shade=True)

        def _disk(r_in, r_out, z, color, alpha=0.85):
            """Flat annular disk at height z."""
            r = np.linspace(r_in, r_out, 2)
            T, R = np.meshgrid(theta, r)
            ax.plot_surface(R * np.cos(T), R * np.sin(T), np.full_like(R, z),
                            color=color, alpha=alpha, linewidth=0, shade=True)

        r_out = od_in / 2.0
        r_in  = cb_in / 2.0

        # ── Main body ─────────────────────────────────────────────────────
        _cyl(r_out, 0.0, t_in, body_color)             # outer wall
        _cyl(r_in,  0.0, t_in, body_color, alpha=0.45) # inner bore wall
        _disk(r_in, r_out, t_in, body_color)            # top (wheel-side) face

        if hub_h_in > 0.0:
            r_hub = (hub_d_in / 2.0) if hub_d_in else (r_in + 0.20)
            hub_z = -hub_h_in
            _disk(r_hub, r_out, 0.0, body_color)        # bottom face (annular, hub takes center)
            _cyl(r_hub, hub_z, 0.0, hub_color)          # hub outer wall
            _cyl(r_in,  hub_z, 0.0, hub_color, alpha=0.40)  # hub bore wall
            _disk(r_in, r_hub, hub_z, hub_color)        # hub bottom face
            _disk(r_in, r_hub, 0.0,  hub_color)         # hub shoulder (meets body)
        else:
            _disk(r_in, r_out, 0.0, body_color)         # full flat bottom face

        # ── Counter-bore shelf (if present and geometrically sensible) ────
        if cbd_in and cbd_dep and cbd_in > r_in * 2 and cbd_in < r_out * 2:
            r_cbd     = cbd_in / 2.0
            z_cbd_bot = t_in - cbd_dep
            if 0.0 < z_cbd_bot < t_in:
                _cyl(r_cbd, z_cbd_bot, t_in, bore_color, alpha=0.60)
                _disk(r_in, r_cbd, z_cbd_bot, bore_color, alpha=0.70)

        # ── Labels and cosmetics ──────────────────────────────────────────
        ax.set_xlabel('X (in)', color='#cccccc', labelpad=8)
        ax.set_ylabel('Y (in)', color='#cccccc', labelpad=8)
        ax.set_zlabel('Z (in)', color='#cccccc', labelpad=8)
        ax.tick_params(colors='#aaaaaa', labelsize=7)
        for pane in (ax.xaxis.pane, ax.yaxis.pane, ax.zaxis.pane):
            pane.fill = False
            pane.set_edgecolor('#333355')
        ax.grid(True, color='#333355', linewidth=0.4)

        sub = f"OD={od_in}\"  T={t_in}\"  CB={cb_mm:.1f}mm"
        if hub_h_in > 0:
            sub += f"  Hub={hub_h_in}\""
        ax.set_title(f"{program_number}: {title or ''}\n{sub}",
                     color='white', pad=12, fontsize=9)

        canvas = FigureCanvasTkAgg(fig, master=win)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        toolbar_frame = tk.Frame(win, bg=self.bg_color)
        toolbar_frame.pack(fill=tk.X)
        NavigationToolbar2Tk(canvas, toolbar_frame).update()

    def refresh_selected_file(self, event=None):
        """Re-parse selected file and update database - useful after editing a file"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to refresh")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()

        if not result or not result[0]:
            conn.close()
            messagebox.showerror("Error", "No file path in database")
            return

        filepath = result[0]
        if not os.path.exists(filepath):
            conn.close()
            messagebox.showerror("File Not Found", f"File not found:\n{filepath}")
            return

        try:
            # Re-parse the file completely using parser directly
            # (GCodeParseResult has all fields including crash_issues, crash_warnings, etc.)
            parse_result = self.parser.parse_file(filepath)

            # Determine validation status - check ALL validation fields
            # Priority: CRASH_RISK > CRITICAL > TOOL_HOME_CRITICAL > CRASH_WARNING > BORE_WARNING > TOOL_HOME_WARNING > DIMENSIONAL > WARNING > PASS
            validation_status = 'PASS'
            status_details = []

            if parse_result.crash_issues:
                validation_status = "CRASH_RISK"
                status_details.append(f"⛔ {len(parse_result.crash_issues)} CRASH RISK(s)")
            elif parse_result.validation_issues:
                validation_status = "CRITICAL"
                status_details.append(f"❌ {len(parse_result.validation_issues)} Critical Issue(s)")
            elif parse_result.tool_home_status == "CRITICAL":
                validation_status = "TOOL_HOME_CRITICAL"
                status_details.append(f"❌ Tool Home Critical")
            elif parse_result.crash_warnings:
                validation_status = "CRASH_WARNING"
                status_details.append(f"⚠️ {len(parse_result.crash_warnings)} Crash Warning(s)")
            elif parse_result.bore_warnings:
                validation_status = "BORE_WARNING"
                status_details.append(f"⚠️ {len(parse_result.bore_warnings)} Bore Warning(s)")
            elif parse_result.tool_home_status == "WARNING":
                validation_status = "TOOL_HOME_WARNING"
                status_details.append(f"⚠️ Tool Home Warning")
            elif parse_result.dimensional_issues:
                validation_status = "DIMENSIONAL"
                status_details.append(f"⚠️ {len(parse_result.dimensional_issues)} Dimensional Issue(s)")
            elif parse_result.validation_warnings:
                validation_status = "WARNING"
                status_details.append(f"⚠️ {len(parse_result.validation_warnings)} Warning(s)")

            # If still PASS, confirm it
            if validation_status == 'PASS':
                status_details.append("✅ All Checks Passed")

            # Update database with ALL fields
            cursor.execute("""
                UPDATE programs SET
                    title = ?, spacer_type = ?, outer_diameter = ?, thickness = ?, thickness_display = ?,
                    center_bore = ?, hub_diameter = ?, hub_height = ?,
                    counter_bore_diameter = ?, counter_bore_depth = ?, material = ?,
                    lathe = ?, validation_status = ?, validation_issues = ?, validation_warnings = ?,
                    bore_warnings = ?, dimensional_issues = ?,
                    tool_home_status = ?, tool_home_issues = ?,
                    feasibility_status = ?, feasibility_issues = ?, feasibility_warnings = ?,
                    crash_issues = ?, crash_warnings = ?,
                    tools_used = ?, tool_sequence = ?,
                    cb_from_gcode = ?, ob_from_gcode = ?,
                    detection_confidence = ?, detection_method = ?,
                    last_modified = ?
                WHERE program_number = ?
            """, (
                parse_result.title, parse_result.spacer_type, parse_result.outer_diameter,
                parse_result.thickness, parse_result.thickness_display,
                parse_result.center_bore, parse_result.hub_diameter, parse_result.hub_height,
                parse_result.counter_bore_diameter, parse_result.counter_bore_depth,
                parse_result.material, parse_result.lathe, validation_status,
                json.dumps(parse_result.validation_issues) if parse_result.validation_issues else None,
                json.dumps(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                json.dumps(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                json.dumps(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                parse_result.tool_home_status,
                json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                parse_result.feasibility_status,
                json.dumps(parse_result.feasibility_issues) if parse_result.feasibility_issues else None,
                json.dumps(parse_result.feasibility_warnings) if parse_result.feasibility_warnings else None,
                json.dumps(parse_result.crash_issues) if parse_result.crash_issues else None,
                json.dumps(parse_result.crash_warnings) if parse_result.crash_warnings else None,
                json.dumps(parse_result.tools_used) if parse_result.tools_used else None,
                json.dumps(parse_result.tool_sequence) if parse_result.tool_sequence else None,
                parse_result.cb_from_gcode,
                parse_result.ob_from_gcode,
                parse_result.detection_confidence,
                parse_result.detection_method,
                datetime.now().isoformat(),
                program_number
            ))
            conn.commit()
            conn.close()

            # Refresh the display to show updated color coding
            self.refresh_results()

            # Open the details page so the user immediately sees the updated
            # validation results without needing an extra click
            self.view_details()

        except Exception as e:
            conn.close()
            messagebox.showerror("Error", f"Failed to refresh file:\n{str(e)}")

    # ============================================================================
    # CLIPBOARD OPERATIONS
    # ============================================================================

    def copy_program_number_to_clipboard(self):
        """Copy selected program number to clipboard"""
        selected = self.tree.selection()
        if not selected:
            return

        program_number = self.tree.item(selected[0])['values'][0]
        # Copy to clipboard (simple fallback without clipboard manager module)
        try:
            self.root.clipboard_clear()
            self.root.clipboard_append(str(program_number))
            self.root.update()
            logger.info(f"Copied program number to clipboard: {program_number}")
            # Optional: Show brief status message
            if hasattr(self, 'show_status_message'):
                self.root.after(0, lambda: self.show_status_message(f"Copied: {program_number}"))
        except Exception as e:
            logger.error(f"Failed to copy to clipboard: {e}")

    def copy_file_path_to_clipboard(self):
        """Copy selected file path to clipboard"""
        selected = self.tree.selection()
        if not selected:
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if result and result[0]:
            # Copy to clipboard (simple fallback)
            try:
                self.root.clipboard_clear()
                self.root.clipboard_append(result[0])
                self.root.update()
                logger.info(f"Copied file path to clipboard: {result[0]}")
                if hasattr(self, 'show_status_message'):
                    self.root.after(0, lambda: self.show_status_message(f"Copied file path"))
            except Exception as e:
                logger.error(f"Failed to copy to clipboard: {e}")
        else:
            messagebox.showwarning("No Path", "No file path available for this program")

    def open_file_location(self):
        """Open folder containing the file in Windows Explorer"""
        selected = self.tree.selection()
        if not selected:
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if result and result[0]:
            filepath = result[0]
            if os.path.exists(filepath):
                # Open folder and select file in Explorer
                try:
                    os.system(f'explorer /select,"{filepath}"')
                    logger.info(f"Opened file location: {filepath}")
                except Exception as e:
                    logger.error(f"Failed to open file location: {e}")
                    messagebox.showerror("Error", f"Failed to open file location:\n{str(e)}")
            else:
                # File doesn't exist, try to open the folder
                folder = os.path.dirname(filepath)
                if os.path.exists(folder):
                    try:
                        os.system(f'explorer "{folder}"')
                        messagebox.showinfo("File Not Found",
                                          f"File not found, but opened containing folder:\n{folder}")
                    except Exception as e:
                        logger.error(f"Failed to open folder: {e}")
                        messagebox.showerror("Error", f"Failed to open folder:\n{str(e)}")
                else:
                    messagebox.showerror("Path Not Found",
                                       f"Neither file nor folder exists:\n{filepath}")
        else:
            messagebox.showwarning("No Path", "No file path available for this program")

    def copy_full_details_to_clipboard(self):
        """Copy full program details to clipboard as formatted text"""
        selected = self.tree.selection()
        if not selected:
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get full details from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        column_names = [desc[0] for desc in cursor.description]
        conn.close()

        if result:
            # Build dictionary of program data
            program_data = {}
            for idx, col_name in enumerate(column_names):
                value = result[idx]
                # Skip internal fields and format others nicely
                if col_name not in ['id', 'validation_issues', 'bore_warnings', 'dimensional_issues', 'tool_home_issues', 'validation_warnings']:
                    program_data[col_name] = value if value is not None else ""

            # Copy to clipboard (simple fallback)
            try:
                # Format as text
                details_text = f"Program: {program_number}\n"
                for key, value in program_data.items():
                    details_text += f"{key}: {value}\n"

                self.root.clipboard_clear()
                self.root.clipboard_append(details_text)
                self.root.update()
                logger.info(f"Copied full details to clipboard: {program_number}")
                if hasattr(self, 'show_status_message'):
                    self.root.after(0, lambda: self.show_status_message(f"Copied details for {program_number}"))
            except Exception as e:
                logger.error(f"Failed to copy to clipboard: {e}")

    def copy_multiple_programs_to_clipboard(self):
        """Copy multiple selected programs as TSV (Excel-compatible)"""
        selected = self.tree.selection()
        if not selected:
            return

        # Get visible columns from tree
        columns = ["Program #", "Title", "Type", "Lathe", "OD", "Thick", "CB", "Status"]

        # Build list of row data
        rows = []
        for item_id in selected:
            values = self.tree.item(item_id)['values']
            if values:
                # Extract the columns we want (matching order from tree)
                row_data = {
                    "Program #": values[0] if len(values) > 0 else "",
                    "Title": values[2] if len(values) > 2 else "",
                    "Type": values[3] if len(values) > 3 else "",
                    "Lathe": values[4] if len(values) > 4 else "",
                    "OD": values[5] if len(values) > 5 else "",
                    "Thick": values[6] if len(values) > 6 else "",
                    "CB": values[7] if len(values) > 7 else "",
                    "Status": values[14] if len(values) > 14 else "",
                }
                rows.append(row_data)

        # Copy to clipboard as TSV (simple fallback)
        try:
            # Build TSV format
            tsv_text = "\t".join(columns) + "\n"
            for row in rows:
                tsv_text += "\t".join(str(row.get(col, "")) for col in columns) + "\n"

            self.root.clipboard_clear()
            self.root.clipboard_append(tsv_text)
            self.root.update()
            logger.info(f"Copied {len(rows)} programs to clipboard as TSV")
            if hasattr(self, 'show_status_message'):
                self.root.after(0, lambda: self.show_status_message(f"Copied {len(rows)} programs"))
        except Exception as e:
            logger.error(f"Failed to copy to clipboard: {e}")

    def show_status_message(self, message: str):
        """Show a brief status message (placeholder - can enhance with statusbar)"""
        # For now, just log it. Can add a status bar later if desired
        logger.info(f"Status: {message}")

    def correct_tool_home_positions(self):
        """Correct incorrect tool home Z-positions in files with warnings"""
        # Permission check
        if not self.require_permission('edit_files', 'correct tool home positions'):
            return

        # Get count of files with tool home warnings
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT COUNT(*)
            FROM programs
            WHERE tool_home_status IN ('WARNING', 'CRITICAL')
            AND tool_home_issues IS NOT NULL
            AND tool_home_issues != ''
        """)
        warning_count = cursor.fetchone()[0]

        cursor.execute("""
            SELECT COUNT(*)
            FROM programs
            WHERE tool_home_status = 'CRITICAL'
        """)
        critical_count = cursor.fetchone()[0]

        if warning_count == 0:
            conn.close()
            messagebox.showinfo("No Issues", "No files found with tool home warnings or critical issues")
            return

        # Ask user to confirm
        response = messagebox.askyesno(
            "Correct Tool Home Positions",
            f"This will correct tool home Z-positions in {warning_count} files:\n\n"
            f"  • {critical_count} CRITICAL (Z-16 or beyond)\n"
            f"  • {warning_count - critical_count} WARNING (incorrect Z for thickness)\n\n"
            f"Files will be modified based on part thickness:\n"
            f"  • ≤ 2.50\" thick → Z-13 or higher\n"
            f"  • 2.75\" - 3.75\" thick → Z-11 or higher\n"
            f"  • 4.00\" - 5.00\" thick → Z-9 or higher\n\n"
            f"Original files will be backed up with .bak extension.\n\n"
            f"Continue with correction?",
            icon='warning'
        )

        if not response:
            conn.close()
            return

        # Get all files with tool home issues
        cursor.execute("""
            SELECT program_number, file_path, thickness, tool_home_issues, tool_home_status
            FROM programs
            WHERE tool_home_status IN ('WARNING', 'CRITICAL')
            AND tool_home_issues IS NOT NULL
            AND tool_home_issues != ''
            AND file_path IS NOT NULL
            ORDER BY tool_home_status DESC, program_number
        """)

        files_to_fix = cursor.fetchall()
        conn.close()

        if not files_to_fix:
            messagebox.showinfo("No Files", "No files found with valid file paths to correct")
            return

        # Create progress dialog
        progress_win = tk.Toplevel(self.root)
        progress_win.title("Correcting Tool Home Positions")
        progress_win.geometry("600x400")
        progress_win.configure(bg=self.bg_color)
        progress_win.transient(self.root)
        progress_win.grab_set()

        tk.Label(progress_win, text="Correcting Tool Home Positions...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        progress_text = scrolledtext.ScrolledText(progress_win,
                                                  bg=self.input_bg,
                                                  fg=self.fg_color,
                                                  font=("Courier", 9),
                                                  height=20, width=70)
        progress_text.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

        progress_win.update()

        # Process each file
        corrected_count = 0
        skipped_count = 0
        error_count = 0

        for prog_num, file_path, thickness, issues_json, status in files_to_fix:
            try:
                if not os.path.exists(file_path):
                    progress_text.insert(tk.END, f"SKIP {prog_num}: File not found\n")
                    skipped_count += 1
                    progress_text.see(tk.END)
                    progress_win.update()
                    continue

                # Parse issues to determine expected Z
                if thickness is None:
                    progress_text.insert(tk.END, f"SKIP {prog_num}: No thickness data\n")
                    skipped_count += 1
                    progress_text.see(tk.END)
                    progress_win.update()
                    continue

                # Determine expected Z based on thickness
                if thickness <= 2.50:
                    expected_z = -13
                elif 2.75 <= thickness <= 3.75:
                    expected_z = -11
                elif 4.00 <= thickness <= 5.00:
                    expected_z = -9
                else:
                    progress_text.insert(tk.END, f"SKIP {prog_num}: Thickness {thickness}\" outside defined ranges\n")
                    skipped_count += 1
                    progress_text.see(tk.END)
                    progress_win.update()
                    continue

                # Read file content
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                # Create backup
                backup_path = file_path + '.bak'
                shutil.copy2(file_path, backup_path)

                # Find and replace G53 lines with incorrect Z
                lines = content.split('\n')
                modified = False
                changes = []

                g53_pattern = re.compile(r'(G53\s*X[\d.\-]*\s*Z)([\-\d.]+)', re.IGNORECASE)

                for i, line in enumerate(lines):
                    match = g53_pattern.search(line)
                    if match:
                        try:
                            current_z = float(match.group(2))

                            # Check if this Z needs correction
                            needs_correction = False

                            # Always fix Z-16 or beyond (CRITICAL)
                            if current_z <= -16:
                                needs_correction = True
                            # Fix if Z is below expected minimum
                            elif current_z < expected_z:
                                needs_correction = True

                            if needs_correction:
                                # Replace with expected Z
                                new_line = g53_pattern.sub(f'\\g<1>{int(expected_z)}', line)
                                lines[i] = new_line
                                modified = True
                                changes.append(f"  Line {i+1}: Z{int(current_z)} → Z{int(expected_z)}")
                        except ValueError:
                            continue

                if modified:
                    # Write corrected content
                    new_content = '\n'.join(lines)
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(new_content)

                    progress_text.insert(tk.END, f"FIXED {prog_num} ({thickness:.2f}\" → Z{int(expected_z)}): {len(changes)} line(s)\n")
                    for change in changes[:3]:  # Show first 3 changes
                        progress_text.insert(tk.END, f"{change}\n")
                    if len(changes) > 3:
                        progress_text.insert(tk.END, f"  ... and {len(changes)-3} more\n")

                    corrected_count += 1

                    # Re-parse and update database
                    try:
                        parse_result = self.parse_gcode_file(file_path)

                        validation_status = 'PASS'
                        if parse_result.crash_issues:
                            validation_status = "CRASH_RISK"
                        elif parse_result.validation_issues:
                            validation_status = "CRITICAL"
                        elif parse_result.tool_home_status == "CRITICAL":
                            validation_status = "TOOL_HOME_CRITICAL"
                        elif parse_result.crash_warnings:
                            validation_status = "CRASH_WARNING"
                        elif parse_result.bore_warnings:
                            validation_status = "BORE_WARNING"
                        elif parse_result.tool_home_status == "WARNING":
                            validation_status = "TOOL_HOME_WARNING"
                        elif parse_result.dimensional_issues:
                            validation_status = "DIMENSIONAL"
                        elif parse_result.validation_warnings:
                            validation_status = "WARNING"

                        conn = sqlite3.connect(self.db_path)
                        cursor = conn.cursor()
                        cursor.execute("""
                            UPDATE programs SET
                                validation_status = ?, tool_home_status = ?,
                                tool_home_issues = ?, last_modified = ?
                            WHERE program_number = ?
                        """, (
                            validation_status,
                            parse_result.tool_home_status,
                            json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                            datetime.now().isoformat(),
                            prog_num
                        ))
                        conn.commit()
                        conn.close()
                    except Exception as e:
                        progress_text.insert(tk.END, f"  WARNING: Database update failed: {str(e)}\n")
                else:
                    progress_text.insert(tk.END, f"SKIP {prog_num}: No changes needed\n")
                    skipped_count += 1

            except Exception as e:
                progress_text.insert(tk.END, f"ERROR {prog_num}: {str(e)}\n")
                error_count += 1

            progress_text.see(tk.END)
            progress_win.update()

        # Show summary
        progress_text.insert(tk.END, f"\n{'='*60}\n")
        progress_text.insert(tk.END, f"SUMMARY:\n")
        progress_text.insert(tk.END, f"  Files corrected: {corrected_count}\n")
        progress_text.insert(tk.END, f"  Files skipped: {skipped_count}\n")
        progress_text.insert(tk.END, f"  Errors: {error_count}\n")
        progress_text.insert(tk.END, f"  Total processed: {len(files_to_fix)}\n")
        progress_text.insert(tk.END, f"\nBackup files created with .bak extension\n")
        progress_text.see(tk.END)

        # Add Close button
        tk.Button(progress_win, text="Close",
                 command=lambda: [progress_win.destroy(), self.refresh_results()],
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=15).pack(pady=10)

        progress_win.grab_release()

    def create_program_copy(self):
        """Create a copy of selected program with a new program number for editing"""
        # Permission check
        if not self.require_permission('copy_files', 'create copies'):
            return

        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to copy")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get source file info from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT file_path, title, outer_diameter, round_size
            FROM programs WHERE program_number = ?
        """, (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "No file path found for this program")
            return

        source_path, title, od, round_size = result

        if not os.path.exists(source_path):
            messagebox.showerror("File Not Found", f"Source file not found:\n{source_path}")
            return

        # Determine round size for finding next available number
        rs = round_size if round_size else od

        # Create copy dialog
        copy_win = tk.Toplevel(self.root)
        copy_win.title("Create Program Copy")
        copy_win.geometry("500x350")
        copy_win.configure(bg=self.bg_color)
        copy_win.transient(self.root)
        copy_win.grab_set()

        # Center the window
        copy_win.update_idletasks()
        x = self.root.winfo_x() + (self.root.winfo_width() - 500) // 2
        y = self.root.winfo_y() + (self.root.winfo_height() - 350) // 2
        copy_win.geometry(f"+{x}+{y}")

        # Header
        tk.Label(copy_win, text="Create Program Copy",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=15)

        # Source info
        info_frame = tk.Frame(copy_win, bg=self.bg_color)
        info_frame.pack(fill=tk.X, padx=20, pady=5)

        tk.Label(info_frame, text=f"Source: {program_number}",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 11)).pack(anchor='w')
        tk.Label(info_frame, text=f"Title: {title or 'No title'}",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack(anchor='w')
        if rs:
            tk.Label(info_frame, text=f"Round Size: {rs}\"",
                    bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack(anchor='w')

        # Find next several available numbers
        available_nums = self.find_available_numbers(rs, count=5)
        next_num = available_nums[0] if available_nums else None
        suggested_name = f"o{next_num:05d}" if next_num else ""

        # New program number
        num_frame = tk.Frame(copy_win, bg=self.bg_color)
        num_frame.pack(fill=tk.X, padx=20, pady=15)

        tk.Label(num_frame, text="New Program Number:",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 11)).pack(anchor='w')

        # Entry row with quick-select buttons
        entry_row = tk.Frame(num_frame, bg=self.bg_color)
        entry_row.pack(fill=tk.X, pady=5)

        new_num_var = tk.StringVar(value=suggested_name)
        num_entry = tk.Entry(entry_row, textvariable=new_num_var,
                            bg=self.input_bg, fg=self.fg_color,
                            insertbackground=self.fg_color, font=("Arial", 12), width=15)
        num_entry.pack(side=tk.LEFT)

        # Availability indicator label
        avail_indicator = tk.Label(entry_row, text="", bg=self.bg_color, font=("Arial", 10))
        avail_indicator.pack(side=tk.LEFT, padx=10)

        # Create button reference to enable/disable
        create_btn_ref = [None]

        def check_availability(*args):
            """Check if entered program number is available"""
            entered = new_num_var.get().strip().lower()
            if not entered:
                avail_indicator.config(text="", fg=self.fg_color)
                if create_btn_ref[0]:
                    create_btn_ref[0].config(state=tk.DISABLED)
                return

            # Normalize format
            if not entered.startswith('o'):
                entered = 'o' + entered

            # Check if it's a valid format
            clean_num = entered.replace('o', '').replace('O', '')
            if not clean_num.isdigit():
                avail_indicator.config(text="Invalid format", fg="#FF6B6B")
                if create_btn_ref[0]:
                    create_btn_ref[0].config(state=tk.DISABLED)
                return

            # Check database
            try:
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM programs WHERE LOWER(program_number) = ?", (entered,))
                exists_db = cursor.fetchone()[0] > 0
                conn.close()

                # Also check if file exists in repository
                dest_filename = entered + '.nc'
                dest_path = os.path.join(self.repository_path, dest_filename)
                exists_file = os.path.exists(dest_path)

                if exists_db or exists_file:
                    avail_indicator.config(text="Already exists", fg="#FF6B6B")
                    if create_btn_ref[0]:
                        create_btn_ref[0].config(state=tk.DISABLED)
                else:
                    avail_indicator.config(text="Available", fg="#4CAF50")
                    if create_btn_ref[0]:
                        create_btn_ref[0].config(state=tk.NORMAL)
            except Exception as e:
                avail_indicator.config(text="Check failed", fg="#FF9800")

        # Bind to variable changes (with slight delay to avoid excessive checks)
        new_num_var.trace_add('write', lambda *args: copy_win.after(300, check_availability))

        # Initial check
        check_availability()

        # Available numbers section
        if available_nums:
            avail_frame = tk.Frame(num_frame, bg=self.bg_color)
            avail_frame.pack(fill=tk.X, pady=5)

            tk.Label(avail_frame, text=f"Available in {rs}\" range (click to select):",
                    bg=self.bg_color, fg="#888888", font=("Arial", 9)).pack(anchor='w')

            btn_row = tk.Frame(avail_frame, bg=self.bg_color)
            btn_row.pack(anchor='w', pady=3)

            def select_num(num):
                new_num_var.set(f"o{num:05d}")

            for num in available_nums:
                btn = tk.Button(btn_row, text=f"o{num:05d}",
                               command=lambda n=num: select_num(n),
                               bg=self.input_bg, fg=self.fg_color,
                               font=("Arial", 9), cursor="hand2",
                               relief=tk.GROOVE, padx=5)
                btn.pack(side=tk.LEFT, padx=2)

        # Options
        opt_frame = tk.Frame(copy_win, bg=self.bg_color)
        opt_frame.pack(fill=tk.X, padx=20, pady=10)

        open_after_var = tk.BooleanVar(value=True)
        tk.Checkbutton(opt_frame, text="Open file after creating copy",
                      variable=open_after_var,
                      bg=self.bg_color, fg=self.fg_color,
                      selectcolor=self.input_bg, activebackground=self.bg_color,
                      activeforeground=self.fg_color).pack(anchor='w')

        add_to_db_var = tk.BooleanVar(value=False)
        tk.Checkbutton(opt_frame, text="Add to database immediately (uncheck to add later)",
                      variable=add_to_db_var,
                      bg=self.bg_color, fg=self.fg_color,
                      selectcolor=self.input_bg, activebackground=self.bg_color,
                      activeforeground=self.fg_color).pack(anchor='w')

        # Status label
        status_var = tk.StringVar(value="")
        status_label = tk.Label(copy_win, textvariable=status_var,
                               bg=self.bg_color, fg="#FF6B6B", font=("Arial", 10))
        status_label.pack(pady=5)

        def do_copy():
            new_num = new_num_var.get().strip().lower()

            # Validate new number
            if not new_num:
                status_var.set("Please enter a new program number")
                return

            # Normalize format
            if not new_num.startswith('o'):
                new_num = 'o' + new_num

            # Check if number already exists
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM programs WHERE LOWER(program_number) = ?", (new_num,))
            exists = cursor.fetchone()[0] > 0
            conn.close()

            if exists:
                status_var.set(f"Program {new_num} already exists!")
                return

            # Create the copy
            try:
                # Read source file
                with open(source_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                # Update program number in content (first O##### line)
                new_num_digits = re.sub(r'[^0-9]', '', new_num)
                content = re.sub(r'^([Oo])(\d{4,5})', f'O{new_num_digits.zfill(5)}', content, count=1, flags=re.MULTILINE)

                # Determine destination path
                dest_filename = new_num + '.nc'
                dest_path = os.path.join(self.repository_path, dest_filename)

                # Check if file already exists
                if os.path.exists(dest_path):
                    status_var.set(f"File {dest_filename} already exists in repository!")
                    return

                # Write new file
                with open(dest_path, 'w', encoding='utf-8') as f:
                    f.write(content)

                # Add to database if requested
                if add_to_db_var.get():
                    self._import_single_file(dest_path)
                    self.refresh_results()

                copy_win.destroy()

                # Show success message
                msg = f"Created copy: {dest_filename}\nLocation: {dest_path}"
                if not add_to_db_var.get():
                    msg += "\n\nNote: File not added to database yet.\nImport it when you're done editing."
                messagebox.showinfo("Copy Created", msg)

                # Open file if requested
                if open_after_var.get():
                    if os.name == 'nt':
                        os.startfile(dest_path)
                    elif os.name == 'posix':
                        os.system(f'open "{dest_path}"' if sys.platform == 'darwin' else f'xdg-open "{dest_path}"')

            except Exception as e:
                status_var.set(f"Error: {str(e)}")
                logger.error(f"Error creating program copy: {e}", exc_info=True)

        # Buttons
        btn_frame = tk.Frame(copy_win, bg=self.bg_color)
        btn_frame.pack(pady=20)

        create_btn = tk.Button(btn_frame, text="Create Copy", command=do_copy,
                 bg="#4CAF50", fg="white", font=("Arial", 11),
                 width=12, cursor="hand2")
        create_btn.pack(side=tk.LEFT, padx=10)

        # Store reference for enable/disable
        create_btn_ref[0] = create_btn

        tk.Button(btn_frame, text="Cancel", command=copy_win.destroy,
                 bg="#666666", fg="white", font=("Arial", 11),
                 width=12, cursor="hand2").pack(side=tk.LEFT, padx=10)

        num_entry.focus_set()
        num_entry.select_range(0, tk.END)

        # Run initial availability check after button is created
        check_availability()

    def add_entry(self):
        """Add a new entry manually"""
        # Permission check
        if not self.require_permission('add_files', 'add entries'):
            return
        EditEntryWindow(self, None, self.refresh_results)

    def edit_entry(self):
        """Edit selected entry"""
        # Permission check
        if not self.require_permission('edit_files', 'edit entries'):
            return

        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to edit")
            return

        program_number = self.tree.item(selected[0])['values'][0]
        EditEntryWindow(self, program_number, self.refresh_results)
        
    def archive_program(self):
        """Archive selected program - moves file to archive and removes from database"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to archive")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "No file path found for this program in the database.")
            return

        file_path = result[0]

        if not os.path.exists(file_path):
            messagebox.showerror("Error", f"File not found: {file_path}")
            return

        # Check if already archived
        if 'archive' in file_path.lower():
            messagebox.showinfo("Already Archived", f"{program_number} is already in the archive.")
            return

        # Confirm archive
        if not messagebox.askyesno("Confirm Archive",
                                   f"Archive program {program_number}?\n\n"
                                   f"File: {os.path.basename(file_path)}\n\n"
                                   f"This will:\n"
                                   f"• Move the file to the archive folder\n"
                                   f"• Remove the entry from the database\n"
                                   f"• Create a versioned backup"):
            return

        try:
            # Import repository manager
            from repository_manager import RepositoryManager

            # Use self.repository_path if available, otherwise derive from file path
            if hasattr(self, 'repository_path') and self.repository_path:
                repo_path = self.repository_path
            else:
                # Derive repository path from database path
                repo_path = os.path.join(os.path.dirname(self.db_path), 'repository')

            repo_manager = RepositoryManager(self.db_path, repo_path)

            # Archive the file
            archive_path = repo_manager.archive_old_file(file_path, program_number, reason='manual')

            if archive_path:
                # Remove from database
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("DELETE FROM programs WHERE program_number = ?", (program_number,))
                conn.commit()
                conn.close()

                self.refresh_results()
                messagebox.showinfo("Archived",
                                   f"{program_number} archived successfully\n\n"
                                   f"Archive location:\n{archive_path}")

                # Log activity
                self.log_activity('archive_program', program_number, {
                    'original_path': file_path,
                    'archive_path': archive_path,
                    'reason': 'manual'
                })
            else:
                messagebox.showerror("Error", "Failed to archive file")

        except Exception as e:
            messagebox.showerror("Archive Error", f"Error archiving program:\n{str(e)}")

    def delete_entry(self):
        """Delete selected entry"""
        # Permission check
        if not self.require_permission('delete_files', 'delete entries'):
            return

        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to delete")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        if messagebox.askyesno("Confirm Delete",
                              f"Delete program {program_number}?\n\nThis will only remove the database entry, not the file."):

            # Safety check before delete (Phase 1)
            safe, level, msg = self._check_database_safety_before_write("delete_entry")
            if not safe:
                logger.info(f"Delete entry cancelled by safety check: {msg}")
                return

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM programs WHERE program_number = ?", (program_number,))
            conn.commit()
            conn.close()

            # Record successful write (Phase 1)
            self._record_database_write("delete_entry")

            self.refresh_results()
            messagebox.showinfo("Deleted", "Entry deleted successfully")
            
    def view_details(self):
        """View full details of selected entry"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to view")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get full record
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if result:
            DetailsWindow(self, result)

    def show_version_history_window(self):
        """Show version history window for selected program"""
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a program to view version history")
            return

        program_number = self.tree.item(selected[0])['values'][0]

        # Get file path for the program
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found for this program.")
            return

        file_path = result[0]

        # Open version history window
        VersionHistoryWindow(self.root, self, program_number, file_path)

    def export_csv(self):
        """Export database to Excel with separate sheets for each round size"""
        try:
            import openpyxl
        except ImportError:
            messagebox.showerror("Missing Library",
                "openpyxl is required for Excel export.\n\n"
                "Install it with:\npip install openpyxl")
            return

        from datetime import datetime
        default_filename = f"GCode_Programs_{datetime.now().strftime('%Y%m%d')}.xlsx"

        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            initialfile=default_filename,
            filetypes=[("Excel Workbook", "*.xlsx"), ("All files", "*.*")],
            title="Export to Excel - By Round Size"
        )

        if filepath:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Define organized column order - dimensions and key info only
            export_columns = [
                # Identity
                'program_number',
                'title',

                # Dimensions (sorted by OD, Type, CB, Thickness)
                'outer_diameter',
                'spacer_type',
                'center_bore',
                'thickness',
                'hub_diameter',
                'hub_height',
                'counter_bore_diameter',
                'counter_bore_depth',

                # Classification
                'material',
                'lathe',

                # Status (summary only)
                'validation_status',
                'detection_confidence',

                # Metadata
                'last_modified'
            ]

            # Build query with ordering: OD, Type, CB, Thickness
            # NULLS LAST ensures NULL values don't cause sorting issues
            columns_str = ', '.join(export_columns)
            cursor.execute(f"""
                SELECT {columns_str} FROM programs
                ORDER BY
                    CASE WHEN outer_diameter IS NULL THEN 1 ELSE 0 END,
                    outer_diameter,
                    spacer_type,
                    CASE WHEN center_bore IS NULL THEN 1 ELSE 0 END,
                    center_bore,
                    CASE WHEN thickness IS NULL THEN 1 ELSE 0 END,
                    thickness
            """)
            results = cursor.fetchall()

            # Create Excel workbook
            wb = openpyxl.Workbook()
            wb.remove(wb.active)  # Remove default sheet

            # Define standard round sizes
            round_sizes = [
                ('5.75"', 5.75),
                ('6.00"', 6.00),
                ('6.25"', 6.25),
                ('6.50"', 6.50),
                ('7.00"', 7.00),
                ('7.50"', 7.50),
                ('8.00"', 8.00),
                ('9.00"', 9.00),
                ('9.50"', 9.50),
                ('10.00"', 10.00),
                ('13.00"', 13.00),
            ]

            # Group programs by OD
            programs_by_od = {}
            for row in results:
                od = row[2]  # outer_diameter column (index 2: program_number, title, outer_diameter)
                if od not in programs_by_od:
                    programs_by_od[od] = []
                programs_by_od[od].append(row)

            # Create sheet for each round size
            for sheet_name, od_value in round_sizes:
                if od_value in programs_by_od:
                    ws = wb.create_sheet(title=sheet_name)
                    self._write_excel_sheet(ws, programs_by_od[od_value])

            # Create "Other Sizes" sheet for non-standard sizes
            other_ods = [od for od in programs_by_od.keys()
                        if od not in [size[1] for size in round_sizes]]
            if other_ods:
                ws = wb.create_sheet(title="Other Sizes")
                other_programs = []
                # Sort ODs, handling None values (put them last)
                sorted_ods = sorted([od for od in other_ods if od is not None])
                none_ods = [od for od in other_ods if od is None]
                for od in sorted_ods + none_ods:
                    other_programs.extend(programs_by_od[od])
                self._write_excel_sheet(ws, other_programs)

            # Save workbook
            wb.save(filepath)
            conn.close()

            total_sheets = len(wb.sheetnames)
            messagebox.showinfo("Export Complete",
                f"Exported {len(results)} records to {total_sheets} sheets:\n{filepath}")

    def _write_excel_sheet(self, ws, data):
        """Write data to an Excel sheet with formatting"""
        from openpyxl.styles import Font, PatternFill, Alignment

        # Header
        headers = [
            'Program #',
            'Title',
            'OD (in)',
            'Type',
            'CB (mm)',
            'Thickness (in)',
            'Hub (mm)',
            'Hub Height (in)',
            'Counterbore (mm)',
            'CB Depth (in)',
            'Material',
            'Lathe',
            'Status',
            'Confidence',
            'Last Modified'
        ]

        # Write header with formatting
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
            cell.font = Font(bold=True, color="FFFFFF")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # Write data
        for row_idx, row_data in enumerate(data, start=2):
            for col_idx, value in enumerate(row_data, start=1):
                cell = ws.cell(row=row_idx, column=col_idx)

                if value is None:
                    cell.value = ""
                elif isinstance(value, float):
                    # Format floats to 2 decimal places
                    cell.value = round(value, 2)
                    cell.number_format = '0.00'
                else:
                    cell.value = str(value)

        # Auto-adjust column widths
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)  # Cap at 50
            ws.column_dimensions[column_letter].width = adjusted_width

    def export_google_sheets(self):
        """Export database to Excel optimized for Google Sheets import"""
        try:
            import openpyxl
        except ImportError:
            messagebox.showerror("Missing Library",
                "openpyxl is required for Google Sheets export.\n\n"
                "Install it with:\npip install openpyxl")
            return

        from datetime import datetime
        default_filename = f"GCode_GoogleSheets_{datetime.now().strftime('%Y%m%d')}.xlsx"

        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            initialfile=default_filename,
            filetypes=[("Excel Workbook", "*.xlsx"), ("All files", "*.*")],
            title="Export for Google Sheets"
        )

        if filepath:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Define organized column order per user request:
            # Program Number, Round Size, Thickness (display), CB, OB, Hub Height, Hub D, CB Diam, CB Depth, Type, Title, Status, Warning Details
            # Use thickness_display to show mm when applicable
            # CB Depth shown in mm if title contains 'MM' for depth indication
            # Sort order: Round Size, Type, CB, Thickness
            cursor.execute("""
                SELECT
                    program_number, round_size, thickness_display, center_bore, hub_diameter,
                    hub_height, hub_diameter as hub_d_mm, counter_bore_diameter,
                    CASE
                        WHEN counter_bore_depth IS NOT NULL AND (title LIKE '%MM B/C%' OR title LIKE '%MM DEEP%' OR title LIKE '%MM STEP%')
                        THEN ROUND(counter_bore_depth * 25.4, 1)
                        ELSE counter_bore_depth
                    END as cb_depth_display,
                    spacer_type, title, validation_status,
                    COALESCE(tool_home_issues, '') || COALESCE(bore_warnings, '') || COALESCE(dimensional_issues, '') || COALESCE(validation_issues, '')
                FROM programs
                WHERE (is_deleted IS NULL OR is_deleted = 0)
                ORDER BY
                    CASE WHEN round_size IS NULL THEN 1 ELSE 0 END,
                    round_size,
                    CASE WHEN spacer_type IS NULL THEN 99 ELSE
                        CASE
                            WHEN LOWER(spacer_type) = 'standard' THEN 1
                            WHEN LOWER(spacer_type) = 'hub_centric' THEN 2
                            WHEN LOWER(spacer_type) = 'step' THEN 3
                            WHEN LOWER(spacer_type) LIKE '%steel%' THEN 4
                            WHEN LOWER(spacer_type) LIKE '%2pc%' THEN 5
                            ELSE 6
                        END
                    END,
                    CASE WHEN center_bore IS NULL THEN 1 ELSE 0 END,
                    center_bore,
                    CASE WHEN thickness IS NULL THEN 1 ELSE 0 END,
                    thickness
            """)
            results = cursor.fetchall()

            # Create Excel workbook
            wb = openpyxl.Workbook()
            wb.remove(wb.active)  # Remove default sheet

            # FIRST SHEET: All Programs together, sorted by Round Size, Type, Thickness, CB
            ws_all = wb.create_sheet(title="All Programs")
            self._write_google_sheet(ws_all, results)

            # Define standard round sizes for individual sheets (one sheet per size)
            round_size_groups = [
                ('5.75"', [5.75]),
                ('6.00"', [6.00]),
                ('6.25"', [6.25]),
                ('6.50"', [6.50]),
                ('7.00"', [7.00]),
                ('7.50"', [7.50]),
                ('8.00"', [8.00]),
                ('8.50"', [8.50]),
                ('9.50"', [9.50]),
                ('10.25"', [10.25]),
                ('10.50"', [10.50]),
                ('13.00"', [13.00]),
            ]

            # Group programs by round_size
            programs_by_round_size = {}
            for row in results:
                round_size = row[1]  # round_size is index 1 in new column order
                if round_size not in programs_by_round_size:
                    programs_by_round_size[round_size] = []
                programs_by_round_size[round_size].append(row)

            # Create sheet for each round size group
            for sheet_name, round_size_values in round_size_groups:
                group_programs = []
                for round_size_value in round_size_values:
                    if round_size_value in programs_by_round_size:
                        group_programs.extend(programs_by_round_size[round_size_value])

                if group_programs:
                    ws = wb.create_sheet(title=sheet_name)
                    self._write_google_sheet(ws, group_programs)

            # Create "Other Sizes" sheet for non-standard sizes
            all_standard_sizes = []
            for _, size_list in round_size_groups:
                all_standard_sizes.extend(size_list)

            other_sizes = [size for size in programs_by_round_size.keys()
                          if size not in all_standard_sizes]
            if other_sizes:
                ws = wb.create_sheet(title="Other Sizes")
                other_programs = []
                # Sort sizes, handling None values (put them last)
                sorted_sizes = sorted([size for size in other_sizes if size is not None])
                none_sizes = [size for size in other_sizes if size is None]
                for size in sorted_sizes + none_sizes:
                    other_programs.extend(programs_by_round_size[size])
                self._write_google_sheet(ws, other_programs)

            # Create LPN (Lot Program Number) Tracker Sheet - COMBINED (existing + available in gaps)
            self.create_lpn_tracker_sheet(wb)

            # Create Available Numbers Report - SEPARATE (compact summary by round size)
            self.create_available_numbers_sheet(wb)

            # Save workbook
            wb.save(filepath)
            conn.close()

            total_sheets = len(wb.sheetnames)
            messagebox.showinfo("Google Sheets Export Complete",
                f"Exported {len(results)} records to {total_sheets} sheets.\n\n"
                f"Sheets included:\n"
                f"• All Programs - Complete list sorted by round size\n"
                f"• LPN Tracker - Existing + available numbers in gaps (combined)\n"
                f"• Available Numbers - Compact summary of available ranges\n"
                f"• Individual round size sheets (5.75\", 6.0\", etc.)\n\n"
                f"To import to Google Sheets:\n"
                f"1. Go to sheets.google.com\n"
                f"2. File → Import → Upload\n"
                f"3. Select this file\n"
                f"4. Import location: Replace spreadsheet")

    def _write_google_sheet(self, ws, data):
        """Write data to an Excel sheet optimized for Google Sheets"""
        from openpyxl.styles import Font, PatternFill, Alignment

        # Header - columns per user request:
        # Program Number, Round Size, Thickness, CB, OB, Hub Height, Hub D (mm), CB Diam (mm), CB Depth (in), Type, Title, Status, Warning Details
        headers = [
            'Program #', 'Round Size', 'Thickness', 'CB (mm)', 'OB (mm)',
            'Hub Height', 'Hub D (mm)', 'CB Diam (mm)', 'CB Depth (in)',
            'Type', 'Title', 'Status', 'Warning Details'
        ]

        # Alternating row colors - light green and medium green
        light_green = PatternFill(start_color="E8F5E9", end_color="E8F5E9", fill_type="solid")
        medium_green = PatternFill(start_color="C8E6C9", end_color="C8E6C9", fill_type="solid")

        # Write header with Google Sheets-friendly formatting
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            # Google green color for headers
            cell.fill = PatternFill(start_color="34A853", end_color="34A853", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # Status column cleanup mapping
        status_display = {
            'OK': 'OK',
            'WARNING': 'Warning',
            'TOOL_HOME_WARNING': 'Tool Home Warning',
            'TOOL_HOME_CRITICAL': 'Tool Home Critical',
            'CB_OB_WARNING': 'CB/OB Warning',
            'MISMATCH': 'Mismatch',
            'ERROR': 'Error',
        }

        # Write data with alternating row colors
        for row_idx, row_data in enumerate(data, start=2):
            # Determine row fill color (alternating)
            row_fill = light_green if row_idx % 2 == 0 else medium_green
            for col_idx, value in enumerate(row_data, start=1):
                cell = ws.cell(row=row_idx, column=col_idx)

                # Clean up status column (column 12 now with added columns)
                if col_idx == 12 and value:
                    value = status_display.get(str(value), str(value))

                # Clean up warning details column (column 13 now with added columns) - parse JSON and format
                if col_idx == 13 and value:
                    try:
                        import json
                        # Value might be concatenated JSON arrays, try to parse
                        details = []
                        # Try to extract individual JSON arrays from concatenated string
                        raw = str(value)
                        if raw.startswith('['):
                            # Find all JSON arrays in the string
                            import re
                            json_arrays = re.findall(r'\[.*?\]', raw)
                            for arr in json_arrays:
                                try:
                                    items = json.loads(arr)
                                    if isinstance(items, list):
                                        details.extend(items)
                                except:
                                    pass
                        if details:
                            # Clean up and join, remove prefixes like "WARNING: "
                            cleaned = []
                            for d in details:
                                d = str(d).replace('WARNING: ', '').replace('CRITICAL: ', '').replace('REVIEW: ', '')
                                if d and d not in cleaned:
                                    cleaned.append(d)
                            value = '; '.join(cleaned[:3])  # Limit to first 3 issues
                        else:
                            value = ""
                    except:
                        value = ""

                if value is None:
                    cell.value = ""
                elif isinstance(value, float):
                    # Format floats to 2 decimal places
                    cell.value = round(value, 2)
                    cell.number_format = '0.00'
                else:
                    cell.value = str(value)

                # Apply alternating row fill color
                cell.fill = row_fill

        # Auto-adjust column widths (Google Sheets respects this)
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)  # Cap at 50
            ws.column_dimensions[column_letter].width = adjusted_width

    def create_lpn_tracker_sheet(self, wb):
        """
        Create LPN (Lot Program Number) tracking sheet - COMBINED VIEW.
        Shows existing programs + available numbers within gaps (smart detection).
        Prevents Excel crash by only showing relevant available numbers near gaps.
        """
        from openpyxl.styles import Font, PatternFill, Alignment
        import re

        ws = wb.create_sheet(title="LPN Tracker", index=1)  # Second sheet (after "All Programs")

        # Headers
        headers = ["Program #", "Round Size", "Title", "Type", "OD", "Thick",
                   "CB", "OB", "Status", "Last Modified"]

        # Header formatting
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34A853", end_color="34A853", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # Get all existing programs
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT program_number, round_size, title, spacer_type,
                   outer_diameter, thickness, center_bore, hub_diameter,
                   validation_status, last_modified
            FROM programs
            WHERE (is_deleted IS NULL OR is_deleted = 0)
            ORDER BY program_number
        """)
        existing_rows = cursor.fetchall()
        conn.close()

        # Build lookup and extract numeric IDs
        existing_programs = {}  # program_number -> data
        existing_nums = []  # sorted list of numeric IDs

        for row in existing_rows:
            prog_num = row[0]
            existing_programs[prog_num] = row

            # Extract numeric ID
            match = re.search(r'[oO]?(\d+)', str(prog_num))
            if match:
                existing_nums.append(int(match.group(1)))

        existing_nums.sort()

        # Get round size ranges
        round_size_ranges = self.get_round_size_ranges()

        # Build reverse lookup: number -> round size
        def get_round_size_for_number(num):
            for rs, (start, end, name) in round_size_ranges.items():
                if start <= num <= end:
                    return rs if rs > 0 else 0  # Free ranges return 0
            return None

        # Colors
        light_green = PatternFill(start_color="E8F5E9", end_color="E8F5E9", fill_type="solid")
        medium_green = PatternFill(start_color="C8E6C9", end_color="C8E6C9", fill_type="solid")
        light_gray = PatternFill(start_color="F5F5F5", end_color="F5F5F5", fill_type="solid")
        medium_gray = PatternFill(start_color="E0E0E0", end_color="E0E0E0", fill_type="solid")

        row_num = 2

        # Smart gap detection: Show numbers to include
        numbers_to_show = set()

        # 1. Add all existing numbers
        numbers_to_show.update(existing_nums)

        # 2. For each round size range, add first 20 and last 20 numbers (to show range boundaries)
        for round_size, (start_num, end_num, range_name) in round_size_ranges.items():
            # First 20
            for i in range(start_num, min(start_num + 20, end_num + 1)):
                numbers_to_show.add(i)
            # Last 20
            for i in range(max(end_num - 19, start_num), end_num + 1):
                numbers_to_show.add(i)

        # 3. Add numbers within gaps (±10 around each gap between consecutive existing programs)
        for i in range(len(existing_nums) - 1):
            current_num = existing_nums[i]
            next_num = existing_nums[i + 1]

            gap_size = next_num - current_num - 1

            if gap_size > 0:
                # Show gap: numbers around the gap
                if gap_size <= 20:
                    # Small gap: show all numbers in gap
                    for num in range(current_num + 1, next_num):
                        numbers_to_show.add(num)
                else:
                    # Large gap: show first 10 and last 10 of gap
                    for num in range(current_num + 1, min(current_num + 11, next_num)):
                        numbers_to_show.add(num)
                    for num in range(max(next_num - 10, current_num + 1), next_num):
                        numbers_to_show.add(num)

        # Convert to sorted list
        all_numbers = sorted(numbers_to_show)

        # Write rows
        for num in all_numbers:
            prog_num = f"o{num:05d}"
            round_size = get_round_size_for_number(num)

            if prog_num in existing_programs:
                # Existing program - show full details
                row = existing_programs[prog_num]
                row_fill = light_green if row_num % 2 == 0 else medium_green

                data = [
                    row[0],  # Program #
                    f"{row[1]:.2f}\"" if row[1] else "",  # Round Size
                    row[2],  # Title
                    row[3],  # Type
                    f"{row[4]:.2f}" if row[4] else "",  # OD
                    f"{row[5]:.3f}" if row[5] else "",  # Thick
                    f"{row[6]:.1f}" if row[6] else "",  # CB
                    f"{row[7]:.1f}" if row[7] else "",  # OB
                    row[8] or "OK",  # Status
                    row[9] or ""  # Last Modified
                ]
            else:
                # Available number - show as empty
                row_fill = light_gray if row_num % 2 == 0 else medium_gray

                data = [
                    prog_num,  # Program #
                    f"{round_size:.2f}\"" if round_size and round_size > 0 else "",  # Round Size
                    "—",  # No title
                    "—",  # No type
                    "",  # No OD
                    "",  # No thickness
                    "",  # No CB
                    "",  # No OB
                    "AVAILABLE",  # Status
                    ""  # No last modified
                ]

            # Write row
            for col_idx, value in enumerate(data, start=1):
                cell = ws.cell(row=row_num, column=col_idx, value=value)
                cell.fill = row_fill

                # Gray text for available numbers
                if data[8] == "AVAILABLE":
                    cell.font = Font(color="808080")

            row_num += 1

        # Auto-size columns
        for column in ws.columns:
            max_length = 0
            column_letter = column[0].column_letter
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column_letter].width = adjusted_width

    def create_available_numbers_sheet(self, wb):
        """
        Create Available Numbers Report - SEPARATE SHEET.
        Shows summary of available numbers grouped by round size with compact ranges.
        """
        from openpyxl.styles import Font, PatternFill, Alignment
        import re

        ws = wb.create_sheet(title="Available Numbers", index=2)  # Third sheet

        # Title row
        title_cell = ws.cell(row=1, column=1, value="AVAILABLE PROGRAM NUMBERS REPORT")
        title_cell.font = Font(bold=True, size=14, color="FFFFFF")
        title_cell.fill = PatternFill(start_color="1976D2", end_color="1976D2", fill_type="solid")
        ws.merge_cells('A1:E1')

        # Headers
        headers = ["Round Size", "Range", "Used Count", "Available Count", "Available Ranges"]
        for col, header in enumerate(headers, start=1):
            cell = ws.cell(row=3, column=col, value=header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="34A853", end_color="34A853", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # Get all existing programs
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT program_number
            FROM programs
            WHERE (is_deleted IS NULL OR is_deleted = 0)
            ORDER BY program_number
        """)
        existing_rows = cursor.fetchall()
        conn.close()

        # Extract numeric IDs
        existing_nums = set()
        for row in existing_rows:
            prog_num = row[0]
            match = re.search(r'[oO]?(\d+)', str(prog_num))
            if match:
                existing_nums.add(int(match.group(1)))

        # Get round size ranges
        round_size_ranges = self.get_round_size_ranges()

        # Helper function to format consecutive numbers as ranges
        def format_ranges(numbers):
            """Convert list of numbers to compact range strings"""
            if not numbers:
                return "None"

            numbers = sorted(numbers)
            ranges = []
            start = numbers[0]
            prev = numbers[0]

            for num in numbers[1:]:
                if num == prev + 1:
                    # Continue range
                    prev = num
                else:
                    # End current range
                    if start == prev:
                        ranges.append(f"o{start:05d}")
                    else:
                        ranges.append(f"o{start:05d}-o{prev:05d}")
                    start = num
                    prev = num

            # Add final range
            if start == prev:
                ranges.append(f"o{start:05d}")
            else:
                ranges.append(f"o{start:05d}-o{prev:05d}")

            # Limit to first 10 ranges to prevent cell overflow
            if len(ranges) > 10:
                return ", ".join(ranges[:10]) + f" ... ({len(ranges)-10} more)"
            else:
                return ", ".join(ranges)

        # Colors
        light_blue = PatternFill(start_color="E3F2FD", end_color="E3F2FD", fill_type="solid")
        medium_blue = PatternFill(start_color="BBDEFB", end_color="BBDEFB", fill_type="solid")

        row_num = 4

        # Process each round size range
        for round_size, (start_num, end_num, range_name) in sorted(round_size_ranges.items()):
            # Find used and available numbers in this range
            used_in_range = [n for n in existing_nums if start_num <= n <= end_num]
            available_in_range = [n for n in range(start_num, end_num + 1) if n not in existing_nums]

            used_count = len(used_in_range)
            available_count = len(available_in_range)
            total_count = end_num - start_num + 1

            # Format round size display
            if round_size > 0:
                round_size_display = f"{round_size:.2f}\""
            elif round_size == 0:
                round_size_display = "FREE 1"
            else:
                round_size_display = "FREE 2"

            # Format range
            range_display = f"o{start_num:05d} - o{end_num:05d}"

            # Format available ranges
            available_ranges_display = format_ranges(available_in_range)

            # Row fill
            row_fill = light_blue if row_num % 2 == 0 else medium_blue

            data = [
                round_size_display,
                range_display,
                f"{used_count} / {total_count}",
                available_count,
                available_ranges_display
            ]

            # Write row
            for col_idx, value in enumerate(data, start=1):
                cell = ws.cell(row=row_num, column=col_idx, value=value)
                cell.fill = row_fill
                cell.alignment = Alignment(horizontal="left", vertical="top", wrap_text=True)

            row_num += 1

        # Summary row
        ws.cell(row=row_num + 1, column=1, value="TOTAL:").font = Font(bold=True)
        total_used = len(existing_nums)
        ws.cell(row=row_num + 1, column=3, value=f"{total_used}").font = Font(bold=True)

        # Calculate total available in all defined ranges
        total_in_ranges = sum(end - start + 1 for _, (start, end, _) in round_size_ranges.items())
        total_available = total_in_ranges - total_used
        ws.cell(row=row_num + 1, column=4, value=f"{total_available}").font = Font(bold=True)

        # Auto-size columns
        ws.column_dimensions['A'].width = 15
        ws.column_dimensions['B'].width = 25
        ws.column_dimensions['C'].width = 15
        ws.column_dimensions['D'].width = 18
        ws.column_dimensions['E'].width = 60  # Wide for ranges

        # Set row heights for wrapped text
        for row in range(4, row_num):
            ws.row_dimensions[row].height = 30

    def export_unused_numbers(self):
        """Export program numbers with two sheets: All Programs (in order) and Unused Numbers"""
        import csv

        # Get round size ranges for reference
        round_size_ranges = self.get_round_size_ranges()

        # Build reverse lookup: program number -> round size
        def get_round_size_for_number(num):
            for rs, (start, end, name) in round_size_ranges.items():
                if start <= num <= end:
                    if rs > 0:
                        return rs
                    elif rs == 0:
                        return "FREE"
                    else:
                        return "FREE2"
            return ""

        # Get all existing program data from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT program_number, outer_diameter, thickness, thickness_display,
                   center_bore, hub_diameter, hub_height, counter_bore_depth, spacer_type
            FROM programs
        """)

        # Build lookup of existing programs
        existing_programs = {}  # num -> (program_number, od, thickness, cb, ob, hub_depth, piece_type)
        for row in cursor.fetchall():
            prog_num, od, thickness, thickness_display, cb, ob, hub_h, cb_depth, stype = row
            # Extract numeric part
            match = re.search(r'[oO]?(\d+)', str(prog_num))
            if match:
                num = int(match.group(1))
                # Determine piece type
                if stype:
                    stype_upper = stype.upper()
                    if '2PC' in stype_upper:
                        piece_type = '2PC'
                    elif 'STEEL' in stype_upper:
                        piece_type = 'STEEL'
                    elif 'STEP' in stype_upper:
                        piece_type = 'STEP'
                    else:
                        piece_type = 'STD'
                else:
                    piece_type = 'STD'

                # Hub/Step depth (use hub_height for HC, counter_bore_depth for STEP)
                hub_step = hub_h if hub_h else cb_depth if cb_depth else ''

                # Use thickness_display if available, otherwise thickness value
                thick_val = thickness_display if thickness_display else (thickness if thickness else '')

                existing_programs[num] = (prog_num, od, thick_val, cb, ob, hub_step, piece_type)
        conn.close()

        # Ask user for save location
        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            filetypes=[("Excel files", "*.xlsx"), ("CSV files", "*.csv"), ("All files", "*.*")],
            title="Export Program Numbers"
        )

        if not filepath:
            return

        # Check if user wants Excel or CSV
        if filepath.endswith('.xlsx'):
            self._export_unused_numbers_excel(filepath, existing_programs, get_round_size_for_number)
        else:
            self._export_unused_numbers_csv(filepath, existing_programs, get_round_size_for_number)

    def _export_unused_numbers_excel(self, filepath, existing_programs, get_round_size_for_number):
        """Export to Excel with two sheets"""
        try:
            import openpyxl
            from openpyxl.styles import Font, PatternFill, Alignment
            from openpyxl.worksheet.datavalidation import DataValidation
        except ImportError:
            messagebox.showerror("Missing Module",
                               "openpyxl is required for Excel export.\n\n"
                               "Install with: pip install openpyxl\n\n"
                               "Falling back to CSV export.")
            csv_path = filepath.replace('.xlsx', '.csv')
            self._export_unused_numbers_csv(csv_path, existing_programs, get_round_size_for_number)
            return

        wb = openpyxl.Workbook()

        # Sheet 1: All Programs (in order)
        ws1 = wb.active
        ws1.title = "All Programs"

        # Headers: A=Program#, B=Round Size, C=Thickness, D=CB, E=OB, F=Hub/Step Depth, G=Type
        headers = ["Program #", "Round Size", "Thickness", "CB", "OB", "Hub/Step Depth", "Type"]
        for col, header in enumerate(headers, 1):
            cell = ws1.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.font = Font(bold=True, color="FFFFFF")

        # Define range to export (skip 0, start from 1)
        # Use the round size ranges to determine which numbers to include
        ranges_to_export = []
        round_size_ranges = self.get_round_size_ranges()
        for rs, (start, end, name) in sorted(round_size_ranges.items(), key=lambda x: x[1][0]):
            ranges_to_export.append((start, end))

        # Green fill for available
        green_fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")
        green_font = Font(color="006100")

        row_num = 2
        total_available = 0

        for range_start, range_end in ranges_to_export:
            for num in range(range_start, range_end + 1):
                prog_str = f"o{num:05d}"
                round_size = get_round_size_for_number(num)

                if num in existing_programs:
                    # Existing program - show details
                    prog_num, od, thick_val, cb, ob, hub_step, piece_type = existing_programs[num]
                    ws1.cell(row=row_num, column=1, value=prog_num)
                    ws1.cell(row=row_num, column=2, value=od if od else round_size)
                    ws1.cell(row=row_num, column=3, value=thick_val if thick_val else '')
                    ws1.cell(row=row_num, column=4, value=round(cb, 1) if cb else '')
                    ws1.cell(row=row_num, column=5, value=round(ob, 1) if ob else '')
                    ws1.cell(row=row_num, column=6, value=hub_step if hub_step else '')
                    ws1.cell(row=row_num, column=7, value=piece_type)
                else:
                    # Available - mark as available with green
                    ws1.cell(row=row_num, column=1, value=prog_str)
                    for col in range(2, 8):
                        cell = ws1.cell(row=row_num, column=col, value="AVAILABLE")
                        cell.fill = green_fill
                        cell.font = green_font
                    total_available += 1

                row_num += 1

        # Auto-width columns
        for col in range(1, 8):
            ws1.column_dimensions[openpyxl.utils.get_column_letter(col)].width = 15

        # Sheet 2: Unused Numbers Only
        ws2 = wb.create_sheet("Unused Numbers")

        # Headers: A=Program#, B=Round Size, C=Range, D=Date Added, E=Status, F=Notes
        headers2 = ["Program #", "Round Size", "Range", "Date Added", "Status", "Notes"]
        for col, header in enumerate(headers2, 1):
            cell = ws2.cell(row=1, column=col, value=header)
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.font = Font(bold=True, color="FFFFFF")

        row_num = 2
        for range_start, range_end in ranges_to_export:
            for num in range(range_start, range_end + 1):
                if num not in existing_programs:
                    prog_str = f"o{num:05d}"
                    round_size = get_round_size_for_number(num)
                    range_name = f"o{range_start:05d}-o{range_end:05d}"

                    ws2.cell(row=row_num, column=1, value=prog_str)
                    ws2.cell(row=row_num, column=2, value=round_size)
                    ws2.cell(row=row_num, column=3, value=range_name)
                    ws2.cell(row=row_num, column=4, value='')  # Date Added - blank
                    ws2.cell(row=row_num, column=5, value='Unused')  # Status - default to Unused
                    ws2.cell(row=row_num, column=6, value='')  # Notes - blank

                    row_num += 1

        # Apply dropdown validation to entire Status column at once (much faster)
        if row_num > 2:
            status_dropdown = DataValidation(
                type="list",
                formula1='"Unused,Created,Added,Issue"',
                allow_blank=True
            )
            status_dropdown.error = "Please select from the list"
            status_dropdown.errorTitle = "Invalid Status"
            # Apply to range E2:E{last_row}
            status_dropdown.add(f"E2:E{row_num - 1}")
            ws2.add_data_validation(status_dropdown)

        # Auto-width columns
        col_widths = [12, 12, 18, 12, 12, 30]  # Program#, Round Size, Range, Date Added, Status, Notes
        for col, width in enumerate(col_widths, 1):
            ws2.column_dimensions[openpyxl.utils.get_column_letter(col)].width = width

        # Save
        try:
            wb.save(filepath)
            messagebox.showinfo(
                "Export Complete",
                f"Exported to:\n{filepath}\n\n"
                f"Sheet 1 'All Programs': All program numbers in order\n"
                f"Sheet 2 'Unused Numbers': {total_available:,} available numbers\n\n"
                f"Available numbers are highlighted in green."
            )
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to save Excel file:\n{str(e)}")

    def _export_unused_numbers_csv(self, filepath, existing_programs, get_round_size_for_number):
        """Export to CSV (single file with all programs)"""
        import csv

        round_size_ranges = self.get_round_size_ranges()
        ranges_to_export = []
        for rs, (start, end, name) in sorted(round_size_ranges.items(), key=lambda x: x[1][0]):
            ranges_to_export.append((start, end))

        total_available = 0

        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(["Program #", "Round Size", "Thickness", "CB", "OB", "Hub/Step Depth", "Type"])

            for range_start, range_end in ranges_to_export:
                for num in range(range_start, range_end + 1):
                    prog_str = f"o{num:05d}"
                    round_size = get_round_size_for_number(num)

                    if num in existing_programs:
                        prog_num, od, thick_val, cb, ob, hub_step, piece_type = existing_programs[num]
                        writer.writerow([
                            prog_num,
                            od if od else round_size,
                            thick_val if thick_val else '',
                            round(cb, 1) if cb else '',
                            round(ob, 1) if ob else '',
                            hub_step if hub_step else '',
                            piece_type
                        ])
                    else:
                        writer.writerow([prog_str, "AVAILABLE", "AVAILABLE", "AVAILABLE", "AVAILABLE", "AVAILABLE", "AVAILABLE"])
                        total_available += 1

        messagebox.showinfo(
            "Export Complete",
            f"Exported to:\n{filepath}\n\n"
            f"Total available numbers: {total_available:,}\n\n"
            f"For Excel with multiple sheets, save as .xlsx"
        )

    def find_and_mark_repeats(self):
        """Enhanced duplicate detection with parent/child relationships and classification"""
        import uuid
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Finding & Classifying Duplicates...")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Analyzing database...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get all files from database with full info
        cursor.execute('''
            SELECT program_number, title, spacer_type, outer_diameter, thickness,
                   center_bore, hub_height, hub_diameter, counter_bore_diameter,
                   counter_bore_depth, last_modified, file_path, detection_confidence,
                   validation_status, date_created
            FROM programs
        ''')
        all_files = cursor.fetchall()

        progress_text.insert(tk.END, f"Found {len(all_files)} total files in database.\n")
        progress_text.insert(tk.END, f"Classifying duplicates...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        # Build filename and content maps
        filename_map = {}  # filename -> list of files
        content_map = {}   # (title+dims) -> list of files

        for file_data in all_files:
            prog_num, title, stype, od, thick, cb, hub_h, hub_d, cb_d, cb_dep, modified, fpath, confidence, val_status, created = file_data

            filename = os.path.basename(fpath).lower() if fpath else ""

            # Add to filename map
            if filename:
                if filename not in filename_map:
                    filename_map[filename] = []
                filename_map[filename].append(file_data)

            # Create content key
            content_key = (
                title.strip().upper() if title else "",
                stype,
                round(od, 3) if od else None,
                round(thick, 3) if thick else None,
                round(cb, 3) if cb else None,
                round(hub_h, 3) if hub_h else None,
                round(hub_d, 3) if hub_d else None,
                round(cb_d, 3) if cb_d else None,
                round(cb_dep, 3) if cb_dep else None
            )

            if content_key not in content_map:
                content_map[content_key] = []
            content_map[content_key].append(file_data)

        # Classify duplicates
        solid_dups = 0
        name_collisions = 0
        content_dups = 0

        # Process SOLID DUPLICATES (same filename AND same content)
        for filename, files in filename_map.items():
            if len(files) > 1:
                # Check if they also have same content
                first_content = (files[0][1], files[0][2], files[0][3], files[0][4], files[0][5])
                all_same_content = all(
                    (f[1], f[2], f[3], f[4], f[5]) == first_content for f in files
                )

                if all_same_content:
                    # SOLID DUPLICATE - same filename, same content
                    group_id = str(uuid.uuid4())[:8]

                    # Choose parent: oldest file with best validation
                    def sort_key(f):
                        # Priority: 1) Validation status, 2) Confidence, 3) Oldest date
                        val_priority = {'PASS': 0, 'WARNING': 1, 'DIMENSIONAL': 2, 'BORE_WARNING': 3, 'CRITICAL': 4, 'REPEAT': 5}
                        conf_priority = {'HIGH': 0, 'MEDIUM': 1, 'LOW': 2}
                        date = f[14] if f[14] else f[10] if f[10] else '9999-12-31'  # created or modified
                        return (val_priority.get(f[13], 9), conf_priority.get(f[12], 9), date)

                    sorted_files = sorted(files, key=sort_key)
                    parent = sorted_files[0]
                    children = sorted_files[1:]

                    progress_text.insert(tk.END, f"SOLID DUP: {filename}\n")
                    progress_text.insert(tk.END, f"  ✓ Parent: {parent[0]} (oldest with best validation)\n")

                    # Mark children as REPEAT
                    for child in children:
                        cursor.execute('''
                            UPDATE programs
                            SET validation_status = 'REPEAT',
                                duplicate_type = 'SOLID',
                                parent_file = ?,
                                duplicate_group = ?
                            WHERE program_number = ?
                        ''', (parent[0], group_id, child[0]))
                        progress_text.insert(tk.END, f"  ✗ Child: {child[0]}\n")
                        solid_dups += 1

                    progress_text.insert(tk.END, "\n")
                    progress_text.see(tk.END)
                    self.root.update()
                else:
                    # NAME COLLISION - same filename, different content
                    group_id = str(uuid.uuid4())[:8]
                    progress_text.insert(tk.END, f"NAME COLLISION: {filename}\n")
                    for f in files:
                        cursor.execute('''
                            UPDATE programs
                            SET duplicate_type = 'NAME_COLLISION',
                                duplicate_group = ?
                            WHERE program_number = ?
                        ''', (group_id, f[0]))
                        progress_text.insert(tk.END, f"  ! {f[0]} - Different content, needs rename\n")
                        name_collisions += 1
                    progress_text.insert(tk.END, "\n")
                    progress_text.see(tk.END)
                    self.root.update()

        # Process CONTENT DUPLICATES (same content, different filenames)
        for content_key, files in content_map.items():
            if len(files) > 1:
                # Get unique filenames in this group
                filenames = set(os.path.basename(f[11]).lower() if f[11] else "" for f in files)

                if len(filenames) > 1:  # Different filenames but same content
                    group_id = str(uuid.uuid4())[:8]

                    # Choose parent: oldest file with best validation
                    def sort_key(f):
                        val_priority = {'PASS': 0, 'WARNING': 1, 'DIMENSIONAL': 2, 'BORE_WARNING': 3, 'CRITICAL': 4, 'REPEAT': 5}
                        conf_priority = {'HIGH': 0, 'MEDIUM': 1, 'LOW': 2}
                        date = f[14] if f[14] else f[10] if f[10] else '9999-12-31'
                        return (val_priority.get(f[13], 9), conf_priority.get(f[12], 9), date)

                    sorted_files = sorted(files, key=sort_key)
                    parent = sorted_files[0]
                    children = sorted_files[1:]

                    progress_text.insert(tk.END, f"CONTENT DUP: {content_key[0][:50]}\n")
                    progress_text.insert(tk.END, f"  ✓ Parent: {parent[0]} (oldest with best validation)\n")

                    for child in children:
                        cursor.execute('''
                            UPDATE programs
                            SET validation_status = 'REPEAT',
                                duplicate_type = 'CONTENT_DUP',
                                parent_file = ?,
                                duplicate_group = ?
                            WHERE program_number = ?
                        ''', (parent[0], group_id, child[0]))
                        progress_text.insert(tk.END, f"  ✗ Child: {child[0]}\n")
                        content_dups += 1

                    progress_text.insert(tk.END, "\n")
                    progress_text.see(tk.END)
                    self.root.update()

        conn.commit()
        conn.close()

        # Show results
        progress_label.config(text="Complete!")
        progress_text.insert(tk.END, f"{'='*70}\n")
        progress_text.insert(tk.END, f"SOLID Duplicates (same file+content): {solid_dups}\n")
        progress_text.insert(tk.END, f"NAME Collisions (same name, diff content): {name_collisions}\n")
        progress_text.insert(tk.END, f"CONTENT Duplicates (diff name, same content): {content_dups}\n")
        progress_text.insert(tk.END, f"\nTotal duplicates found: {solid_dups + name_collisions + content_dups}\n")
        progress_text.see(tk.END)

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def delete_duplicates(self):
        """Delete all duplicate files (REPEAT status) keeping only parent files"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Count duplicates to be deleted
        cursor.execute("""
            SELECT COUNT(*) FROM programs
            WHERE validation_status = 'REPEAT'
        """)
        dup_count = cursor.fetchone()[0]

        if dup_count == 0:
            conn.close()
            messagebox.showinfo("No Duplicates",
                "No duplicate files found.\n\n"
                "Use 'Find Repeats' first to identify duplicates.")
            return

        # Get details about what will be deleted
        cursor.execute("""
            SELECT program_number, duplicate_type, parent_file
            FROM programs
            WHERE validation_status = 'REPEAT'
            ORDER BY duplicate_type, parent_file
        """)
        duplicates = cursor.fetchall()
        conn.close()

        # Confirmation dialog
        result = messagebox.askyesno(
            "Delete All Duplicates",
            f"This will DELETE {dup_count} duplicate record(s) from the DATABASE.\n\n"
            f"✓ Parent files (best versions) will be KEPT\n"
            f"✗ Child files (duplicates) will be DELETED\n\n"
            f"⚠️  The actual files on disk will NOT be deleted.\n"
            f"⚠️  Only database records will be removed.\n\n"
            f"Do you want to continue?",
            icon='warning'
        )

        if not result:
            return

        # Second confirmation - type "DELETE DUPLICATES"
        confirm_window = tk.Toplevel(self.root)
        confirm_window.title("Final Confirmation")
        confirm_window.geometry("500x250")
        confirm_window.configure(bg=self.bg_color)
        confirm_window.transient(self.root)
        confirm_window.grab_set()

        tk.Label(confirm_window,
                text=f"⚠️  You are about to delete {dup_count} duplicate records",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        tk.Label(confirm_window,
                text='Type "DELETE DUPLICATES" to confirm:',
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=10)

        confirm_entry = tk.Entry(confirm_window, bg=self.input_bg, fg=self.fg_color,
                                font=("Arial", 12), width=25)
        confirm_entry.pack(pady=10)
        confirm_entry.focus()

        confirmed = [False]

        def check_confirmation():
            if confirm_entry.get() == "DELETE DUPLICATES":
                confirmed[0] = True
                confirm_window.destroy()
            else:
                messagebox.showerror("Invalid", 'You must type "DELETE DUPLICATES" exactly to confirm.')

        def cancel_delete():
            confirm_window.destroy()

        btn_frame = tk.Frame(confirm_window, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="Confirm", command=check_confirmation,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=10).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Cancel", command=cancel_delete,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=10).pack(side=tk.LEFT, padx=5)

        # Bind Enter key to confirm
        confirm_entry.bind('<Return>', lambda e: check_confirmation())

        # Wait for window to close
        self.root.wait_window(confirm_window)

        if not confirmed[0]:
            return

        # Safety check before delete (Phase 1)
        safe, level, msg = self._check_database_safety_before_write("delete_duplicates")
        if not safe:
            logger.info(f"Delete duplicates cancelled by safety check: {msg}")
            messagebox.showinfo("Operation Cancelled", "Delete operation cancelled by safety check.")
            return

        # Create database backup before deleting
        if not self.backup_database():
            messagebox.showerror("Backup Failed",
                "Database backup failed. Delete operation canceled for safety.\n\n"
                "Please check the error and try again.")
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Deleting Duplicates")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window,
                text="Deleting duplicate records...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                  bg=self.input_bg, fg=self.fg_color,
                                                  font=("Courier", 9),
                                                  wrap=tk.WORD)
        progress_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Group duplicates by type for reporting
        by_type = {}
        for prog_num, dup_type, parent in duplicates:
            if dup_type not in by_type:
                by_type[dup_type] = []
            by_type[dup_type].append((prog_num, parent))

        # Show what's being deleted
        progress_text.insert(tk.END, f"Deleting {dup_count} duplicate records:\n\n")

        for dup_type, items in by_type.items():
            progress_text.insert(tk.END, f"--- {dup_type or 'Unknown Type'} ({len(items)} records) ---\n")
            for prog_num, parent in items[:10]:  # Show first 10
                progress_text.insert(tk.END, f"  DELETE: {prog_num} (parent: {parent or 'N/A'})\n")
            if len(items) > 10:
                progress_text.insert(tk.END, f"  ... and {len(items) - 10} more\n")
            progress_text.insert(tk.END, "\n")
            self.root.update()

        # Delete from database
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            cursor.execute("""
                DELETE FROM programs
                WHERE validation_status = 'REPEAT'
            """)

            deleted_count = cursor.rowcount
            conn.commit()
            conn.close()

            # Record successful write (Phase 1)
            self._record_database_write("delete_duplicates")

            progress_text.insert(tk.END, f"{'='*60}\n")
            progress_text.insert(tk.END, f"✓ Successfully deleted {deleted_count} duplicate record(s)\n")
            progress_text.insert(tk.END, f"✓ Parent files have been preserved\n")
            progress_text.insert(tk.END, f"⚠️  Files on disk were NOT deleted\n")

            # Refresh the display
            self.refresh_filter_values()
            self.refresh_results()

        except Exception as e:
            progress_text.insert(tk.END, f"\n\n❌ ERROR: {str(e)}\n")
            messagebox.showerror("Error", f"An error occurred:\n{str(e)}")

        # Add close button
        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

        # Refresh the display
        self.refresh_results()

    def compare_files(self):
        """Compare selected files side-by-side with difference highlighting"""
        # Get selected items from treeview
        selected_items = self.tree.selection()

        if len(selected_items) < 2:
            messagebox.showwarning("Selection Required",
                "Please select 2 or more files to compare.\n\n"
                "Hold Ctrl and click to select multiple files.")
            return

        if len(selected_items) > 4:
            result = messagebox.askyesno("Many Files Selected",
                f"You selected {len(selected_items)} files.\n\n"
                f"Comparing many files may be difficult to view.\n\n"
                f"Continue anyway?")
            if not result:
                return

        # Extract program numbers
        program_numbers = []
        for item in selected_items:
            values = self.tree.item(item)['values']
            if values:
                program_numbers.append(values[0])

        # Get file details from database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        placeholders = ','.join('?' * len(program_numbers))
        cursor.execute(f'''
            SELECT program_number, title, file_path, spacer_type, outer_diameter, thickness,
                   center_bore, hub_height, hub_diameter, counter_bore_diameter,
                   counter_bore_depth, validation_status, detection_confidence,
                   duplicate_type, parent_file, last_modified, date_created
            FROM programs
            WHERE program_number IN ({placeholders})
        ''', program_numbers)

        files_data = cursor.fetchall()
        conn.close()

        if len(files_data) < 2:
            messagebox.showerror("Error", "Could not retrieve file information from database.")
            return

        # Open comparison window
        FileComparisonWindow(self.root, files_data, self.bg_color, self.fg_color,
                           self.input_bg, self.button_bg, self.refresh_results, self)

    def compare_2pc_files(self, stud, lug, stud_path, lug_path):
        """Compare 2PC STUD and LUG files with hub/counter bore highlighting"""
        import difflib

        # Read file contents
        try:
            with open(stud_path, 'r', encoding='utf-8', errors='ignore') as f:
                stud_lines = f.readlines()
        except:
            messagebox.showerror("Error", f"Failed to read STUD file: {stud_path}")
            return

        try:
            with open(lug_path, 'r', encoding='utf-8', errors='ignore') as f:
                lug_lines = f.readlines()
        except:
            messagebox.showerror("Error", f"Failed to read LUG file: {lug_path}")
            return

        # Create comparison window
        comp_win = tk.Toplevel(self.root)
        comp_win.title(f"2PC Comparison: {stud['program_number']} (STUD) + {lug['program_number']} (LUG)")
        comp_win.geometry("1600x900")
        comp_win.configure(bg=self.bg_color)

        # Header with key dimensions
        header_frame = tk.Frame(comp_win, bg=self.bg_color)
        header_frame.pack(fill=tk.X, padx=10, pady=10)

        # Calculate clearance
        clearance_mm = lug.get('counter_bore_diameter', 0) - stud.get('hub_diameter', 0)
        clearance_color = "#4CAF50" if 0.025 <= clearance_mm <= 2.0 else "#FF9800"

        tk.Label(header_frame,
                text=f"STUD: {stud['program_number']}  |  Hub: {stud.get('hub_diameter', 'N/A'):.1f}mm × {stud.get('hub_height', 'N/A'):.2f}\"",
                bg=self.bg_color, fg="#2196F3", font=("Arial", 11, "bold")).grid(row=0, column=0, padx=10, sticky='w')

        tk.Label(header_frame,
                text=f"Clearance: {clearance_mm:.2f}mm",
                bg=self.bg_color, fg=clearance_color, font=("Arial", 11, "bold")).grid(row=0, column=1, padx=20)

        tk.Label(header_frame,
                text=f"LUG: {lug['program_number']}  |  Counter Bore: {lug.get('counter_bore_diameter', 'N/A'):.1f}mm × {lug.get('counter_bore_depth', 'N/A'):.2f}\"",
                bg=self.bg_color, fg="#FF5722", font=("Arial", 11, "bold")).grid(row=0, column=2, padx=10, sticky='e')

        # Main comparison frame
        main_frame = tk.Frame(comp_win, bg=self.bg_color)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Create two text widgets side by side
        left_frame = tk.Frame(main_frame, bg=self.bg_color)
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))

        tk.Label(left_frame, text=f"STUD: {stud['program_number']}",
                bg=self.bg_color, fg="#2196F3", font=("Courier", 10, "bold")).pack()

        stud_text = tk.Text(left_frame, wrap=tk.NONE, bg=self.input_bg, fg=self.fg_color,
                           font=("Courier", 9), height=40)
        stud_scroll_y = tk.Scrollbar(left_frame, orient=tk.VERTICAL, command=stud_text.yview)
        stud_scroll_x = tk.Scrollbar(left_frame, orient=tk.HORIZONTAL, command=stud_text.xview)
        stud_text.configure(yscrollcommand=stud_scroll_y.set, xscrollcommand=stud_scroll_x.set)

        stud_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        stud_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        stud_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        right_frame = tk.Frame(main_frame, bg=self.bg_color)
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))

        tk.Label(right_frame, text=f"LUG: {lug['program_number']}",
                bg=self.bg_color, fg="#FF5722", font=("Courier", 10, "bold")).pack()

        lug_text = tk.Text(right_frame, wrap=tk.NONE, bg=self.input_bg, fg=self.fg_color,
                          font=("Courier", 9), height=40)
        lug_scroll_y = tk.Scrollbar(right_frame, orient=tk.VERTICAL, command=lug_text.yview)
        lug_scroll_x = tk.Scrollbar(right_frame, orient=tk.HORIZONTAL, command=lug_text.xview)
        lug_text.configure(yscrollcommand=lug_scroll_y.set, xscrollcommand=lug_scroll_x.set)

        lug_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        lug_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        lug_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Configure tags for highlighting
        stud_text.tag_configure("hub_highlight", background="#1976D2", foreground="white")  # Blue - 2PC hub
        stud_text.tag_configure("large_hub_highlight", background="#4CAF50", foreground="white")  # Green - 0.5" hub
        stud_text.tag_configure("other_step_highlight", background="#FF9800", foreground="white")  # Orange - other steps
        lug_text.tag_configure("cb_highlight", background="#D32F2F", foreground="white")  # Red - 2PC counter bore
        lug_text.tag_configure("other_step_highlight", background="#FF9800", foreground="white")  # Orange - other steps

        import re

        # Track if we're in OP2 for STUD (to distinguish 0.5" hub from 0.25" hub)
        in_op2_stud = False

        # Insert STUD content and highlight dimensions
        for i, line in enumerate(stud_lines, 1):
            stud_text.insert(tk.END, line)

            line_upper = line.upper()

            # Track OP2 boundary
            if any(marker in line_upper for marker in ['OP2', 'OP 2', 'FLIP PART', 'FLIP', 'SIDE 2']):
                in_op2_stud = True

            # Highlight T303 turning operations
            if 'T303' in line_upper or 'TURN TOOL' in line_upper:
                stud_text.tag_add("hub_highlight", f"{i}.0", f"{i}.end")
            elif in_op2_stud and 'X' in line_upper and 'Z' in line_upper:
                # Check X and Z values for hub detection
                x_match = re.search(r'X\s*([\d.]+)', line, re.IGNORECASE)
                z_match = re.search(r'Z\s*-?\s*([\d.]+)', line, re.IGNORECASE)

                if x_match:
                    x_val = float(x_match.group(1))

                    # Check for 2PC mating hub (0.20-0.30" height)
                    if stud.get('hub_diameter') and stud.get('hub_height'):
                        hub_dia_inches = stud.get('hub_diameter') / 25.4
                        hub_height = stud.get('hub_height')

                        # 2PC mating hub (small hub ~0.25")
                        if 0.20 <= hub_height <= 0.30:
                            if abs(x_val - hub_dia_inches) < 0.1:
                                stud_text.tag_add("hub_highlight", f"{i}.0", f"{i}.end")
                        # Large hub for mounting (0.45-0.60")
                        elif 0.45 <= hub_height <= 0.60:
                            if abs(x_val - hub_dia_inches) < 0.1:
                                stud_text.tag_add("large_hub_highlight", f"{i}.0", f"{i}.end")

        # Track if we're in OP1 for LUG (to find counter bore and other steps)
        in_op1_lug = True
        in_bore_op1 = False

        # Insert LUG content and highlight dimensions
        for i, line in enumerate(lug_lines, 1):
            lug_text.insert(tk.END, line)

            line_upper = line.upper()

            # Track OP2 boundary
            if any(marker in line_upper for marker in ['OP2', 'OP 2', 'FLIP PART', 'FLIP', 'SIDE 2']):
                in_op1_lug = False

            # Track bore tool
            if 'T121' in line_upper or 'BORE' in line_upper:
                in_bore_op1 = True
                lug_text.tag_add("cb_highlight", f"{i}.0", f"{i}.end")
            elif 'T303' in line_upper or 'TURN' in line_upper:
                in_bore_op1 = False

            # Highlight counter bore and other steps in OP1
            if in_op1_lug and in_bore_op1 and 'X' in line_upper:
                x_match = re.search(r'X\s*([\d.]+)', line, re.IGNORECASE)
                z_match = re.search(r'Z\s*-?\s*([\d.]+)', line, re.IGNORECASE)

                if x_match:
                    x_val = float(x_match.group(1))

                    # Check if this is the 2PC counter bore step
                    if lug.get('counter_bore_diameter') and lug.get('counter_bore_depth'):
                        cb_dia_inches = lug.get('counter_bore_diameter') / 25.4
                        cb_depth = lug.get('counter_bore_depth')

                        # Main 2PC counter bore (0.25-0.40" deep)
                        if 0.25 <= cb_depth <= 0.40:
                            if abs(x_val - cb_dia_inches) < 0.1:
                                lug_text.tag_add("cb_highlight", f"{i}.0", f"{i}.end")
                        # Other steps (different depth or diameter)
                        elif z_match:
                            z_val = abs(float(z_match.group(1).replace(' ', '')))
                            # Highlight if it's a step operation but not the main CB
                            if 0.15 <= z_val <= 1.0 and abs(x_val - cb_dia_inches) > 0.1:
                                lug_text.tag_add("other_step_highlight", f"{i}.0", f"{i}.end")

        stud_text.configure(state=tk.DISABLED)
        lug_text.configure(state=tk.DISABLED)

        # Sync scrolling
        def sync_scroll(*args):
            stud_text.yview(*args)
            lug_text.yview(*args)

        stud_scroll_y.configure(command=sync_scroll)
        lug_scroll_y.configure(command=sync_scroll)

        # Bottom buttons and legend
        bottom_frame = tk.Frame(comp_win, bg=self.bg_color)
        bottom_frame.pack(fill=tk.X, padx=10, pady=10)

        # Legend
        legend_frame = tk.Frame(bottom_frame, bg=self.bg_color)
        legend_frame.pack(side=tk.LEFT, padx=10)

        tk.Label(legend_frame,
                text="Color Legend:",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 10, "bold")).pack(anchor='w')
        tk.Label(legend_frame,
                text="🔵 Blue = 2PC Mating Hub (~0.25\" STUD)  |  🔴 Red = 2PC Counter Bore (~0.30\" LUG)",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 9)).pack(anchor='w')
        tk.Label(legend_frame,
                text="🟢 Green = Large Hub (~0.5\" for mounting)  |  🟠 Orange = Other Steps (non-2PC)",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 9)).pack(anchor='w')

        tk.Button(bottom_frame, text="Close", command=comp_win.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=15).pack(side=tk.RIGHT, padx=5)

    def rename_duplicate_files(self):
        """Rename physical files with duplicate filenames and update database - FILTERED VIEW ONLY"""
        # Get currently displayed items (respects filters)
        displayed_items = self.tree.get_children()

        if not displayed_items:
            messagebox.showwarning("No Files",
                "No files in current view.\n\n"
                "Apply filters to show the files you want to rename.")
            return

        # Get program numbers from filtered view
        filtered_program_numbers = []
        for item in displayed_items:
            values = self.tree.item(item)['values']
            if values:
                filtered_program_numbers.append(values[0])

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Find files with duplicate filenames - ONLY IN FILTERED VIEW
        placeholders = ','.join('?' * len(filtered_program_numbers))
        cursor.execute(f"""
            SELECT program_number, file_path, duplicate_type, parent_file, duplicate_group,
                   validation_status
            FROM programs
            WHERE file_path IS NOT NULL
              AND program_number IN ({placeholders})
            ORDER BY file_path
        """, filtered_program_numbers)
        all_files = cursor.fetchall()

        # Group files by filename (case-insensitive)
        filename_groups = {}
        for prog_num, file_path, dup_type, parent, dup_group, val_status in all_files:
            if not file_path or not os.path.exists(file_path):
                continue

            basename = os.path.basename(file_path).lower()
            if basename not in filename_groups:
                filename_groups[basename] = []
            filename_groups[basename].append((prog_num, file_path, dup_type, parent, dup_group, val_status))

        # Find files that need renaming (duplicates)
        duplicates_to_rename = []
        for basename, files in filename_groups.items():
            if len(files) > 1:
                # Sort to determine parent (keep oldest with best validation)
                def sort_key(f):
                    val_priority = {'PASS': 0, 'WARNING': 1, 'DIMENSIONAL': 2, 'BORE_WARNING': 3, 'CRITICAL': 4, 'REPEAT': 5}
                    return val_priority.get(f[5], 9)

                sorted_files = sorted(files, key=sort_key)
                parent_file = sorted_files[0]
                child_files = sorted_files[1:]

                for child in child_files:
                    duplicates_to_rename.append({
                        'prog_num': child[0],
                        'old_path': child[1],
                        'parent_prog': parent_file[0],
                        'basename': basename
                    })

        conn.close()

        if not duplicates_to_rename:
            messagebox.showinfo("No Duplicates",
                "No duplicate filenames found.\n\n"
                "All files have unique names.")
            return

        # Show mode selection: Preview or Execute
        mode_choice = [None]

        mode_window = tk.Toplevel(self.root)
        mode_window.title("Rename Duplicate Files")
        mode_window.geometry("500x200")
        mode_window.configure(bg=self.bg_color)
        mode_window.transient(self.root)
        mode_window.grab_set()

        tk.Label(mode_window,
                text=f"Found {len(duplicates_to_rename)} file(s) with duplicate names",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=15)

        tk.Label(mode_window,
                text="This will assign new O-numbers (o59000+) to duplicate files.",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        tk.Label(mode_window,
                text="Updates: physical file, internal O-number, and database.",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        tk.Label(mode_window,
                text="Choose mode:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        def preview_mode():
            mode_choice[0] = "preview"
            mode_window.destroy()

        def execute_mode():
            mode_choice[0] = "execute"
            mode_window.destroy()

        def cancel_mode():
            mode_window.destroy()

        btn_frame = tk.Frame(mode_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="🔍 Preview (Dry Run)",
                 command=preview_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="▶️ Execute (Rename Files)",
                 command=execute_mode,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Cancel",
                 command=cancel_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=10).pack(side=tk.LEFT, padx=5)

        self.root.wait_window(mode_window)

        if mode_choice[0] is None:
            return

        dry_run = (mode_choice[0] == "preview")

        # Create backup if executing
        if not dry_run:
            if not self.backup_database():
                messagebox.showerror("Backup Failed",
                    "Database backup failed. Rename operation canceled for safety.")
                return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        if dry_run:
            progress_window.title("Rename Preview (Dry Run)")
        else:
            progress_window.title("Assigning New O-Numbers to Duplicates")
        progress_window.geometry("900x600")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window,
                text="Preview - Files that WOULD be assigned new O-numbers:" if dry_run else "Assigning new O-numbers...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                  bg=self.input_bg, fg=self.fg_color,
                                                  font=("Courier", 9),
                                                  wrap=tk.WORD)
        progress_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        if dry_run:
            progress_text.insert(tk.END, f"=== DRY RUN MODE - NO CHANGES WILL BE MADE ===\n\n")

        progress_text.insert(tk.END, f"Found {len(duplicates_to_rename)} duplicate file(s) in filtered view.\n")
        progress_text.insert(tk.END, f"Assigning available O-numbers (avoiding reserved 00000-01000)...\n\n")

        renamed_count = 0
        errors = 0

        # Get all existing program numbers to find available O-numbers
        conn_temp = sqlite3.connect(self.db_path)
        cursor_temp = conn_temp.cursor()
        cursor_temp.execute("SELECT program_number FROM programs")
        existing_program_numbers = set()
        for row in cursor_temp.fetchall():
            prog = row[0]
            # Extract numeric part
            match = re.search(r'o?(\d+)', prog, re.IGNORECASE)
            if match:
                existing_program_numbers.add(int(match.group(1)))
        conn_temp.close()

        # Reserved ranges (DO NOT USE for production files)
        reserved_ranges = [
            (0, 1000)  # Machine needed files (00000-01000)
        ]

        # Helper function to check if number is in reserved range
        def is_reserved(num):
            for reserved_start, reserved_end in reserved_ranges:
                if reserved_start <= num <= reserved_end:
                    return True
            return False

        # Find available O-numbers starting from 1001 (avoiding reserved 0-1000)
        def find_next_available_onumber(start=1001):
            """Find the next available O-number, skipping reserved ranges"""
            current = start
            while current < 100000:
                if current not in existing_program_numbers and not is_reserved(current):
                    existing_program_numbers.add(current)  # Reserve it
                    return current
                current += 1
            return None  # No available numbers found

        # Track used names to avoid collisions
        used_names = set()

        for idx, dup_info in enumerate(duplicates_to_rename, 1):
            prog_num = dup_info['prog_num']
            old_path = dup_info['old_path']
            parent_prog = dup_info['parent_prog']

            # Get available O-number
            new_onumber = find_next_available_onumber()

            # Check if we ran out of numbers
            if new_onumber is None:
                progress_text.insert(tk.END, f"[{idx}] ❌ ERROR: No available O-numbers in entire range (00000-99999)!\n\n")
                errors += 1
                continue

            # Format with leading zeros (always 5 digits: o01057, not o1057)
            new_prog_num = f"o{new_onumber:05d}"

            # Generate new filename
            old_dir = os.path.dirname(old_path)
            old_basename = os.path.basename(old_path)
            name_without_ext, ext = os.path.splitext(old_basename)

            # New filename with proper O-number (5 digits with leading zeros)
            new_basename = f"o{new_onumber:05d}{ext}"
            new_path = os.path.join(old_dir, new_basename)

            # Safety check - ensure new path doesn't exist
            if os.path.exists(new_path):
                progress_text.insert(tk.END, f"[{idx}] ⚠️  SKIP: {new_basename} already exists\n\n")
                continue

            used_names.add(new_basename.lower())

            try:
                if dry_run:
                    progress_text.insert(tk.END, f"[{idx}] WOULD RENAME:\n")
                    progress_text.insert(tk.END, f"    Old File: {old_basename}\n")
                    progress_text.insert(tk.END, f"    New File: {new_basename}\n")
                    progress_text.insert(tk.END, f"    Old Program: {prog_num} (parent: {parent_prog})\n")
                    progress_text.insert(tk.END, f"    New Program: {new_prog_num}\n\n")
                    renamed_count += 1
                else:
                    # Actually rename the physical file
                    os.rename(old_path, new_path)

                    # Update internal G-code program number
                    if not self.update_gcode_program_number(new_path, new_prog_num):
                        progress_text.insert(tk.END, f"    ⚠️  Warning: Could not update internal O-number\n")

                    # Update database with new path AND new program number
                    conn = sqlite3.connect(self.db_path)
                    cursor = conn.cursor()
                    cursor.execute("""
                        UPDATE programs
                        SET file_path = ?,
                            program_number = ?
                        WHERE program_number = ?
                    """, (new_path, new_prog_num, prog_num))
                    conn.commit()
                    conn.close()

                    progress_text.insert(tk.END, f"[{idx}] ✓ RENAMED:\n")
                    progress_text.insert(tk.END, f"    Old File: {old_basename}\n")
                    progress_text.insert(tk.END, f"    New File: {new_basename}\n")
                    progress_text.insert(tk.END, f"    Old Program: {prog_num}\n")
                    progress_text.insert(tk.END, f"    New Program: {new_prog_num}\n\n")
                    renamed_count += 1

                progress_text.see(tk.END)
                self.root.update()

            except Exception as e:
                progress_text.insert(tk.END, f"[{idx}] ❌ ERROR: {prog_num}\n")
                progress_text.insert(tk.END, f"    {str(e)}\n\n")
                errors += 1
                progress_text.see(tk.END)
                self.root.update()

        # Summary
        progress_text.insert(tk.END, f"\n{'='*70}\n")
        if dry_run:
            progress_text.insert(tk.END, f"PREVIEW COMPLETE - No actual changes were made.\n")
            progress_text.insert(tk.END, f"Would assign new O-numbers to: {renamed_count} file(s)\n")
            progress_text.insert(tk.END, f"\nClick 'Execute' to apply these changes.\n")
        else:
            progress_text.insert(tk.END, f"OPERATION COMPLETE!\n")
            progress_text.insert(tk.END, f"Successfully assigned new O-numbers to: {renamed_count} file(s)\n")
            progress_text.insert(tk.END, f"Errors: {errors}\n")
            progress_text.insert(tk.END, f"\nAll files now have unique O-numbers (o59000+)\n")
            progress_text.insert(tk.END, f"Physical files renamed, internal O-numbers updated, database updated.\n")

            # Refresh display
            self.refresh_filter_values()
            self.refresh_results()

        progress_text.see(tk.END)

        # Close button
        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def organize_files_by_od(self):
        """Copy all database files to organized folder structure by OD

        Includes:
        - Current repository files
        - Revised repository files
        - Complete version history
        """
        import shutil

        # Ask user for destination folder
        dest_folder = filedialog.askdirectory(title="Select Destination Folder for Organized Files")

        if not dest_folder:
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Organizing Files by OD...")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        progress_label = tk.Label(progress_window, text="Organizing files...",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get all files from database with OD info
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('''
            SELECT program_number, file_path, outer_diameter
            FROM programs
            WHERE file_path IS NOT NULL
        ''')
        all_files = cursor.fetchall()
        conn.close()

        progress_text.insert(tk.END, f"=== Organize by OD - Full Export ===\n\n")
        progress_text.insert(tk.END, f"Found {len(all_files)} files in database.\n")
        progress_text.insert(tk.END, f"Destination: {dest_folder}\n\n")
        progress_text.insert(tk.END, f"This will copy:\n")
        progress_text.insert(tk.END, f"  • Current repository files (organized by OD)\n")
        progress_text.insert(tk.END, f"  • Version history (all old versions)\n")
        progress_text.insert(tk.END, f"  • Revised repository (edited files)\n\n")
        progress_text.see(tk.END)
        self.root.update()

        # OD folder mapping (round to standard sizes)
        od_folders = {
            5.75: "5.75 Round",
            6.00: "6.00 Round",
            6.25: "6.25 Round",
            6.50: "6.50 Round",
            7.00: "7.00 Round",
            7.50: "7.50 Round",
            8.00: "8.00 Round",
            8.50: "8.50 Round",
            9.50: "9.50 Round",
            10.25: "10.25 Round",
            10.50: "10.50 Round",
            13.00: "13.00 Round"
        }

        copied = 0
        skipped = 0
        errors = 0

        for idx, (prog_num, file_path, od) in enumerate(all_files, 1):
            progress_label.config(text=f"Processing {idx}/{len(all_files)}: {prog_num}")
            self.root.update()

            # Check if file exists
            if not os.path.exists(file_path):
                progress_text.insert(tk.END, f"SKIP: {prog_num} - file not found: {file_path}\n")
                progress_text.see(tk.END)
                skipped += 1
                continue

            # Determine OD folder
            if od is None:
                folder_name = "Other Sizes"
            else:
                # Find closest standard OD
                closest_od = min(od_folders.keys(), key=lambda x: abs(x - od))
                if abs(closest_od - od) <= 0.1:  # Within tolerance
                    folder_name = od_folders[closest_od]
                else:
                    folder_name = "Other Sizes"

            # Create destination folder if needed
            od_folder_path = os.path.join(dest_folder, folder_name)
            os.makedirs(od_folder_path, exist_ok=True)

            # Copy file
            filename = os.path.basename(file_path)
            dest_path = os.path.join(od_folder_path, filename)

            try:
                shutil.copy2(file_path, dest_path)
                progress_text.insert(tk.END, f"COPY: {prog_num} -> {folder_name}/{filename}\n")
                progress_text.see(tk.END)
                copied += 1
            except Exception as e:
                progress_text.insert(tk.END, f"ERROR: {prog_num} - {str(e)[:100]}\n")
                progress_text.see(tk.END)
                errors += 1

        # Copy versions folder (complete version history)
        progress_label.config(text="Copying version history...")
        progress_text.insert(tk.END, f"\n{'='*60}\n")
        progress_text.insert(tk.END, f"Copying version history...\n")
        progress_text.see(tk.END)
        self.root.update()

        versions_copied = 0
        if os.path.exists(self.versions_path):
            versions_dest = os.path.join(dest_folder, "versions")
            try:
                shutil.copytree(self.versions_path, versions_dest)
                # Count version files
                for root, dirs, files in os.walk(versions_dest):
                    versions_copied += len(files)
                progress_text.insert(tk.END, f"✓ Copied {versions_copied} version files\n")
            except Exception as e:
                progress_text.insert(tk.END, f"⚠ Warning: Could not copy versions folder: {str(e)[:100]}\n")
            progress_text.see(tk.END)
            self.root.update()
        else:
            progress_text.insert(tk.END, f"No versions folder found.\n")

        # Copy revised_repository folder
        progress_label.config(text="Copying revised repository...")
        progress_text.insert(tk.END, f"\nCopying revised repository...\n")
        progress_text.see(tk.END)
        self.root.update()

        revised_copied = 0
        if os.path.exists(self.revised_repository_path):
            revised_dest = os.path.join(dest_folder, "revised_repository")
            try:
                os.makedirs(revised_dest, exist_ok=True)
                for file in os.listdir(self.revised_repository_path):
                    src = os.path.join(self.revised_repository_path, file)
                    if os.path.isfile(src):
                        shutil.copy2(src, os.path.join(revised_dest, file))
                        revised_copied += 1
                progress_text.insert(tk.END, f"✓ Copied {revised_copied} revised files\n")
            except Exception as e:
                progress_text.insert(tk.END, f"⚠ Warning: Could not copy revised_repository: {str(e)[:100]}\n")
            progress_text.see(tk.END)
            self.root.update()
        else:
            progress_text.insert(tk.END, f"No revised_repository folder found.\n")

        # Show final results
        progress_label.config(text="Complete!")
        progress_text.insert(tk.END, f"\n{'='*60}\n")
        progress_text.insert(tk.END, f"EXPORT COMPLETE\n")
        progress_text.insert(tk.END, f"{'='*60}\n\n")
        progress_text.insert(tk.END, f"Repository files:\n")
        progress_text.insert(tk.END, f"  Total in database: {len(all_files)}\n")
        progress_text.insert(tk.END, f"  Copied: {copied}\n")
        progress_text.insert(tk.END, f"  Skipped: {skipped}\n")
        progress_text.insert(tk.END, f"  Errors: {errors}\n\n")
        progress_text.insert(tk.END, f"Version history: {versions_copied} files\n")
        progress_text.insert(tk.END, f"Revised repository: {revised_copied} files\n\n")
        progress_text.insert(tk.END, f"Total files exported: {copied + versions_copied + revised_copied}\n\n")
        progress_text.insert(tk.END, f"Organized by OD in folders:\n")
        progress_text.insert(tk.END, f"  {dest_folder}\n")
        progress_text.see(tk.END)

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def export_filtered_to_excel(self):
        """Export currently filtered/displayed items to Excel file"""
        try:
            import openpyxl
            from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
        except ImportError:
            messagebox.showerror("Missing Library",
                "openpyxl is required for Excel export.\n\n"
                "Install with: pip install openpyxl")
            return

        # Get currently displayed items from treeview
        displayed_items = self.tree.get_children()
        if not displayed_items:
            messagebox.showwarning("No Results", "No files in current view to export.\n\nPlease search/filter first.")
            return

        # Ask for save location
        from tkinter import filedialog
        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            filetypes=[("Excel Workbook", "*.xlsx"), ("All files", "*.*")],
            title=f"Export {len(displayed_items)} Filtered Records to Excel"
        )

        if not filepath:
            return

        try:
            # Create workbook
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Filtered Results"

            # Get column headers from treeview
            columns = list(self.tree["columns"])

            # Style definitions
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            header_alignment = Alignment(horizontal="center", vertical="center")
            thin_border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # Write headers
            for col_idx, col_name in enumerate(columns, 1):
                cell = ws.cell(row=1, column=col_idx, value=col_name)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = thin_border

            # Color fills for different statuses
            status_fills = {
                'CRITICAL': PatternFill(start_color="FF6B6B", end_color="FF6B6B", fill_type="solid"),
                'TOOL_HOME_CRITICAL': PatternFill(start_color="FF3333", end_color="FF3333", fill_type="solid"),
                'BORE_WARNING': PatternFill(start_color="FFA500", end_color="FFA500", fill_type="solid"),
                'TOOL_HOME_WARNING': PatternFill(start_color="FFBB44", end_color="FFBB44", fill_type="solid"),
                'DIMENSIONAL': PatternFill(start_color="DA77F2", end_color="DA77F2", fill_type="solid"),
                'WARNING': PatternFill(start_color="FFD43B", end_color="FFD43B", fill_type="solid"),
                'PASS': PatternFill(start_color="69DB7C", end_color="69DB7C", fill_type="solid"),
            }

            # Write data rows
            for row_idx, item in enumerate(displayed_items, 2):
                values = self.tree.item(item, "values")
                status_value = None

                for col_idx, value in enumerate(values, 1):
                    cell = ws.cell(row=row_idx, column=col_idx, value=value if value != "-" else "")
                    cell.border = thin_border

                    # Track status column (index 15 = "Status" after adding Tool Home)
                    if columns[col_idx - 1] == "Status":
                        status_value = value

                # Apply row color based on status
                if status_value and status_value in status_fills:
                    for col_idx in range(1, len(columns) + 1):
                        ws.cell(row=row_idx, column=col_idx).fill = status_fills[status_value]

            # Auto-adjust column widths
            for col_idx, col_name in enumerate(columns, 1):
                max_length = len(col_name)
                for row_idx in range(2, len(displayed_items) + 2):
                    cell_value = ws.cell(row=row_idx, column=col_idx).value
                    if cell_value:
                        max_length = max(max_length, len(str(cell_value)))
                # Set width with some padding, max 50
                ws.column_dimensions[openpyxl.utils.get_column_letter(col_idx)].width = min(max_length + 2, 50)

            # Freeze header row
            ws.freeze_panes = "A2"

            # Save workbook
            wb.save(filepath)

            messagebox.showinfo("Export Complete",
                f"Successfully exported {len(displayed_items)} records to:\n\n{filepath}")

        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export:\n{str(e)}")

    def copy_filtered_view(self):
        """Copy currently filtered/displayed files to folder with OD subfolders and auto-rename"""
        import shutil

        # Get currently displayed items from treeview
        displayed_items = self.tree.get_children()
        if not displayed_items:
            messagebox.showwarning("No Results", "No files in current view to copy.\n\nPlease search/filter first.")
            return

        # Ask user: Preview or Execute?
        preview_window = tk.Toplevel(self.root)
        preview_window.title("Copy Mode")
        preview_window.geometry("400x180")
        preview_window.configure(bg=self.bg_color)

        tk.Label(preview_window,
                text=f"Ready to copy {len(displayed_items)} files",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=15)

        tk.Label(preview_window,
                text="Choose operation mode:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        mode_choice = [None]  # Use list to modify in nested function

        def preview_mode():
            mode_choice[0] = "preview"
            preview_window.destroy()

        def execute_mode():
            mode_choice[0] = "execute"
            preview_window.destroy()

        btn_frame = tk.Frame(preview_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="🔍 Preview (Dry Run)", command=preview_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=18, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="▶️ Execute (Copy Files)", command=execute_mode,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=18, height=2).pack(side=tk.LEFT, padx=5)

        # Wait for user choice
        self.root.wait_window(preview_window)

        if not mode_choice[0]:
            return  # User closed window

        dry_run = (mode_choice[0] == "preview")

        # Create database backup before executing (not for preview)
        if not dry_run:
            if not self.backup_database():
                messagebox.showerror("Backup Failed",
                    "Database backup failed. Operation canceled for safety.\n\n"
                    "Please check the error and try again.")
                return

        # Ask user for destination folder
        dest_folder = filedialog.askdirectory(title="Select Destination Folder for Filtered Files")
        if not dest_folder:
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        title_text = "Preview: Copy Filtered View" if dry_run else "Copying Filtered View..."
        progress_window.title(title_text)
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        label_text = "Preview Mode (No files will be copied)" if dry_run else "Copying files..."
        progress_label = tk.Label(progress_window, text=label_text,
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 12))
        progress_label.pack(pady=20)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                 bg=self.input_bg, fg=self.fg_color,
                                                 width=80, height=20)
        progress_text.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.root.update()

        # Get file info from database for displayed items
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Extract program numbers from treeview
        program_numbers = []
        for item in displayed_items:
            values = self.tree.item(item)['values']
            if values:
                program_numbers.append(values[0])  # First column is Program #

        progress_text.insert(tk.END, f"Found {len(program_numbers)} files in current view.\n")
        progress_text.insert(tk.END, f"Destination: {dest_folder}\n\n")
        progress_text.see(tk.END)
        self.root.update()

        # Get file details from database
        placeholders = ','.join('?' * len(program_numbers))
        cursor.execute(f'''
            SELECT program_number, file_path, outer_diameter
            FROM programs
            WHERE program_number IN ({placeholders})
        ''', program_numbers)
        files_to_copy = cursor.fetchall()
        conn.close()

        # OD folder mapping
        od_folders = {
            5.75: "5.75 Round",
            6.00: "6.00 Round",
            6.25: "6.25 Round",
            6.50: "6.50 Round",
            7.00: "7.00 Round",
            7.50: "7.50 Round",
            8.00: "8.00 Round",
            8.50: "8.50 Round",
            9.50: "9.50 Round",
            10.25: "10.25 Round",
            10.50: "10.50 Round",
            13.00: "13.00 Round"
        }

        copied = 0
        skipped = 0
        errors = 0
        renamed = 0

        # Track filenames to handle collisions with auto-rename
        filename_tracker = {}  # {(folder, basename): occurrence_count}

        for idx, (prog_num, file_path, od) in enumerate(files_to_copy, 1):
            progress_label.config(text=f"Processing {idx}/{len(files_to_copy)}: {prog_num}")
            self.root.update()

            # Check if file exists
            if not file_path:
                progress_text.insert(tk.END, f"⚠️  SKIP: {prog_num} - no file path in database\n")
                progress_text.see(tk.END)
                skipped += 1
                continue

            if not os.path.exists(file_path):
                progress_text.insert(tk.END, f"⚠️  SKIP: {prog_num} - file not found at: {file_path}\n")
                progress_text.see(tk.END)
                skipped += 1
                continue

            # Determine OD folder
            if od is None:
                folder_name = "Unknown OD"
            else:
                closest_od = min(od_folders.keys(), key=lambda x: abs(x - od))
                if abs(closest_od - od) <= 0.1:
                    folder_name = od_folders[closest_od]
                else:
                    folder_name = f"Other ({od:.2f})"

            # Create destination folder
            od_folder_path = os.path.join(dest_folder, folder_name)
            os.makedirs(od_folder_path, exist_ok=True)

            # Get filename and handle collisions
            base_filename = os.path.basename(file_path)
            name_without_ext, ext = os.path.splitext(base_filename)

            # Check for collision and auto-rename with (1), (2), etc.
            folder_file_key = (od_folder_path, base_filename)
            if folder_file_key in filename_tracker:
                # Collision detected - add suffix
                filename_tracker[folder_file_key] += 1
                occurrence = filename_tracker[folder_file_key]
                new_filename = f"{name_without_ext}({occurrence}){ext}"
                progress_text.insert(tk.END, f"COLLISION: {base_filename} -> {new_filename}\n")
                renamed += 1
            else:
                # First occurrence
                filename_tracker[folder_file_key] = 1
                new_filename = base_filename

            dest_path = os.path.join(od_folder_path, new_filename)

            try:
                if dry_run:
                    # Preview mode - just show what would happen
                    progress_text.insert(tk.END, f"WOULD COPY: {prog_num} -> {folder_name}/{new_filename}\n")
                    progress_text.see(tk.END)
                    copied += 1
                else:
                    # Actually copy the file
                    shutil.copy2(file_path, dest_path)
                    progress_text.insert(tk.END, f"COPIED: {prog_num} -> {folder_name}/{new_filename}\n")
                    progress_text.see(tk.END)
                    copied += 1
            except Exception as e:
                progress_text.insert(tk.END, f"ERROR: {prog_num} - {str(e)[:100]}\n")
                progress_text.see(tk.END)
                errors += 1

        # Show results
        if dry_run:
            progress_label.config(text="Preview Complete (No files copied)")
            progress_text.insert(tk.END, f"\n{'='*70}\n")
            progress_text.insert(tk.END, f"PREVIEW MODE - No files were actually copied\n")
            progress_text.insert(tk.END, f"Total files: {len(files_to_copy)}\n")
            progress_text.insert(tk.END, f"Would copy: {copied}\n")
            progress_text.insert(tk.END, f"Would auto-rename (collisions): {renamed}\n")
            progress_text.insert(tk.END, f"Would skip: {skipped}\n")
            progress_text.insert(tk.END, f"Potential errors: {errors}\n")
        else:
            progress_label.config(text="Complete!")
            progress_text.insert(tk.END, f"\n{'='*70}\n")
            progress_text.insert(tk.END, f"Total files: {len(files_to_copy)}\n")
            progress_text.insert(tk.END, f"Copied: {copied}\n")
            progress_text.insert(tk.END, f"Auto-renamed (collisions): {renamed}\n")
            progress_text.insert(tk.END, f"Skipped: {skipped}\n")
            progress_text.insert(tk.END, f"Errors: {errors}\n")

        if skipped > 0:
            progress_text.insert(tk.END, f"\n⚠️  NOTE: {skipped} file(s) were skipped because the file paths in the database\n")
            progress_text.insert(tk.END, f"    are invalid or the files no longer exist at those locations.\n")
            progress_text.insert(tk.END, f"    You may need to use 'Scan Folder' to update the database with current file locations.\n")

        progress_text.see(tk.END)

        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def delete_filtered_view(self):
        """Delete currently filtered/displayed files from database (NOT from filesystem)"""
        # Permission check
        if not self.require_permission('delete_files', 'delete filtered entries'):
            return

        # Get currently displayed items from treeview
        displayed_items = self.tree.get_children()
        if not displayed_items:
            messagebox.showwarning("No Results", "No files in current view to delete.\n\nPlease search/filter first.")
            return

        # Extract program numbers and details
        program_numbers = []
        program_details = []  # For preview
        for item in displayed_items:
            values = self.tree.item(item)['values']
            if values:
                program_numbers.append(values[0])  # First column is Program #
                # Store prog_num, filename, OD for preview
                prog_num = values[0]
                filename = os.path.basename(values[1]) if len(values) > 1 and values[1] else "Unknown"
                od = values[6] if len(values) > 6 else "N/A"
                program_details.append((prog_num, filename, od))

        count = len(program_numbers)

        # Ask user: Preview or Execute?
        mode_choice = [None]  # Use list to modify in nested function

        mode_window = tk.Toplevel(self.root)
        mode_window.title("Delete Mode Selection")
        mode_window.geometry("450x180")
        mode_window.configure(bg=self.bg_color)
        mode_window.transient(self.root)
        mode_window.grab_set()

        tk.Label(mode_window,
                text=f"Delete {count} record(s) from database",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=15)

        tk.Label(mode_window,
                text="Choose mode:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(pady=5)

        def preview_mode():
            mode_choice[0] = "preview"
            mode_window.destroy()

        def execute_mode():
            mode_choice[0] = "execute"
            mode_window.destroy()

        def cancel_mode():
            mode_window.destroy()

        btn_frame = tk.Frame(mode_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="🔍 Preview (Dry Run)",
                 command=preview_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="▶️ Execute (Delete Records)",
                 command=execute_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Cancel",
                 command=cancel_mode,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=10).pack(side=tk.LEFT, padx=5)

        # Wait for user choice
        self.root.wait_window(mode_window)

        if mode_choice[0] is None:
            return  # User canceled

        dry_run = (mode_choice[0] == "preview")

        # If executing (not preview), require "DELETE" confirmation
        if not dry_run:
            confirm_window = tk.Toplevel(self.root)
            confirm_window.title("Final Confirmation")
            confirm_window.geometry("400x200")
            confirm_window.configure(bg=self.bg_color)
            confirm_window.transient(self.root)
            confirm_window.grab_set()

            tk.Label(confirm_window,
                    text=f"You are about to delete {count} records",
                    bg=self.bg_color, fg=self.fg_color,
                    font=("Arial", 12, "bold")).pack(pady=10)

            tk.Label(confirm_window,
                    text='Type "DELETE" to confirm:',
                    bg=self.bg_color, fg=self.fg_color,
                    font=("Arial", 10)).pack(pady=10)

            confirm_entry = tk.Entry(confirm_window, bg=self.input_bg, fg=self.fg_color,
                                    font=("Arial", 12), width=20)
            confirm_entry.pack(pady=10)
            confirm_entry.focus()

            confirmed = [False]  # Use list to modify in nested function

            def check_confirmation():
                if confirm_entry.get() == "DELETE":
                    confirmed[0] = True
                    confirm_window.destroy()
                else:
                    messagebox.showerror("Invalid", 'You must type "DELETE" exactly to confirm.')

            def cancel_delete():
                confirm_window.destroy()

            btn_frame = tk.Frame(confirm_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="Confirm", command=check_confirmation,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold"), width=10).pack(side=tk.LEFT, padx=5)

            tk.Button(btn_frame, text="Cancel", command=cancel_delete,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold"), width=10).pack(side=tk.LEFT, padx=5)

            # Bind Enter key to confirm
            confirm_entry.bind('<Return>', lambda e: check_confirmation())

            # Wait for window to close
            self.root.wait_window(confirm_window)

            if not confirmed[0]:
                return

            # Create database backup before executing delete
            if not self.backup_database():
                messagebox.showerror("Backup Failed",
                    "Database backup failed. Delete operation canceled for safety.\n\n"
                    "Please check the error and try again.")
                return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        if dry_run:
            progress_window.title("Delete Preview (Dry Run)")
        else:
            progress_window.title("Deleting Records")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window,
                text="Preview - Records that WOULD be deleted:" if dry_run else "Deleting database records...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        progress_text = scrolledtext.ScrolledText(progress_window,
                                                  bg=self.input_bg, fg=self.fg_color,
                                                  font=("Courier", 9),
                                                  wrap=tk.WORD)
        progress_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Process deletions
        deleted_count = 0
        try:
            if dry_run:
                # Preview mode - just show what would be deleted
                progress_text.insert(tk.END, f"=== DRY RUN MODE - NO CHANGES WILL BE MADE ===\n\n")
                progress_text.insert(tk.END, f"The following {count} record(s) WOULD be deleted from the database:\n\n")

                for prog_num, filename, od in program_details:
                    progress_text.insert(tk.END, f"WOULD DELETE: {prog_num} - {filename} (OD: {od})\n")
                    self.root.update()

                deleted_count = count  # For summary message
                progress_text.insert(tk.END, f"\n{'='*60}\n")
                progress_text.insert(tk.END, f"Preview complete. {count} record(s) WOULD be deleted.\n")
                progress_text.insert(tk.END, f"No actual changes were made to the database.\n")
            else:
                # Execute mode - actually delete from database
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()

                placeholders = ','.join('?' * len(program_numbers))
                cursor.execute(f'''
                    DELETE FROM programs
                    WHERE program_number IN ({placeholders})
                ''', program_numbers)

                deleted_count = cursor.rowcount
                conn.commit()
                conn.close()

                # Show deleted records
                for prog_num, filename, od in program_details:
                    progress_text.insert(tk.END, f"DELETED: {prog_num} - {filename} (OD: {od})\n")
                    self.root.update()

                progress_text.insert(tk.END, f"\n{'='*60}\n")
                progress_text.insert(tk.END, f"Successfully deleted {deleted_count} record(s) from the database.\n")
                progress_text.insert(tk.END, f"⚠️  The files on disk were NOT deleted.\n")

                # Refresh the display
                self.refresh_filter_values()
                self.refresh_results()

        except Exception as e:
            progress_text.insert(tk.END, f"\n\n❌ ERROR: {str(e)}\n")
            messagebox.showerror("Error", f"An error occurred:\n{str(e)}")

        # Add close button
        close_btn = tk.Button(progress_window, text="Close",
                             command=progress_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def show_context_menu(self, event):
        """Show right-click context menu - hide items user doesn't have permission for"""
        # Select row under mouse
        row_id = self.tree.identify_row(event.y)
        if row_id:
            self.tree.selection_set(row_id)

            menu = tk.Menu(self.root, tearoff=0, bg=self.input_bg, fg=self.fg_color)
            menu.add_command(label="Edit File", command=self.open_file)
            menu.add_command(label="Refresh File", command=self.refresh_selected_file)

            # Auto-Fix crash risks — only when crash_issues exist and user can edit
            if self.has_permission('edit_files'):
                try:
                    prog_num = self.tree.item(row_id)['values'][0]
                    _conn = sqlite3.connect(self.db_path)
                    _cur  = _conn.cursor()
                    _cur.execute("SELECT crash_issues FROM programs WHERE program_number = ?",
                                 (prog_num,))
                    _ci_row = _cur.fetchone()
                    _conn.close()
                    _has_crash = (_ci_row and _ci_row[0] and
                                  _ci_row[0] not in ('null', '[]', ''))
                except Exception:
                    _has_crash = False

                if _has_crash:
                    menu.add_command(label="🔧 Auto-Fix: G00 Crash Risks",
                                     command=self.auto_fix_crash_risks)

            # Edit Entry - only for editors and above
            if self.has_permission('edit_files'):
                menu.add_command(label="Edit Entry", command=self.edit_entry)

            menu.add_command(label="View Details", command=self.view_details)

            # Clipboard operations
            menu.add_separator()
            menu.add_command(label="📋 Copy Program #", command=self.copy_program_number_to_clipboard)
            menu.add_command(label="📋 Copy File Path", command=self.copy_file_path_to_clipboard)
            menu.add_command(label="📂 Open File Location", command=self.open_file_location)
            menu.add_command(label="📋 Copy Full Details", command=self.copy_full_details_to_clipboard)
            if selected_count := len(self.tree.selection()):
                if selected_count > 1:
                    menu.add_command(label=f"📋 Copy {selected_count} Programs as TSV", command=self.copy_multiple_programs_to_clipboard)

            # Compare Files - show if multiple files are selected
            if not selected_count:
                selected_count = len(self.tree.selection())
            if selected_count >= 2:
                menu.add_command(label=f"🔄 Compare {selected_count} Files", command=self.compare_files)

            # Find Compatible 2PC Parts - show only for 2PC parts
            selected = self.tree.selection()
            if selected:
                item = self.tree.item(selected[0])
                values = item['values']
                if values and len(values) > 3:
                    spacer_type = str(values[3]) if len(values) > 3 else ''
                    if '2PC' in spacer_type:
                        menu.add_command(label="🔗 Find Compatible 2PC Parts", command=self.show_compatible_2pc_parts)
            # 2PC CB match search — always available from right-click
            menu.add_command(label="🔗 Find 2PC Match by CB", command=self.show_2pc_cb_search_dialog)

            menu.add_separator()

            # Create Copy option - available to operators and above
            if self.has_permission('copy_files'):
                menu.add_command(label="Create Copy for Editing", command=self.create_program_copy)
                menu.add_separator()

            menu.add_command(label="View Version History", command=self.show_version_history_window)
            menu.add_command(label="View Toolpath", command=self.show_toolpath_plotter)
            menu.add_command(label="View 3D Model", command=self.show_3d_spacer_model)

            # Archive and Delete - only for those with permission
            if self.has_permission('delete_files') or self.has_permission('move_files'):
                menu.add_separator()
                if self.has_permission('move_files'):
                    menu.add_command(label="Archive Program", command=self.archive_program)
                if self.has_permission('delete_files'):
                    menu.add_command(label="Delete Entry", command=self.delete_entry)

            menu.post(event.x_root, event.y_root)

    def show_dimensional_variations(self):
        """Show all dimensional variations - programs with same OD but different finishing dimensions"""

        # Create progress dialog
        progress_win = tk.Toplevel(self.root)
        progress_win.title("Finding Variations...")
        progress_win.geometry("400x150")
        progress_win.configure(bg=self.bg_color)
        progress_win.transient(self.root)
        progress_win.grab_set()

        tk.Label(progress_win, text="Scanning for dimensional variations...",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 12)).pack(pady=20)
        tk.Label(progress_win, text="This may take a moment for large databases",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack(pady=10)

        progress_win.update()

        # Find variations
        try:
            variations = self.find_dimensional_variations()
        except Exception as e:
            progress_win.destroy()
            messagebox.showerror("Error", f"Failed to find variations: {str(e)}")
            return

        progress_win.destroy()

        if not variations:
            messagebox.showinfo("No Variations", "No dimensional variations found.\n\n"
                "Variations are programs with the same OD but different:\n"
                "- Center bore\n"
                "- Thickness\n"
                "- Hub dimensions\n"
                "- Counter bore")
            return

        # Create results window
        var_win = tk.Toplevel(self.root)
        var_win.title("Dimensional Variations")
        var_win.geometry("1100x700")
        var_win.configure(bg=self.bg_color)

        # Header
        header_frame = tk.Frame(var_win, bg=self.bg_color)
        header_frame.pack(fill=tk.X, padx=10, pady=10)

        total_od_groups = len(variations)
        total_variations = sum(v['variation_count'] for v in variations.values())
        total_programs = sum(v['total_programs'] for v in variations.values())

        tk.Label(header_frame,
                text=f"Found {total_variations} variation groups across {total_od_groups} OD sizes ({total_programs} total programs)",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 12, "bold")).pack(pady=5)

        tk.Label(header_frame,
                text="Programs with same OD but different CB, thickness, hub, or counter bore dimensions",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack()

        # Create treeview
        tree_frame = tk.Frame(var_win, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        columns = ('od', 'variations', 'programs', 'signature', 'prog_num', 'title', 'cb', 'thickness')
        tree = ttk.Treeview(tree_frame, columns=columns, show='tree headings', height=25)

        tree.heading('#0', text='')
        tree.heading('od', text='OD')
        tree.heading('variations', text='Variations')
        tree.heading('programs', text='Programs')
        tree.heading('signature', text='Dimension Signature')
        tree.heading('prog_num', text='Program #')
        tree.heading('title', text='Title')
        tree.heading('cb', text='CB (mm)')
        tree.heading('thickness', text='Thickness')

        tree.column('#0', width=30)
        tree.column('od', width=60)
        tree.column('variations', width=70)
        tree.column('programs', width=70)
        tree.column('signature', width=200)
        tree.column('prog_num', width=100)
        tree.column('title', width=250)
        tree.column('cb', width=70)
        tree.column('thickness', width=80)

        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        hsb.grid(row=1, column=0, sticky='ew')

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        # Populate tree
        for od_key in sorted(variations.keys()):
            var_data = variations[od_key]

            # Parent node for OD
            od_id = tree.insert('', 'end', text='▶',
                              values=(f'{od_key}"', var_data['variation_count'],
                                     var_data['total_programs'], '', '', '', '', ''))

            # Child nodes for each variation group
            for group in var_data['groups']:
                group_id = tree.insert(od_id, 'end', text='  ▷',
                                      values=('', '', group['count'],
                                             group['signature'], '', '', '', ''))

                # Child nodes for each program in this variation
                for prog in group['programs']:
                    tree.insert(group_id, 'end', text='',
                              values=('', '', '',
                                     '',
                                     prog['program_number'],
                                     prog['title'] or '',
                                     prog['center_bore'] or '',
                                     f"{prog['thickness']}\"" if prog['thickness'] else ''))

        # Button frame
        btn_frame = tk.Frame(var_win, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        def compare_selected():
            """Compare two selected programs"""
            selection = tree.selection()
            if len(selection) != 2:
                messagebox.showwarning("Selection Required",
                    "Please select exactly 2 programs to compare.\n"
                    "Hold Ctrl and click to select multiple.")
                return

            # Get program numbers from selection
            progs = []
            for item in selection:
                values = tree.item(item, 'values')
                prog_num = values[4] if len(values) > 4 else None
                if prog_num:
                    progs.append(prog_num)

            if len(progs) != 2:
                messagebox.showwarning("Selection Required",
                    "Please select two program rows (not group headers)")
                return

            # Get file paths
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            paths = []
            for prog in progs:
                cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (prog,))
                row = cursor.fetchone()
                if row and row[0]:
                    paths.append(row[0])
            conn.close()

            if len(paths) != 2:
                messagebox.showerror("Error", "Could not find file paths for selected programs")
                return

            # Run comparison
            comparison = self.compare_file_contents(paths[0], paths[1])

            # Show results
            comp_msg = f"Comparing {progs[0]} vs {progs[1]}\n\n"
            comp_msg += f"Same OD: {'Yes' if comparison['same_od'] else 'No'}\n"
            comp_msg += f"Is Variation: {'Yes' if comparison['is_variation'] else 'No'}\n"
            comp_msg += f"Variation Type: {comparison['variation_type'] or 'N/A'}\n\n"

            if comparison['dimension_differences']:
                comp_msg += "Dimensional Differences:\n"
                for diff in comparison['dimension_differences']:
                    comp_msg += f"  • {diff}\n"
            else:
                comp_msg += "No dimensional differences detected\n"

            comp_msg += f"\nCode Similarity: {comparison['common_lines_percent']:.1f}%\n"
            comp_msg += f"Recommendation: {comparison['recommendation']}"

            messagebox.showinfo("Comparison Results", comp_msg)

        def export_variations():
            """Export variations to CSV"""
            from tkinter import filedialog
            import csv

            filepath = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv")],
                title="Export Variations"
            )

            if not filepath:
                return

            try:
                with open(filepath, 'w', newline='', encoding='utf-8') as f:
                    writer = csv.writer(f)
                    writer.writerow(['OD', 'Variation Group', 'Program #', 'Title',
                                   'Center Bore', 'Thickness', 'Hub Height', 'Hub Dia',
                                   'CB Diameter', 'CB Depth'])

                    for od_key in sorted(variations.keys()):
                        var_data = variations[od_key]
                        for i, group in enumerate(var_data['groups'], 1):
                            for prog in group['programs']:
                                writer.writerow([
                                    od_key,
                                    f"Group {i}: {group['signature']}",
                                    prog['program_number'],
                                    prog['title'] or '',
                                    prog['center_bore'] or '',
                                    prog['thickness'] or '',
                                    prog['hub_height'] or '',
                                    prog['hub_diameter'] or '',
                                    prog['counter_bore_diameter'] or '',
                                    prog['counter_bore_depth'] or ''
                                ])

                messagebox.showinfo("Exported", f"Variations exported to:\n{filepath}")

            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export: {str(e)}")

        tk.Button(btn_frame, text="⚖️ Compare Selected", command=compare_selected,
                 bg="#2196F3", fg="white", font=("Arial", 10, "bold"),
                 width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="📊 Export CSV", command=export_variations,
                 bg="#4CAF50", fg="white", font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=var_win.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=10).pack(side=tk.RIGHT, padx=5)

        # Info label
        tk.Label(btn_frame,
                text="Tip: Select 2 programs and click 'Compare Selected' to see detailed differences",
                bg=self.bg_color, fg="#888888", font=("Arial", 9)).pack(side=tk.LEFT, padx=20)

    def show_standards_reference(self):
        """Show verification standards reference window"""
        StandardsReferenceWindow(self.root, self)

    def show_2pc_filter_dialog(self):
        """Show filter dialog for 2PC part matching with thickness filters"""
        dialog = tk.Toplevel(self.root)
        dialog.title("2PC Match Filters")
        dialog.geometry("450x400")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Center the dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() - 450) // 2
        y = (dialog.winfo_screenheight() - 400) // 2
        dialog.geometry(f"+{x}+{y}")

        result = [None]

        # Header
        tk.Label(dialog, text="Filter 2PC Part Matches",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=15)

        tk.Label(dialog, text="Leave fields blank to search without limits",
                bg=self.bg_color, fg="#888888",
                font=("Arial", 9, "italic")).pack(pady=5)

        # Filter frame
        filter_frame = tk.Frame(dialog, bg=self.bg_color)
        filter_frame.pack(pady=20, padx=30, fill=tk.BOTH, expand=True)

        # STUD Thickness filters
        stud_frame = tk.LabelFrame(filter_frame, text=" STUD Thickness (inches) ",
                                   bg=self.bg_color, fg=self.fg_color,
                                   font=("Arial", 10, "bold"))
        stud_frame.pack(fill=tk.X, pady=10)

        stud_inner = tk.Frame(stud_frame, bg=self.bg_color)
        stud_inner.pack(pady=10, padx=10)

        tk.Label(stud_inner, text="Min:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).grid(row=0, column=0, padx=5, sticky='e')
        stud_min_entry = tk.Entry(stud_inner, bg=self.input_bg, fg=self.fg_color,
                                  font=("Arial", 10), width=15)
        stud_min_entry.grid(row=0, column=1, padx=5)

        tk.Label(stud_inner, text="Max:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5, sticky='e')
        stud_max_entry = tk.Entry(stud_inner, bg=self.input_bg, fg=self.fg_color,
                                  font=("Arial", 10), width=15)
        stud_max_entry.grid(row=1, column=1, padx=5, pady=5)

        # LUG Thickness filters
        lug_frame = tk.LabelFrame(filter_frame, text=" LUG Thickness (inches) ",
                                  bg=self.bg_color, fg=self.fg_color,
                                  font=("Arial", 10, "bold"))
        lug_frame.pack(fill=tk.X, pady=10)

        lug_inner = tk.Frame(lug_frame, bg=self.bg_color)
        lug_inner.pack(pady=10, padx=10)

        tk.Label(lug_inner, text="Min:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).grid(row=0, column=0, padx=5, sticky='e')
        lug_min_entry = tk.Entry(lug_inner, bg=self.input_bg, fg=self.fg_color,
                                 font=("Arial", 10), width=15)
        lug_min_entry.grid(row=0, column=1, padx=5)

        tk.Label(lug_inner, text="Max:", bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5, sticky='e')
        lug_max_entry = tk.Entry(lug_inner, bg=self.input_bg, fg=self.fg_color,
                                 font=("Arial", 10), width=15)
        lug_max_entry.grid(row=1, column=1, padx=5, pady=5)

        def apply_filters():
            """Validate and apply filters"""
            try:
                # Parse thickness values (allow empty for no filter)
                stud_min = float(stud_min_entry.get()) if stud_min_entry.get().strip() else None
                stud_max = float(stud_max_entry.get()) if stud_max_entry.get().strip() else None
                lug_min = float(lug_min_entry.get()) if lug_min_entry.get().strip() else None
                lug_max = float(lug_max_entry.get()) if lug_max_entry.get().strip() else None

                # Validate ranges
                if stud_min is not None and stud_max is not None and stud_min > stud_max:
                    messagebox.showerror("Invalid Range", "STUD Min thickness cannot be greater than Max")
                    return
                if lug_min is not None and lug_max is not None and lug_min > lug_max:
                    messagebox.showerror("Invalid Range", "LUG Min thickness cannot be greater than Max")
                    return

                result[0] = {
                    'stud_thickness_min': stud_min,
                    'stud_thickness_max': stud_max,
                    'lug_thickness_min': lug_min,
                    'lug_thickness_max': lug_max
                }
                dialog.destroy()

            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter valid numeric values for thickness")

        # Buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="Search", command=apply_filters,
                 bg="#4CAF50", fg="white", font=("Arial", 11, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Cancel", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 11),
                 width=12).pack(side=tk.LEFT, padx=5)

        # Example text
        tk.Label(dialog, text='Example: Enter "0.5" and "1.0" to find parts between 0.5" and 1.0" thick',
                bg=self.bg_color, fg="#666666",
                font=("Arial", 8, "italic")).pack(pady=5)

        dialog.wait_window()
        return result[0]

    def show_compatible_2pc_parts(self):
        """Show compatible 2PC STUD/LUG pairings for the selected program with optional filters"""

        # Get selected program
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("No Selection", "Please select a 2PC program first")
            return

        item = self.tree.item(selected[0])
        values = item['values']
        program_number = values[0] if values else None

        if not program_number:
            messagebox.showwarning("No Selection", "Could not find program number")
            return

        # Show filter dialog
        filter_result = self.show_2pc_filter_dialog()
        if filter_result is None:
            return  # User cancelled

        # Create progress dialog
        progress_win = tk.Toplevel(self.root)
        progress_win.title("Finding Compatible Parts...")
        progress_win.geometry("400x150")
        progress_win.configure(bg=self.bg_color)
        progress_win.transient(self.root)
        progress_win.grab_set()

        tk.Label(progress_win, text="Searching for compatible 2PC parts...",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 12)).pack(pady=20)
        tk.Label(progress_win, text="Analyzing hub/step dimensions and OD matching",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack(pady=10)

        progress_win.update()

        # Find compatible parts with thickness filters
        try:
            logger.info(f"[2PC MATCH] Searching for matches for {program_number}")
            logger.info(f"[2PC MATCH] Filters: STUD thick={filter_result['stud_thickness_min']}-{filter_result['stud_thickness_max']}, LUG thick={filter_result['lug_thickness_min']}-{filter_result['lug_thickness_max']}")

            matches = self.find_compatible_2pc_parts(
                program_number=program_number,
                stud_thickness_min=filter_result['stud_thickness_min'],
                stud_thickness_max=filter_result['stud_thickness_max'],
                lug_thickness_min=filter_result['lug_thickness_min'],
                lug_thickness_max=filter_result['lug_thickness_max']
            )

            logger.info(f"[2PC MATCH] Found {len(matches)} matches")
            if matches:
                for i, match in enumerate(matches[:3]):
                    logger.info(f"[2PC MATCH]   Match {i+1}: {match['stud']['program_number']} + {match['lug']['program_number']} (score={match['score']})")

        except Exception as e:
            logger.error(f"[2PC MATCH] Error: {e}", exc_info=True)
            progress_win.destroy()
            messagebox.showerror("Error", f"Failed to find compatible parts: {str(e)}")
            return

        progress_win.destroy()

        if not matches:
            messagebox.showinfo("No Matches",
                "No compatible 2PC parts found.\n\n"
                "Compatibility requires:\n"
                "• Matching round size (OD) within ±1mm\n"
                "• STUD hub fits inside LUG step (1-3mm clearance)\n"
                "• STUD hub height fits inside LUG step depth")
            return

        # Create results window
        match_win = tk.Toplevel(self.root)
        match_win.title(f"Compatible 2PC Parts for {program_number}")
        match_win.geometry("1400x700")
        match_win.configure(bg=self.bg_color)

        # Header
        header_frame = tk.Frame(match_win, bg=self.bg_color)
        header_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(header_frame,
                text=f"Found {len(matches)} compatible 2PC pairing(s) for {program_number}",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 12, "bold")).pack(pady=5)

        tk.Label(header_frame,
                text="STUD and LUG parts that can be assembled together based on hub/step fit and round size",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack()

        # Show active filters
        filter_text_parts = []
        if filter_result['stud_thickness_min'] is not None or filter_result['stud_thickness_max'] is not None:
            min_str = f"{filter_result['stud_thickness_min']:.2f}" if filter_result['stud_thickness_min'] else "any"
            max_str = f"{filter_result['stud_thickness_max']:.2f}" if filter_result['stud_thickness_max'] else "any"
            filter_text_parts.append(f"STUD: {min_str}\" - {max_str}\"")
        if filter_result['lug_thickness_min'] is not None or filter_result['lug_thickness_max'] is not None:
            min_str = f"{filter_result['lug_thickness_min']:.2f}" if filter_result['lug_thickness_min'] else "any"
            max_str = f"{filter_result['lug_thickness_max']:.2f}" if filter_result['lug_thickness_max'] else "any"
            filter_text_parts.append(f"LUG: {min_str}\" - {max_str}\"")

        if filter_text_parts:
            tk.Label(header_frame,
                    text=f"Filters: {' | '.join(filter_text_parts)}",
                    bg=self.bg_color, fg="#FF9800", font=("Arial", 9, "bold")).pack(pady=3)

        # Create treeview
        tree_frame = tk.Frame(match_win, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        columns = ('score', 'stud_prog', 'stud_title', 'stud_od', 'stud_thick', 'hub_h', 'hub_d',
                  'lug_prog', 'lug_title', 'lug_od', 'lug_thick', 'step_d', 'step_depth', 'notes')
        tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=25)

        tree.heading('score', text='Score')
        tree.heading('stud_prog', text='STUD Prog#')
        tree.heading('stud_title', text='STUD Title')
        tree.heading('stud_od', text='STUD OD')
        tree.heading('stud_thick', text='STUD Thick')
        tree.heading('hub_h', text='Hub H')
        tree.heading('hub_d', text='Hub D (mm)')
        tree.heading('lug_prog', text='LUG Prog#')
        tree.heading('lug_title', text='LUG Title')
        tree.heading('lug_od', text='LUG OD')
        tree.heading('lug_thick', text='LUG Thick')
        tree.heading('step_d', text='Step D (mm)')
        tree.heading('step_depth', text='Step Depth')
        tree.heading('notes', text='Compatibility Notes')

        tree.column('score', width=50)
        tree.column('stud_prog', width=80)
        tree.column('stud_title', width=150)
        tree.column('stud_od', width=70)
        tree.column('stud_thick', width=75)
        tree.column('hub_h', width=60)
        tree.column('hub_d', width=80)
        tree.column('lug_prog', width=80)
        tree.column('lug_title', width=150)
        tree.column('lug_od', width=70)
        tree.column('lug_thick', width=75)
        tree.column('step_d', width=80)
        tree.column('step_depth', width=80)
        tree.column('notes', width=250)

        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        hsb.grid(row=1, column=0, sticky='ew')

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        # Populate tree with matches
        # Store match data for each row so we can retrieve it on double-click
        match_data = {}
        for idx, match in enumerate(matches):
            stud = match['stud']
            lug = match['lug']
            score = match['score']
            notes = ' | '.join(match['notes'])

            item_id = tree.insert('', 'end', values=(
                score,
                stud['program_number'],
                stud['title'][:30] if stud['title'] else '',
                f"{stud['outer_diameter']:.2f}\"" if stud['outer_diameter'] else '',
                f"{stud['thickness']:.3f}\"" if stud['thickness'] else '',
                f"{stud['hub_height']:.2f}\"" if stud['hub_height'] else '',
                f"{stud['hub_diameter']:.1f}" if stud['hub_diameter'] else '',
                lug['program_number'],
                lug['title'][:30] if lug['title'] else '',
                f"{lug['outer_diameter']:.2f}\"" if lug['outer_diameter'] else '',
                f"{lug['thickness']:.3f}\"" if lug['thickness'] else '',
                f"{lug['counter_bore_diameter']:.1f}" if lug['counter_bore_diameter'] else '',
                f"{lug['counter_bore_depth']:.2f}\"" if lug['counter_bore_depth'] else '',
                notes
            ))
            # Store the match data indexed by tree item ID
            match_data[item_id] = match

        # Add double-click handler to compare files with 2PC highlighting
        def on_double_click(event):
            selection = tree.selection()
            if not selection:
                return

            item_id = selection[0]
            match = match_data.get(item_id)
            if not match:
                return

            stud = match['stud']
            lug = match['lug']

            # Get file paths
            stud_path = stud.get('file_path')
            lug_path = lug.get('file_path')

            if not stud_path or not lug_path:
                messagebox.showwarning("Missing Files", "File paths not available for comparison")
                return

            # Open comparison viewer with 2PC dimension highlighting
            self.compare_2pc_files(stud, lug, stud_path, lug_path)

        tree.bind('<Double-1>', on_double_click)

        # Button frame
        btn_frame = tk.Frame(match_win, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(btn_frame, text="Close", command=match_win.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=10).pack(side=tk.RIGHT, padx=5)

        # Info label
        tk.Label(btn_frame,
                text="Higher scores indicate better fit. Hub and step dimensions must allow proper assembly.",
                bg=self.bg_color, fg="#888888", font=("Arial", 9)).pack(side=tk.LEFT, padx=20)

    def _eval_2pc_ring_fit(self, prog):
        """
        Evaluate ring/recess fit quality for a 2PC program using TWOPC_RING_TABLE.

        For LUG programs:  checks counter_bore_diameter clearance (0.003–0.005" over hub OD)
                           and counter_bore_depth >= 0.300".
        For STUD programs: checks hub_diameter matches expected hub OD for CB class.

        Returns:
            (label_str, sort_score)  — lower sort_score = better fit (1 = perfect).
        """
        is_lug = '2PC LUG' in prog.get('spacer_type', '')
        cb_mm = prog.get('center_bore')

        if not cb_mm:
            return 'No CB data', 99

        # Look up expected hub OD(s) for this program's CB class
        entry = None
        for cb_min, cb_max, hub_ods, desc in TWOPC_RING_TABLE:
            if cb_min <= cb_mm < cb_max:
                entry = (hub_ods, desc)
                break

        if entry is None:
            return '—', 90  # CB in a gap zone, not validated

        hub_ods_in, desc = entry

        if is_lug:
            cbd_mm = prog.get('counter_bore_diameter')
            depth_in = prog.get('counter_bore_depth')

            if not cbd_mm:
                return 'No recess bore', 80

            cbd_in = cbd_mm / 25.4
            nearest_hub = min(hub_ods_in, key=lambda r: abs(cbd_in - r))
            clearance = cbd_in - nearest_hub
            depth_ok = depth_in is not None and depth_in >= 0.300
            depth_str = f'{depth_in:.3f}"' if depth_in is not None else '—'

            if 0.003 <= clearance <= 0.005 and depth_ok:
                return f'✓ {clearance:+.3f}" cl / {depth_str} deep', 1
            elif 0.003 <= clearance <= 0.005:
                return f'⚠ bore OK / {depth_str} deep (shallow)', 3
            elif clearance < 0.0:
                return f'✗ interference {clearance:+.3f}"', 10
            elif clearance < 0.003:
                return f'⚠ tight {clearance:+.3f}" cl / {depth_str}', 6
            else:
                return f'⚠ loose {clearance:+.3f}" cl / {depth_str}', 7

        else:  # STUD
            hub_d_mm = prog.get('hub_diameter')
            hub_h_in = prog.get('hub_height')

            if not hub_d_mm:
                return 'No hub OD', 80

            hub_d_in = hub_d_mm / 25.4
            nearest_hub = min(hub_ods_in, key=lambda r: abs(hub_d_in - r))
            diff = abs(hub_d_in - nearest_hub)
            hub_h_str = f'{hub_h_in:.3f}"' if hub_h_in is not None else '—'

            if diff <= 0.055:
                return f'✓ hub OD {hub_d_mm:.1f} mm  h={hub_h_str}', 1
            elif diff <= 0.25:
                return f'≈ hub OD close (off {diff:.3f}")  h={hub_h_str}', 4
            else:
                return f'✗ hub OD mismatch (off {diff:.3f}")', 10

    def show_2pc_cb_search_dialog(self):
        """
        Standalone dialog: pick whether you have a STUD or LUG, enter the target CB
        of the matching piece, and see all opposite-type programs sorted by CB proximity
        with ring/recess fit quality evaluated from the hub OD lookup table.
        """
        dialog = tk.Toplevel(self.root)
        dialog.title("Find 2PC Matching Part by CB")
        dialog.geometry("380x230")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() - 380) // 2
        y = (dialog.winfo_screenheight() - 230) // 2
        dialog.geometry(f"+{x}+{y}")

        tk.Label(dialog, text="Find 2PC Matching Part",
                 bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 13, "bold")).pack(pady=12)

        body = tk.Frame(dialog, bg=self.bg_color)
        body.pack(padx=30, fill=tk.X)

        # I have a: STUD / LUG
        tk.Label(body, text="I have a:", bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 10)).grid(row=0, column=0, sticky='w', pady=6)

        have_type_var = tk.StringVar(value='2PC STUD')
        type_frame = tk.Frame(body, bg=self.bg_color)
        type_frame.grid(row=0, column=1, sticky='w', padx=8)
        tk.Radiobutton(type_frame, text="STUD", variable=have_type_var, value='2PC STUD',
                       bg=self.bg_color, fg=self.fg_color, selectcolor=self.input_bg,
                       activebackground=self.bg_color,
                       font=("Arial", 10)).pack(side=tk.LEFT, padx=4)
        tk.Radiobutton(type_frame, text="LUG", variable=have_type_var, value='2PC LUG',
                       bg=self.bg_color, fg=self.fg_color, selectcolor=self.input_bg,
                       activebackground=self.bg_color,
                       font=("Arial", 10)).pack(side=tk.LEFT, padx=4)

        # CB input
        tk.Label(body, text="Matching piece CB:", bg=self.bg_color, fg=self.fg_color,
                 font=("Arial", 10)).grid(row=1, column=0, sticky='w', pady=8)

        cb_frame = tk.Frame(body, bg=self.bg_color)
        cb_frame.grid(row=1, column=1, sticky='w', padx=8)
        cb_entry = tk.Entry(cb_frame, bg=self.input_bg, fg=self.fg_color,
                            font=("Arial", 11), width=10)
        cb_entry.pack(side=tk.LEFT)
        tk.Label(cb_frame, text="mm", bg=self.bg_color, fg="#888888",
                 font=("Arial", 10)).pack(side=tk.LEFT, padx=4)

        cb_entry.focus_set()

        tk.Label(dialog, text="Sorted by CB proximity  ·  ring fit graded against hub OD table",
                 bg=self.bg_color, fg="#666666", font=("Arial", 8, "italic")).pack(pady=4)

        def do_search():
            cb_str = cb_entry.get().strip()
            if not cb_str:
                messagebox.showerror("Missing CB", "Please enter the target center bore in mm", parent=dialog)
                return
            try:
                target_cb = float(cb_str)
            except ValueError:
                messagebox.showerror("Invalid CB", "Please enter a valid numeric value", parent=dialog)
                return
            if target_cb <= 0:
                messagebox.showerror("Invalid CB", "CB must be a positive number", parent=dialog)
                return
            dialog.destroy()
            self._show_2pc_cb_results(have_type_var.get(), target_cb)

        cb_entry.bind('<Return>', lambda e: do_search())

        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=12)
        tk.Button(btn_frame, text="Search", command=do_search,
                  bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                  width=10).pack(side=tk.LEFT, padx=6)
        tk.Button(btn_frame, text="Cancel", command=dialog.destroy,
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                  width=10).pack(side=tk.LEFT, padx=6)

        dialog.wait_window()

    def _show_2pc_cb_results(self, have_type, target_cb_mm):
        """
        Query opposite-type 2PC programs, score ring fit, and display in a results window
        sorted by CB proximity then fit quality.
        """
        if '2PC STUD' in have_type:
            search_type_pattern = '%2PC LUG%'
            have_label, find_label = 'STUD', 'LUG'
        else:
            search_type_pattern = '%2PC STUD%'
            have_label, find_label = 'LUG', 'STUD'

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("""
                SELECT program_number, title, outer_diameter, center_bore,
                       thickness, hub_height, hub_diameter, counter_bore_depth,
                       counter_bore_diameter, spacer_type, validation_status
                FROM programs
                WHERE spacer_type LIKE ?
                  AND is_deleted = 0
                ORDER BY center_bore
            """, (search_type_pattern,))
            rows = cursor.fetchall()
            conn.close()
        except sqlite3.Error as e:
            messagebox.showerror("Database Error", f"Failed to query programs: {e}")
            return

        if not rows:
            messagebox.showinfo("No Results", f"No {find_label} programs found in the database.")
            return

        # Build, score, and sort results
        results = []
        for row in rows:
            prog = {
                'program_number': row[0], 'title': row[1], 'outer_diameter': row[2],
                'center_bore': row[3], 'thickness': row[4], 'hub_height': row[5],
                'hub_diameter': row[6], 'counter_bore_depth': row[7],
                'counter_bore_diameter': row[8], 'spacer_type': row[9],
                'validation_status': row[10],
            }
            cb = prog['center_bore']
            prog['cb_diff'] = abs(cb - target_cb_mm) if cb is not None else 9999
            label, score = self._eval_2pc_ring_fit(prog)
            prog['ring_fit_label'] = label
            prog['ring_fit_score'] = score
            results.append(prog)

        results.sort(key=lambda x: (x['cb_diff'], x['ring_fit_score']))

        # Look up expected hub OD for the target CB
        hub_info = '—'
        for cb_min, cb_max, hub_ods, desc in TWOPC_RING_TABLE:
            if cb_min <= target_cb_mm < cb_max:
                hub_ods_str = ' or '.join(f'{h:.3f}"' for h in hub_ods)
                hub_info = f'{hub_ods_str}  ({desc})'
                break

        # ── Results window ─────────────────────────────────────────────────────
        win = tk.Toplevel(self.root)
        win.title(f"2PC {find_label} Matches — CB ≈ {target_cb_mm:.1f} mm")
        win.geometry("1150x650")
        win.configure(bg=self.bg_color)

        # Header
        hdr = tk.Frame(win, bg=self.bg_color)
        hdr.pack(fill=tk.X, padx=10, pady=8)
        tk.Label(hdr,
                 text=f"Matching {find_label} programs  ·  You have a {have_label}  ·  Target CB = {target_cb_mm:.1f} mm",
                 bg=self.bg_color, fg=self.fg_color, font=("Arial", 12, "bold")).pack()
        tk.Label(hdr,
                 text=f"Expected hub/ring OD for CB {target_cb_mm:.1f} mm:  {hub_info}",
                 bg=self.bg_color, fg="#FF9800", font=("Arial", 10)).pack(pady=2)
        tk.Label(hdr,
                 text=f"{len(results)} {find_label} programs — sorted by CB proximity, then ring fit quality",
                 bg=self.bg_color, fg="#888888", font=("Arial", 9)).pack()

        # Treeview
        tree_frame = tk.Frame(win, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        if find_label == 'LUG':
            cols   = ('prog', 'cb', 'cb_diff', 'od', 'thick', 'cbd_mm', 'cbd_in', 'depth', 'ring_fit', 'status')
            hdrs   = ('Prog #', 'CB (mm)', 'CB Diff', 'OD', 'Thick', 'CBD (mm)', 'CBD (in)', 'Depth', 'Ring Fit', 'Status')
            widths = (80, 70, 65, 65, 65, 78, 82, 68, 270, 85)
        else:  # STUD
            cols   = ('prog', 'cb', 'cb_diff', 'od', 'thick', 'hub_d', 'hub_h', 'ring_fit', 'status')
            hdrs   = ('Prog #', 'CB (mm)', 'CB Diff', 'OD', 'Thick', 'Hub OD (mm)', 'Hub H', 'Ring Fit', 'Status')
            widths = (80, 70, 65, 65, 65, 90, 68, 320, 85)

        tree = ttk.Treeview(tree_frame, columns=cols, show='headings', height=24)
        for col, hdr_text, w in zip(cols, hdrs, widths):
            tree.heading(col, text=hdr_text)
            tree.column(col, width=w, anchor='w')

        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        hsb.grid(row=1, column=0, sticky='ew')
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        tree.tag_configure('good',     foreground='#4CAF50')
        tree.tag_configure('warn',     foreground='#FF9800')
        tree.tag_configure('bad',      foreground='#F44336')
        tree.tag_configure('exact_cb', background='#1a3a1a')

        # Populate rows
        for prog in results:
            cb        = prog.get('center_bore')
            cb_str    = f"{cb:.1f}" if cb is not None else '—'
            cb_diff   = prog.get('cb_diff', 9999)
            diff_str  = f"{cb_diff:+.1f}" if cb_diff < 9999 else '—'
            od        = prog.get('outer_diameter')
            od_str    = f'{od:.2f}"' if od else '—'
            thick     = prog.get('thickness')
            thick_str = f'{thick:.3f}"' if thick else '—'
            fit_score = prog.get('ring_fit_score', 99)
            fit_label = prog.get('ring_fit_label', '—')
            status    = prog.get('validation_status') or ''

            fit_tag   = 'good' if fit_score <= 1 else ('warn' if fit_score <= 4 else 'bad')
            item_tags = (fit_tag, 'exact_cb') if cb_diff < 0.5 else (fit_tag,)

            if find_label == 'LUG':
                cbd_mm  = prog.get('counter_bore_diameter')
                cbd_mm_str = f'{cbd_mm:.1f}' if cbd_mm else '—'
                cbd_in_str = f'{cbd_mm/25.4:.4f}"' if cbd_mm else '—'
                depth      = prog.get('counter_bore_depth')
                depth_str  = f'{depth:.3f}"' if depth is not None else '—'
                tree.insert('', 'end', tags=item_tags, values=(
                    prog['program_number'], cb_str, diff_str, od_str, thick_str,
                    cbd_mm_str, cbd_in_str, depth_str, fit_label, status))
            else:
                hub_d     = prog.get('hub_diameter')
                hub_d_str = f'{hub_d:.1f}' if hub_d else '—'
                hub_h     = prog.get('hub_height')
                hub_h_str = f'{hub_h:.3f}"' if hub_h is not None else '—'
                tree.insert('', 'end', tags=item_tags, values=(
                    prog['program_number'], cb_str, diff_str, od_str, thick_str,
                    hub_d_str, hub_h_str, fit_label, status))

        # Footer
        footer = tk.Frame(win, bg=self.bg_color)
        footer.pack(fill=tk.X, padx=10, pady=8)
        tk.Label(footer,
                 text='Green = ring fit in spec (0.003–0.005" cl, depth ≥ 0.300")  |  Orange = minor issue  |  Red = mismatch  |  Dark background = exact CB match',
                 bg=self.bg_color, fg="#888888", font=("Arial", 8)).pack(side=tk.LEFT)
        tk.Button(footer, text="Close", command=win.destroy,
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                  width=10).pack(side=tk.RIGHT, padx=5)

    def show_resolve_suffixes(self):
        """Show dialog to find and resolve programs with suffix placeholders like (1), _1"""

        # Find suffix programs
        suffix_programs = self.find_suffix_programs()

        if not suffix_programs:
            messagebox.showinfo("No Suffixes Found",
                "No programs with suffix placeholders found.\n\n"
                "Suffixes like (1), (2), _1, _2 are temporary placeholders\n"
                "assigned during batch scanning to avoid collisions.\n\n"
                "All programs have proper unique numbers.")
            return

        # Create dialog
        suffix_win = tk.Toplevel(self.root)
        suffix_win.title("Resolve Suffix Placeholders")
        suffix_win.geometry("900x600")
        suffix_win.configure(bg=self.bg_color)

        # Header
        header_frame = tk.Frame(suffix_win, bg=self.bg_color)
        header_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(header_frame,
                text=f"Found {len(suffix_programs)} programs with suffix placeholders",
                bg=self.bg_color, fg="#FF9800", font=("Arial", 14, "bold")).pack(pady=5)

        tk.Label(header_frame,
                text="These temporary suffixes will be replaced with proper unique program numbers",
                bg=self.bg_color, fg="#888888", font=("Arial", 10)).pack()

        # Create treeview
        tree_frame = tk.Frame(suffix_win, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        columns = ('program', 'base', 'suffix', 'title', 'od', 'new_number')
        tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=20)

        tree.heading('program', text='Current Program #')
        tree.heading('base', text='Base Number')
        tree.heading('suffix', text='Suffix')
        tree.heading('title', text='Title')
        tree.heading('od', text='OD')
        tree.heading('new_number', text='New Number (Preview)')

        tree.column('program', width=120)
        tree.column('base', width=100)
        tree.column('suffix', width=60)
        tree.column('title', width=300)
        tree.column('od', width=60)
        tree.column('new_number', width=120)

        # Scrollbar
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=vsb.set)

        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Populate tree
        for prog in suffix_programs:
            tree.insert('', 'end', values=(
                prog['program_number'],
                prog['base_number'],
                prog['suffix'],
                prog['title'] or '',
                f"{prog['outer_diameter']}\"" if prog['outer_diameter'] else '',
                '(click Preview)'
            ))

        # Button frame
        btn_frame = tk.Frame(suffix_win, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        def preview_resolution():
            """Preview what new numbers would be assigned"""
            # Clear existing previews
            for item in tree.get_children():
                values = list(tree.item(item, 'values'))
                values[5] = '...'
                tree.item(item, values=values)

            suffix_win.update()

            # Run dry run
            stats = self.resolve_all_suffix_programs(dry_run=True)

            # Update tree with preview numbers
            rename_map = {r['old']: r['new'] for r in stats['renames']}
            error_map = {e['program']: e['error'] for e in stats['errors']}

            for item in tree.get_children():
                values = list(tree.item(item, 'values'))
                prog_num = values[0]

                if prog_num in rename_map:
                    values[5] = rename_map[prog_num]
                elif prog_num in error_map:
                    values[5] = f"ERROR: {error_map[prog_num][:30]}"
                else:
                    values[5] = '?'

                tree.item(item, values=values)

            messagebox.showinfo("Preview Complete",
                f"Preview generated:\n\n"
                f"Can resolve: {stats['resolved']}\n"
                f"Errors: {stats['failed']}\n\n"
                f"Click 'Resolve All' to apply these changes.")

        def resolve_all():
            """Actually resolve all suffix programs"""
            if not messagebox.askyesno("Confirm Resolution",
                f"This will rename {len(suffix_programs)} programs to proper unique numbers.\n\n"
                "Both the database records AND the actual files will be renamed.\n\n"
                "This operation cannot be undone. Continue?"):
                return

            # Create auto-backup before this destructive operation
            backup_path = self.create_auto_backup("resolve_suffixes")
            if backup_path:
                logger.info("Auto-backup created before resolving suffixes")

            # Create progress dialog
            progress_win = tk.Toplevel(suffix_win)
            progress_win.title("Resolving Suffixes...")
            progress_win.geometry("400x150")
            progress_win.configure(bg=self.bg_color)
            progress_win.transient(suffix_win)
            progress_win.grab_set()

            progress_label = tk.Label(progress_win, text="Starting...",
                                     bg=self.bg_color, fg=self.fg_color, font=("Arial", 10))
            progress_label.pack(pady=30)

            progress_bar = ttk.Progressbar(progress_win, length=300, mode='determinate')
            progress_bar.pack(pady=10)

            def update_progress(current, total, message):
                progress_label.config(text=message)
                progress_bar['value'] = (current / total) * 100
                progress_win.update()

            # Run resolution
            stats = self.resolve_all_suffix_programs(dry_run=False, progress_callback=update_progress)

            progress_win.destroy()

            # Show results
            result_msg = f"Resolution Complete!\n\n"
            result_msg += f"Resolved: {stats['resolved']}\n"
            result_msg += f"Failed: {stats['failed']}\n"

            if stats['errors']:
                result_msg += f"\nErrors:\n"
                for err in stats['errors'][:5]:  # Show first 5 errors
                    result_msg += f"  {err['program']}: {err['error'][:40]}\n"
                if len(stats['errors']) > 5:
                    result_msg += f"  ... and {len(stats['errors']) - 5} more\n"

            messagebox.showinfo("Resolution Complete", result_msg)

            # Refresh UI
            self.cascade_refresh('suffix_resolution')
            suffix_win.destroy()

        tk.Button(btn_frame, text="👁️ Preview", command=preview_resolution,
                 bg="#2196F3", fg="white", font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="✅ Resolve All", command=resolve_all,
                 bg="#4CAF50", fg="white", font=("Arial", 10, "bold"),
                 width=12).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=suffix_win.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=10).pack(side=tk.RIGHT, padx=5)

        # Info
        tk.Label(btn_frame,
                text="Click 'Preview' first to see what numbers will be assigned",
                bg=self.bg_color, fg="#888888", font=("Arial", 9)).pack(side=tk.LEFT, padx=20)

    def show_extended_integrity_check(self):
        """Show extended integrity check results in a dialog"""
        from datetime import datetime, timedelta

        # Create progress dialog
        progress_win = tk.Toplevel(self.root)
        progress_win.title("Running Integrity Check...")
        progress_win.geometry("400x150")
        progress_win.configure(bg=self.bg_color)
        progress_win.transient(self.root)
        progress_win.grab_set()

        tk.Label(progress_win, text="Running extended integrity check...",
                bg=self.bg_color, fg=self.fg_color, font=("Arial", 12)).pack(pady=20)

        progress_label = tk.Label(progress_win, text="Please wait...",
                                 bg=self.bg_color, fg="#888888", font=("Arial", 10))
        progress_label.pack(pady=10)

        progress_win.update()

        # Run the check
        try:
            result = self.run_extended_integrity_check(fix_issues=False)
        except Exception as e:
            progress_win.destroy()
            messagebox.showerror("Error", f"Integrity check failed: {str(e)}")
            return

        progress_win.destroy()

        # Create results window
        results_win = tk.Toplevel(self.root)
        results_win.title("Extended Integrity Check Results")
        results_win.geometry("900x700")
        results_win.configure(bg=self.bg_color)

        # Summary header
        summary_frame = tk.Frame(results_win, bg=self.bg_color)
        summary_frame.pack(fill=tk.X, padx=10, pady=10)

        summary = result['summary']
        if summary['total_issues'] == 0:
            summary_text = "All checks passed! No issues found."
            summary_color = "#4CAF50"
        else:
            summary_text = f"Found {summary['total_issues']} issues: {summary['critical']} critical, {summary['warnings']} warnings"
            summary_color = "#F44336" if summary['critical'] > 0 else "#FF9800"

        tk.Label(summary_frame, text=summary_text,
                bg=self.bg_color, fg=summary_color, font=("Arial", 14, "bold")).pack(pady=10)

        # Notebook for different check results
        notebook = ttk.Notebook(results_win)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Tab 1: Basic Integrity (untracked, orphaned, registry)
        tab_basic = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_basic, text=f'📁 Basic ({len(result["basic"]["untracked_files"]) + len(result["basic"]["orphaned_records"]) if result["basic"] else 0})')

        basic_text = scrolledtext.ScrolledText(tab_basic, bg=self.input_bg, fg=self.fg_color,
                                               font=("Courier", 9), wrap=tk.WORD)
        basic_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        if result['basic']:
            basic_text.insert(tk.END, "=== UNTRACKED FILES (in repo but not in DB) ===\n\n")
            if result['basic']['untracked_files']:
                for f in result['basic']['untracked_files']:
                    basic_text.insert(tk.END, f"  {os.path.basename(f)}\n")
            else:
                basic_text.insert(tk.END, "  None found\n")

            basic_text.insert(tk.END, "\n=== ORPHANED RECORDS (in DB but file missing) ===\n\n")
            if result['basic']['orphaned_records']:
                for rec in result['basic']['orphaned_records']:
                    basic_text.insert(tk.END, f"  {rec['program_number']}: {rec['file_path']}\n")
            else:
                basic_text.insert(tk.END, "  None found\n")

            basic_text.insert(tk.END, "\n=== STALE REGISTRY ENTRIES ===\n\n")
            if result['basic']['registry_stale']:
                for rec in result['basic']['registry_stale']:
                    basic_text.insert(tk.END, f"  {rec['program_number']}\n")
            else:
                basic_text.insert(tk.END, "  None found\n")

        # Tab 2: Missing M30
        tab_m30 = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_m30, text=f'⚠️ Missing M30 ({len(result["missing_m30"])})')

        m30_text = scrolledtext.ScrolledText(tab_m30, bg=self.input_bg, fg=self.fg_color,
                                            font=("Courier", 9), wrap=tk.WORD)
        m30_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        m30_text.insert(tk.END, "=== PROGRAMS MISSING M30/M02 END CODE ===\n\n")
        m30_text.insert(tk.END, "These programs may not have proper program end codes.\n")
        m30_text.insert(tk.END, "This could cause issues on some CNC machines.\n\n")

        if result['missing_m30']:
            for prog in result['missing_m30']:
                m30_text.insert(tk.END, f"  {prog['program_number']}: {prog['title'] or 'No title'}\n")
        else:
            m30_text.insert(tk.END, "  All programs have proper end codes!\n")

        # Tab 3: Duplicate Internal O-Numbers
        tab_dup = tk.Frame(notebook, bg=self.bg_color)
        dup_count = len(result['duplicate_internal_numbers']['mismatched']) + len(result['duplicate_internal_numbers']['duplicates'])
        notebook.add(tab_dup, text=f'🔢 O-Number Issues ({dup_count})')

        dup_text = scrolledtext.ScrolledText(tab_dup, bg=self.input_bg, fg=self.fg_color,
                                            font=("Courier", 9), wrap=tk.WORD)
        dup_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        dup_text.insert(tk.END, "=== FILENAME/INTERNAL O-NUMBER MISMATCHES ===\n\n")
        dup_text.insert(tk.END, "Files where the filename differs from the internal O-number.\n")
        dup_text.insert(tk.END, "Use 'Sync Filenames' to fix these.\n\n")

        if result['duplicate_internal_numbers']['mismatched']:
            for mis in result['duplicate_internal_numbers']['mismatched']:
                dup_text.insert(tk.END, f"  {mis['program_number']} -> Internal: {mis['internal_number']}\n")
        else:
            dup_text.insert(tk.END, "  None found\n")

        dup_text.insert(tk.END, "\n=== DUPLICATE INTERNAL O-NUMBERS ===\n\n")
        dup_text.insert(tk.END, "Multiple files with the same internal O-number (CRITICAL).\n\n")

        if result['duplicate_internal_numbers']['duplicates']:
            for internal_num, files in result['duplicate_internal_numbers']['duplicates'].items():
                dup_text.insert(tk.END, f"  Internal {internal_num}:\n")
                for f in files:
                    dup_text.insert(tk.END, f"    - {f['program_number']}\n")
        else:
            dup_text.insert(tk.END, "  None found\n")

        # Tab 4: Stale Records
        tab_stale = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_stale, text=f'📅 Stale Records ({len(result["stale_records"])})')

        stale_text = scrolledtext.ScrolledText(tab_stale, bg=self.input_bg, fg=self.fg_color,
                                              font=("Courier", 9), wrap=tk.WORD)
        stale_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        stale_text.insert(tk.END, "=== STALE DATABASE RECORDS ===\n\n")
        stale_text.insert(tk.END, "Files that have been modified since last database scan.\n")
        stale_text.insert(tk.END, "Use 'Rescan Changed' to update these.\n\n")

        if result['stale_records']:
            for rec in result['stale_records']:
                stale_text.insert(tk.END, f"  {rec['program_number']}:\n")
                stale_text.insert(tk.END, f"    DB: {rec['db_modified']}\n")
                stale_text.insert(tk.END, f"    File: {rec['file_modified']}\n\n")
        else:
            stale_text.insert(tk.END, "  All records are up to date!\n")

        # Tab 5: Zero-Byte Files
        tab_zero = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_zero, text=f'📄 Zero-Byte ({len(result["zero_byte_files"])})')

        zero_text = scrolledtext.ScrolledText(tab_zero, bg=self.input_bg, fg=self.fg_color,
                                             font=("Courier", 9), wrap=tk.WORD)
        zero_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        zero_text.insert(tk.END, "=== ZERO-BYTE (EMPTY) FILES ===\n\n")
        zero_text.insert(tk.END, "These files are empty and should be investigated.\n")
        zero_text.insert(tk.END, "They may be corrupted or placeholder files.\n\n")

        if result['zero_byte_files']:
            for zb in result['zero_byte_files']:
                status = "IN DB" if zb['in_database'] else "NOT IN DB"
                zero_text.insert(tk.END, f"  {zb['program_number']} [{status}]\n")
                zero_text.insert(tk.END, f"    {zb['file_path']}\n\n")
        else:
            zero_text.insert(tk.END, "  No empty files found!\n")

        # Button frame
        btn_frame = tk.Frame(results_win, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        def fix_all_issues():
            if messagebox.askyesno("Fix Issues",
                "This will:\n"
                "- Add untracked files to database\n"
                "- Remove orphaned records\n"
                "- Fix stale registry entries\n"
                "- Refresh stale file records\n"
                "- Remove zero-byte entries from DB\n\n"
                "Continue?"):
                results_win.destroy()
                fix_result = self.run_extended_integrity_check(fix_issues=True)
                self.cascade_refresh('integrity_fix')
                messagebox.showinfo("Fixed",
                    f"Issues fixed:\n"
                    f"- Files added: {fix_result['basic']['fixed']['files_added'] if fix_result['basic'] else 0}\n"
                    f"- Records removed: {fix_result['basic']['fixed']['records_removed'] if fix_result['basic'] else 0}\n"
                    f"- Registry updated: {fix_result['basic']['fixed']['registry_updated'] if fix_result['basic'] else 0}\n"
                    f"- Stale refreshed: {fix_result['fixed']['stale_refreshed']}\n"
                    f"- Zero-byte removed: {fix_result['fixed']['zero_byte_removed']}")

        tk.Button(btn_frame, text="🔧 Fix All Issues", command=fix_all_issues,
                 bg="#4CAF50", fg="white", font=("Arial", 10, "bold"),
                 width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="🔄 Refresh Check", command=lambda: [results_win.destroy(), self.show_extended_integrity_check()],
                 bg="#2196F3", fg="white", font=("Arial", 10, "bold"),
                 width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=results_win.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                 width=10).pack(side=tk.RIGHT, padx=5)

    def show_statistics(self):
        """Show comprehensive database statistics with filtering support"""
        stats_window = tk.Toplevel(self.root)
        stats_window.title("Database Statistics")
        stats_window.geometry("1200x800")
        stats_window.configure(bg=self.bg_color)

        # Create notebook for different stat views
        notebook = ttk.Notebook(stats_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Get current filters to show filtered vs total stats
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Build filter query
        filter_query = "SELECT COUNT(*) FROM programs WHERE 1=1"
        filter_params = []

        # Apply current filters
        if hasattr(self, 'filter_od_min') and self.filter_od_min.get():
            filter_query += " AND outer_diameter >= ?"
            filter_params.append(float(self.filter_od_min.get()))
        if hasattr(self, 'filter_od_max') and self.filter_od_max.get():
            filter_query += " AND outer_diameter <= ?"
            filter_params.append(float(self.filter_od_max.get()))
        if hasattr(self, 'filter_thickness_min') and self.filter_thickness_min.get():
            filter_query += " AND thickness >= ?"
            filter_params.append(float(self.filter_thickness_min.get()))
        if hasattr(self, 'filter_thickness_max') and self.filter_thickness_max.get():
            filter_query += " AND thickness <= ?"
            filter_params.append(float(self.filter_thickness_max.get()))
        if hasattr(self, 'filter_cb_min') and self.filter_cb_min.get():
            filter_query += " AND center_bore >= ?"
            filter_params.append(float(self.filter_cb_min.get()))
        if hasattr(self, 'filter_cb_max') and self.filter_cb_max.get():
            filter_query += " AND center_bore <= ?"
            filter_params.append(float(self.filter_cb_max.get()))

        # Check if any filters are active
        filters_active = len(filter_params) > 0

        # TAB 1: Overall Statistics
        tab_overall = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_overall, text='📊 Overall')

        overall_text = scrolledtext.ScrolledText(tab_overall, bg=self.input_bg, fg=self.fg_color,
                                                 font=("Courier", 10), wrap=tk.NONE, padx=10, pady=10)
        overall_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Get total count
        cursor.execute("SELECT COUNT(*) FROM programs")
        total_count = cursor.fetchone()[0]

        # Get filtered count
        cursor.execute(filter_query, filter_params)
        filtered_count = cursor.fetchone()[0]

        overall_text.insert(tk.END, "="*100 + "\n")
        overall_text.insert(tk.END, "DATABASE STATISTICS - OVERALL SUMMARY\n")
        overall_text.insert(tk.END, "="*100 + "\n\n")

        if filters_active:
            overall_text.insert(tk.END, f"Total Programs in Database: {total_count:,}\n")
            overall_text.insert(tk.END, f"Filtered View: {filtered_count:,} ({filtered_count/total_count*100:.1f}%)\n\n")
            overall_text.insert(tk.END, "NOTE: Statistics below show FILTERED data only\n")
            overall_text.insert(tk.END, "="*100 + "\n\n")
        else:
            overall_text.insert(tk.END, f"Total Programs: {total_count:,}\n")
            overall_text.insert(tk.END, "="*100 + "\n\n")

        # Validation Status Breakdown
        if filter_params:
            status_query = filter_query.replace("SELECT COUNT(*)", "SELECT validation_status, COUNT(*)") + " GROUP BY validation_status ORDER BY validation_status"
        else:
            status_query = "SELECT validation_status, COUNT(*) FROM programs GROUP BY validation_status ORDER BY validation_status"

        cursor.execute(status_query, filter_params)
        status_results = cursor.fetchall()

        overall_text.insert(tk.END, "VALIDATION STATUS BREAKDOWN:\n")
        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'Status':<20} {'Count':>10} {'Percentage':>12}\n")
        overall_text.insert(tk.END, "-"*100 + "\n")

        status_total = sum(r[1] for r in status_results)
        for status, count in status_results:
            percentage = (count / status_total * 100) if status_total > 0 else 0
            overall_text.insert(tk.END, f"{status or 'NULL':<20} {count:>10,} {percentage:>11.1f}%\n")

        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'TOTAL':<20} {status_total:>10,} {100.0:>11.1f}%\n\n\n")

        # Spacer Type Breakdown
        if filter_params:
            type_query = filter_query.replace("SELECT COUNT(*)", "SELECT spacer_type, COUNT(*)") + " GROUP BY spacer_type ORDER BY COUNT(*) DESC"
        else:
            type_query = "SELECT spacer_type, COUNT(*) FROM programs GROUP BY spacer_type ORDER BY COUNT(*) DESC"

        cursor.execute(type_query, filter_params)
        type_results = cursor.fetchall()

        overall_text.insert(tk.END, "SPACER TYPE BREAKDOWN:\n")
        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'Type':<25} {'Count':>10} {'Percentage':>12}\n")
        overall_text.insert(tk.END, "-"*100 + "\n")

        type_total = sum(r[1] for r in type_results)
        for stype, count in type_results:
            percentage = (count / type_total * 100) if type_total > 0 else 0
            overall_text.insert(tk.END, f"{stype or 'NULL':<25} {count:>10,} {percentage:>11.1f}%\n")

        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'TOTAL':<25} {type_total:>10,} {100.0:>11.1f}%\n\n\n")

        # Material Breakdown
        if filter_params:
            material_query = filter_query.replace("SELECT COUNT(*)", "SELECT material, COUNT(*)") + " GROUP BY material ORDER BY COUNT(*) DESC"
        else:
            material_query = "SELECT material, COUNT(*) FROM programs GROUP BY material ORDER BY COUNT(*) DESC"

        cursor.execute(material_query, filter_params)
        material_results = cursor.fetchall()

        overall_text.insert(tk.END, "MATERIAL BREAKDOWN:\n")
        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'Material':<25} {'Count':>10} {'Percentage':>12}\n")
        overall_text.insert(tk.END, "-"*100 + "\n")

        material_total = sum(r[1] for r in material_results)
        for material, count in material_results:
            percentage = (count / material_total * 100) if material_total > 0 else 0
            overall_text.insert(tk.END, f"{material or 'NULL':<25} {count:>10,} {percentage:>11.1f}%\n")

        overall_text.insert(tk.END, "-"*100 + "\n")
        overall_text.insert(tk.END, f"{'TOTAL':<25} {material_total:>10,} {100.0:>11.1f}%\n")

        overall_text.config(state=tk.DISABLED)

        # TAB 2: By OD Size
        tab_od = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_od, text='📏 By OD Size')

        od_text = scrolledtext.ScrolledText(tab_od, bg=self.input_bg, fg=self.fg_color,
                                           font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        od_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Define OD ranges
        od_ranges = [
            (5.50, 6.00, '5.75"'),
            (6.00, 6.25, '6.00"'),
            (6.25, 6.50, '6.25"'),
            (6.50, 7.00, '6.50"'),
            (7.00, 7.50, '7.00"'),
            (7.50, 8.00, '7.50"'),
            (8.00, 8.50, '8.00"'),
            (8.50, 9.00, '8.50"'),
            (9.00, 10.00, '9.50"'),
            (10.00, 10.50, '10.25"'),
            (10.50, 11.00, '10.50"'),
            (11.00, 12.00, '11.00"'),
            (12.00, 13.50, '13.00"'),
        ]

        od_text.insert(tk.END, "="*140 + "\n")
        od_text.insert(tk.END, "STATISTICS BY OD SIZE\n")
        od_text.insert(tk.END, "="*140 + "\n\n")

        if filters_active:
            od_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        od_text.insert(tk.END, f"{'OD Size':<10} {'Total':>8} {'PASS':>8} {'CRITICAL':>10} {'DIMENSIONAL':>13} {'WARNING':>9} {'BORE_WARN':>11} {'% PASS':>9}\n")
        od_text.insert(tk.END, "-"*140 + "\n")

        grand_total = 0
        grand_pass = 0
        grand_critical = 0
        grand_dimensional = 0
        grand_warning = 0
        grand_bore = 0

        for min_od, max_od, label in od_ranges:
            # Build query with OD range and optional filters
            od_filter_query = filter_query + " AND outer_diameter >= ? AND outer_diameter < ?"
            od_params = filter_params + [min_od, max_od]

            cursor.execute(od_filter_query, od_params)
            range_total = cursor.fetchone()[0]

            if range_total == 0:
                continue

            # Get status breakdown for this range
            status_query = od_filter_query.replace("SELECT COUNT(*)", "SELECT validation_status, COUNT(*)") + " GROUP BY validation_status"
            cursor.execute(status_query, od_params)
            status_breakdown = dict(cursor.fetchall())

            pass_count = status_breakdown.get('PASS', 0)
            critical_count = status_breakdown.get('CRITICAL', 0)
            dimensional_count = status_breakdown.get('DIMENSIONAL', 0)
            warning_count = status_breakdown.get('WARNING', 0)
            bore_count = status_breakdown.get('BORE_WARNING', 0)
            pass_pct = (pass_count / range_total * 100) if range_total > 0 else 0

            od_text.insert(tk.END, f"{label:<10} {range_total:>8,} {pass_count:>8,} {critical_count:>10,} {dimensional_count:>13,} {warning_count:>9,} {bore_count:>11,} {pass_pct:>8.1f}%\n")

            grand_total += range_total
            grand_pass += pass_count
            grand_critical += critical_count
            grand_dimensional += dimensional_count
            grand_warning += warning_count
            grand_bore += bore_count

        od_text.insert(tk.END, "-"*140 + "\n")
        grand_pass_pct = (grand_pass / grand_total * 100) if grand_total > 0 else 0
        od_text.insert(tk.END, f"{'TOTAL':<10} {grand_total:>8,} {grand_pass:>8,} {grand_critical:>10,} {grand_dimensional:>13,} {grand_warning:>9,} {grand_bore:>11,} {grand_pass_pct:>8.1f}%\n")

        od_text.config(state=tk.DISABLED)

        # TAB 3: Status by OD (matrix view)
        tab_matrix = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_matrix, text='🔢 Status Matrix')

        matrix_text = scrolledtext.ScrolledText(tab_matrix, bg=self.input_bg, fg=self.fg_color,
                                               font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        matrix_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        matrix_text.insert(tk.END, "="*140 + "\n")
        matrix_text.insert(tk.END, "VALIDATION STATUS BY OD SIZE - DETAILED MATRIX\n")
        matrix_text.insert(tk.END, "="*140 + "\n\n")

        if filters_active:
            matrix_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        # Get all validation statuses
        status_list = ['PASS', 'CRITICAL', 'DIMENSIONAL', 'WARNING', 'BORE_WARNING']

        # Create matrix
        for status in status_list:
            matrix_text.insert(tk.END, f"\n{'='*140}\n")
            matrix_text.insert(tk.END, f"{status} BY OD SIZE:\n")
            matrix_text.insert(tk.END, f"{'='*140}\n")
            matrix_text.insert(tk.END, f"{'OD Size':<12} {'Count':>10} {'% of Size':>12} {'% of Status':>14}\n")
            matrix_text.insert(tk.END, "-"*140 + "\n")

            # Get total for this status
            status_filter_query = filter_query + " AND validation_status = ?"
            cursor.execute(status_filter_query, filter_params + [status])
            status_total = cursor.fetchone()[0]

            if status_total == 0:
                matrix_text.insert(tk.END, f"No programs with {status} status\n")
                continue

            status_subtotal = 0
            for min_od, max_od, label in od_ranges:
                od_status_query = filter_query + " AND outer_diameter >= ? AND outer_diameter < ? AND validation_status = ?"
                cursor.execute(od_status_query, filter_params + [min_od, max_od, status])
                count = cursor.fetchone()[0]

                if count == 0:
                    continue

                # Get total for this OD size
                od_total_query = filter_query + " AND outer_diameter >= ? AND outer_diameter < ?"
                cursor.execute(od_total_query, filter_params + [min_od, max_od])
                od_total = cursor.fetchone()[0]

                pct_of_size = (count / od_total * 100) if od_total > 0 else 0
                pct_of_status = (count / status_total * 100) if status_total > 0 else 0

                matrix_text.insert(tk.END, f"{label:<12} {count:>10,} {pct_of_size:>11.1f}% {pct_of_status:>13.1f}%\n")
                status_subtotal += count

            matrix_text.insert(tk.END, "-"*140 + "\n")
            matrix_text.insert(tk.END, f"{'TOTAL':<12} {status_subtotal:>10,} {'':>11} {100.0:>13.1f}%\n")

        matrix_text.config(state=tk.DISABLED)

        # TAB 4: Top Error Types
        tab_errors = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_errors, text='⚠️ Error Types')

        error_text = scrolledtext.ScrolledText(tab_errors, bg=self.input_bg, fg=self.fg_color,
                                              font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        error_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        error_text.insert(tk.END, "="*100 + "\n")
        error_text.insert(tk.END, "TOP ERROR TYPES\n")
        error_text.insert(tk.END, "="*100 + "\n\n")

        if filters_active:
            error_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        # Count different error types from validation_issues
        issues_query = filter_query.replace("SELECT COUNT(*)", "SELECT validation_issues") + " AND validation_issues IS NOT NULL"
        cursor.execute(issues_query, filter_params)
        all_issues = cursor.fetchall()

        # Parse and count error types
        error_counts = {}
        for (issues_str,) in all_issues:
            if not issues_str:
                continue
            # Split by pipe delimiter
            issues = [i.strip() for i in issues_str.split('|') if i.strip()]
            for issue in issues:
                # Extract error type (first part before colon)
                error_type = issue.split(':')[0].strip() if ':' in issue else issue.strip()
                error_counts[error_type] = error_counts.get(error_type, 0) + 1

        # Sort by count
        sorted_errors = sorted(error_counts.items(), key=lambda x: x[1], reverse=True)

        error_text.insert(tk.END, f"{'Error Type':<60} {'Count':>10} {'Percentage':>12}\n")
        error_text.insert(tk.END, "-"*100 + "\n")

        total_errors = sum(error_counts.values())
        for error_type, count in sorted_errors[:20]:  # Top 20 errors
            percentage = (count / total_errors * 100) if total_errors > 0 else 0
            error_text.insert(tk.END, f"{error_type:<60} {count:>10,} {percentage:>11.1f}%\n")

        error_text.insert(tk.END, "-"*100 + "\n")
        error_text.insert(tk.END, f"{'TOTAL ERRORS':<60} {total_errors:>10,} {100.0:>11.1f}%\n\n")

        error_text.insert(tk.END, f"\nTotal programs with errors: {len(all_issues):,}\n")

        error_text.config(state=tk.DISABLED)

        # TAB 5: Status by Type (Detailed breakdown)
        tab_type_status = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_type_status, text='📋 Type & Status')

        type_status_text = scrolledtext.ScrolledText(tab_type_status, bg=self.input_bg, fg=self.fg_color,
                                                     font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        type_status_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        type_status_text.insert(tk.END, "="*140 + "\n")
        type_status_text.insert(tk.END, "VALIDATION STATUS BY SPACER TYPE\n")
        type_status_text.insert(tk.END, "="*140 + "\n\n")

        if filters_active:
            type_status_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        # Get all spacer types
        type_query = "SELECT DISTINCT spacer_type FROM programs WHERE spacer_type IS NOT NULL ORDER BY spacer_type"
        cursor.execute(type_query)
        all_types = [row[0] for row in cursor.fetchall()]

        status_list = ['PASS', 'CRITICAL', 'DIMENSIONAL', 'WARNING', 'BORE_WARNING']

        for spacer_type in all_types:
            type_status_text.insert(tk.END, f"\n{spacer_type.upper()}:\n")
            type_status_text.insert(tk.END, "-"*140 + "\n")
            type_status_text.insert(tk.END, f"{'Status':<20} {'Count':>10} {'% of Type':>12}\n")
            type_status_text.insert(tk.END, "-"*140 + "\n")

            # Get total for this type
            type_total_query = filter_query + " AND spacer_type = ?"
            cursor.execute(type_total_query, filter_params + [spacer_type])
            type_total = cursor.fetchone()[0]

            if type_total == 0:
                continue

            # Get status breakdown
            type_status_query = type_total_query.replace("SELECT COUNT(*)", "SELECT validation_status, COUNT(*)") + " GROUP BY validation_status"
            cursor.execute(type_status_query, filter_params + [spacer_type])
            status_breakdown = dict(cursor.fetchall())

            for status in status_list:
                count = status_breakdown.get(status, 0)
                pct = (count / type_total * 100) if type_total > 0 else 0
                type_status_text.insert(tk.END, f"{status:<20} {count:>10,} {pct:>11.1f}%\n")

            type_status_text.insert(tk.END, "-"*140 + "\n")
            type_status_text.insert(tk.END, f"{'TOTAL':<20} {type_total:>10,} {100.0:>11.1f}%\n")

        type_status_text.config(state=tk.DISABLED)

        # TAB 6: Round Size & Type Matrix
        tab_size_type = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_size_type, text='🔍 Size & Type')

        size_type_text = scrolledtext.ScrolledText(tab_size_type, bg=self.input_bg, fg=self.fg_color,
                                                   font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        size_type_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        size_type_text.insert(tk.END, "="*140 + "\n")
        size_type_text.insert(tk.END, "SPACER TYPE BY ROUND SIZE\n")
        size_type_text.insert(tk.END, "="*140 + "\n\n")

        if filters_active:
            size_type_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        size_type_text.insert(tk.END, f"{'OD Size':<10}")
        for stype in ['hub_centric', 'standard', '2PC LUG', '2PC STUD', 'step', 'STEP']:
            size_type_text.insert(tk.END, f"{stype[:8]:>10}")
        size_type_text.insert(tk.END, f"{'Total':>10}\n")
        size_type_text.insert(tk.END, "-"*140 + "\n")

        for min_od, max_od, label in od_ranges:
            od_filter_query = filter_query + " AND outer_diameter >= ? AND outer_diameter < ?"
            od_params = filter_params + [min_od, max_od]

            cursor.execute(od_filter_query, od_params)
            range_total = cursor.fetchone()[0]

            if range_total == 0:
                continue

            size_type_text.insert(tk.END, f"{label:<10}")

            # Get type breakdown for this OD range
            type_breakdown_query = od_filter_query.replace("SELECT COUNT(*)", "SELECT spacer_type, COUNT(*)") + " GROUP BY spacer_type"
            cursor.execute(type_breakdown_query, od_params)
            type_breakdown = dict(cursor.fetchall())

            for stype in ['hub_centric', 'standard', '2PC LUG', '2PC STUD', 'step', 'STEP']:
                count = type_breakdown.get(stype, 0)
                size_type_text.insert(tk.END, f"{count:>10,}")

            size_type_text.insert(tk.END, f"{range_total:>10,}\n")

        size_type_text.config(state=tk.DISABLED)

        # TAB 7: Errors/Warnings by Round Size
        tab_size_errors = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(tab_size_errors, text='⚠️ Errors by Size')

        size_errors_text = scrolledtext.ScrolledText(tab_size_errors, bg=self.input_bg, fg=self.fg_color,
                                                     font=("Courier", 9), wrap=tk.NONE, padx=10, pady=10)
        size_errors_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        size_errors_text.insert(tk.END, "="*140 + "\n")
        size_errors_text.insert(tk.END, "TOP ERROR TYPES BY ROUND SIZE\n")
        size_errors_text.insert(tk.END, "="*140 + "\n\n")

        if filters_active:
            size_errors_text.insert(tk.END, "NOTE: Showing FILTERED data only\n\n")

        # For each OD range, show top error types
        for min_od, max_od, label in od_ranges:
            od_filter_query = filter_query + " AND outer_diameter >= ? AND outer_diameter < ?"
            od_params = filter_params + [min_od, max_od]

            # Get programs with issues in this range
            issues_query = od_filter_query.replace("SELECT COUNT(*)", "SELECT validation_issues") + " AND validation_issues IS NOT NULL"
            cursor.execute(issues_query, od_params)
            range_issues = cursor.fetchall()

            if not range_issues:
                continue

            size_errors_text.insert(tk.END, f"\n{label} ROUND:\n")
            size_errors_text.insert(tk.END, "-"*140 + "\n")

            # Parse error types for this range
            range_error_counts = {}
            for (issues_str,) in range_issues:
                if not issues_str:
                    continue
                issues = [i.strip() for i in issues_str.split('|') if i.strip()]
                for issue in issues:
                    error_type = issue.split(':')[0].strip() if ':' in issue else issue.strip()
                    range_error_counts[error_type] = range_error_counts.get(error_type, 0) + 1

            # Sort and show top 5 errors
            sorted_range_errors = sorted(range_error_counts.items(), key=lambda x: x[1], reverse=True)

            size_errors_text.insert(tk.END, f"{'Error Type':<60} {'Count':>10}\n")
            size_errors_text.insert(tk.END, "-"*140 + "\n")

            for error_type, count in sorted_range_errors[:5]:
                size_errors_text.insert(tk.END, f"{error_type:<60} {count:>10,}\n")

            total_range_errors = sum(range_error_counts.values())
            size_errors_text.insert(tk.END, "-"*140 + "\n")
            size_errors_text.insert(tk.END, f"Total programs with errors in {label}: {len(range_issues):,} ({total_range_errors:,} total errors)\n")

        size_errors_text.config(state=tk.DISABLED)

        conn.close()

        # Add close button
        close_btn = tk.Button(stats_window, text="Close", command=stats_window.destroy,
                             bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"))
        close_btn.pack(pady=10)

    def show_legend(self):
        """Show validation status legend and help"""
        legend_window = tk.Toplevel(self.root)
        legend_window.title("G-Code Database Manager - Help & Workflow Guide")
        legend_window.geometry("900x900")
        legend_window.configure(bg=self.bg_color)

        # Create scrolled text widget
        text = scrolledtext.ScrolledText(legend_window, bg=self.input_bg, fg=self.fg_color,
                                        font=("Courier", 10), wrap=tk.WORD, padx=15, pady=15)
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Legend content
        legend_content = """
═══════════════════════════════════════════════════════════════════════════════
                      G-CODE DATABASE MANAGER - HELP GUIDE
═══════════════════════════════════════════════════════════════════════════════

TABLE OF CONTENTS:
  1. Production-Ready Workflow (Recommended Steps)
  2. Function Descriptions (What Each Button Does)
  3. Duplicate Handling Strategies
  4. Validation Status Legend
  5. Filtering Tips

═══════════════════════════════════════════════════════════════════════════════
                    1. PRODUCTION-READY WORKFLOW (START HERE!)
═══════════════════════════════════════════════════════════════════════════════

GOAL: Clean catalog with NO duplicate names, NO _dup suffixes, all unique files

STEP 1: INITIAL SCAN
───────────────────────────────────────────────────────────────────────────────
📂 Scan Folder
  • Click "📂 Scan Folder" button (Data tab)
  • Select your main G-code directory
  • This scans ALL files recursively and adds them to database
  • Automatically detects and SKIPS exact duplicates
  • Warns about name collisions (same name, different content)

What Happens:
  ✓ Exact duplicates (same name + content) → Automatically skipped
  ✓ New unique files → Added to database
  ✓ Existing files → Updated if changed
  ⚠️  Name collisions → Warned (you must rename manually before scan)

STEP 2: DETECT DUPLICATES
───────────────────────────────────────────────────────────────────────────────
🔍 Find Repeats
  • Click "🔍 Find Repeats" button (Tools tab)
  • Analyzes ALL files in database for duplicates
  • Classifies duplicates into categories

What Happens:
  • SOLID duplicates: Exact same content, different names
  • NAME_COLLISION: Same name, different content
  • CONTENT_DUP: Same content as parent file
  • Parent/child relationships established

STEP 3: REVIEW DUPLICATES
───────────────────────────────────────────────────────────────────────────────
⚖️ Compare Files
  • Hold Ctrl and click multiple files in the list
  • Click "⚖️ Compare Files" button (Tools tab)
  • View files side-by-side with metadata and G-code preview
  • Decide which to keep, rename, or delete

Decision Process:
  1. If EXACT SAME content but different names:
     → Keep the one with better name (more descriptive)
     → Delete the others from database (file stays on disk)

  2. If SAME NAME but DIFFERENT content:
     → Keep both files BUT rename one
     → Use the rename function to give it a unique name

  3. If similar but slightly different:
     → Compare the G-code to see actual differences
     → Keep the correct/latest version
     → Delete or rename the outdated version

STEP 4: AUTO-ASSIGN NEW O-NUMBERS TO DUPLICATES
───────────────────────────────────────────────────────────────────────────────
📝 Rename Duplicates
  • Filter view first (e.g., Duplicate Type = NAME_COLLISION)
  • Click "📝 Rename Duplicates" button (Tools tab)
  • Finds files with duplicate filenames IN FILTERED VIEW ONLY
  • Assigns new available O-numbers (o59000+)
  • NO _dup suffix - assigns proper clean O-numbers
  • Creates backup before making changes
  • Updates: physical file, internal O-number, database

⚠️  IMPORTANT: Works on FILTERED VIEW ONLY!
  • Filter for the duplicates you want to rename
  • Parent file keeps original name
  • Child files get new O-numbers (o59000, o59001, etc.)
  • All changes are automatic - no manual renaming needed

Preview Mode:
  • Shows exactly what O-numbers will be assigned
  • Review the plan before executing
  • Click Execute to apply changes

STEP 5: DELETE UNWANTED DUPLICATES
───────────────────────────────────────────────────────────────────────────────
🗑️ Delete Filtered View
  • Use filters to show only duplicates
  • Apply filters: Duplicate Type = SOLID, CONTENT_DUP, etc.
  • Click "🗑️ Delete Filtered View" (Tools tab)
  • Deletes from DATABASE ONLY (files stay on disk for safety)

Safety Features:
  • Preview mode shows what will be deleted
  • Database backup created automatically
  • Physical files are NOT deleted (safer)

STEP 6: VERIFY PRODUCTION-READY STATE
───────────────────────────────────────────────────────────────────────────────
✅ Final Checks:
  1. Run Find Repeats again
     → Should find ZERO duplicates

  2. Filter by Validation Status = PASS
     → These are production-ready files

  3. Check total file count
     → All files should have unique O-numbers

  4. Export to CSV for documentation
     → Click "📊 Export CSV" (Reports tab)

═══════════════════════════════════════════════════════════════════════════════
                    2. FUNCTION DESCRIPTIONS (WHAT EACH BUTTON DOES)
═══════════════════════════════════════════════════════════════════════════════

DATA TAB - File Import/Management
───────────────────────────────────────────────────────────────────────────────
📂 Scan Folder
  • Recursively scans a directory for G-code files
  • Parses dimensions, P-codes, and metadata
  • Adds new files, updates existing files
  • Auto-detects exact duplicates (skips them)
  • Warns about name collisions (same name, different content)
  • Shows live progress with file counts

🆕 Scan New Only
  • Scans directory but ONLY adds NEW files
  • Skips files already in database
  • Faster for adding new batches
  • Still detects duplicates and name collisions
  • Use after initial full scan

➕ Add Entry
  • Manually add a single program
  • Fill in all fields manually
  • Use when you need precise control
  • Links to physical file on disk

✏️ Edit Entry
  • Double-click any row OR click this button
  • Modify any field in database
  • Changes save to database
  • Does NOT modify physical file

TOOLS TAB - Duplicate Management
───────────────────────────────────────────────────────────────────────────────
🔍 Find Repeats
  • Analyzes ALL files for duplicates
  • Compares file content (not just names)
  • Creates parent/child relationships
  • Classifies duplicates: SOLID, NAME_COLLISION, CONTENT_DUP
  • Populates duplicate_type column
  • Required before using duplicate filters

⚖️ Compare Files
  • Select 2+ files (Ctrl+Click)
  • Shows side-by-side comparison
  • Displays metadata and G-code content
  • Highlights differences
  • Actions: Keep, Rename, Delete
  • Updates internal O-number when renaming

📝 Rename Duplicates
  • Works on FILTERED VIEW ONLY (not all files)
  • Finds files with same filename in current view
  • Assigns proper available O-numbers (o59000+)
  • NO _dup suffix - assigns clean O-numbers
  • Renames physical files
  • Updates internal O-number in G-code file
  • Updates database program_number
  • Preview mode: See changes before applying
  • Execute mode: Actually renames files
  • Creates automatic backup

📋 Copy Filtered View
  • Copies currently filtered files to new folder
  • Preserves directory structure
  • Only copies files matching active filters
  • Use to extract specific file groups
  • Physical file copy operation

🗑️ Delete Filtered View
  • Deletes currently filtered files from DATABASE
  • Does NOT delete physical files (safer)
  • Preview mode available
  • Creates backup before deletion
  • Use to clean up duplicate entries

REPORTS TAB - Export/Analysis
───────────────────────────────────────────────────────────────────────────────
📊 Export CSV
  • Exports current filtered view to CSV
  • Includes all columns
  • Use for Excel analysis, documentation
  • Respects active filters

📄 Export Unused Numbers
  • Finds gaps in program number sequence
  • Exports available O-numbers
  • Helps when creating new programs
  • Useful for number assignment

🗂️ Organize by OD
  • Groups files by Outer Diameter
  • Creates folders for each OD size
  • Copies files to organized structure
  • Preview mode available

❓ Help/Legend
  • Opens this help guide
  • Workflow documentation
  • Function descriptions
  • Color-coded validation system

═══════════════════════════════════════════════════════════════════════════════
                    3. DUPLICATE HANDLING STRATEGIES
═══════════════════════════════════════════════════════════════════════════════

SCENARIO A: Same Name, Same Content (Exact Duplicates)
───────────────────────────────────────────────────────────────────────────────
Example: O57001.nc in two different folders, identical content

What to do:
  1. Scan Folder → Auto-skips exact duplicates
  2. Find Repeats → Marks as SOLID duplicate
  3. Compare Files → Verify they're identical
  4. Delete one from database (keep the one in primary location)

Result: Only ONE file in database, no confusion

SCENARIO B: Same Name, Different Content (Name Collision)
───────────────────────────────────────────────────────────────────────────────
Example: O57001.nc exists twice but programs are different

THIS IS THE CRITICAL SCENARIO - REQUIRES MANUAL DECISION!

What to do:
  1. Find Repeats → Marks as NAME_COLLISION
  2. Compare Files → View both side-by-side
  3. Decide which is correct:

     Option A - Keep BOTH (they're both valid):
       • Select one file in Compare window
       • Click Rename action
       • Give it a new unique O-number (e.g., O57001A or O59999)
       • System updates filename AND internal O-number
       • Now you have O57001.nc and O59999.nc (both unique)

     Option B - Keep ONE (one is wrong/outdated):
       • Select the wrong one
       • Click Delete action
       • Removes from database (file stays on disk for safety)
       • Correct file remains as O57001.nc

⚠️  NEVER let two different programs share the same O-number!

SCENARIO C: Different Names, Same Content (SOLID Duplicate)
───────────────────────────────────────────────────────────────────────────────
Example: O57001.nc and O57001_backup.nc are identical

What to do:
  1. Find Repeats → Marks as SOLID duplicate
  2. Compare Files → Confirm they're identical
  3. Delete the backup from database
  4. Keep the one with the cleaner name

Result: Single entry with best filename

SCENARIO D: Using Rename Duplicates for Automatic Assignment
───────────────────────────────────────────────────────────────────────────────
Example: You have multiple files named O57001.nc in different folders

Automatic workflow:
  1. Filter: Duplicate Type = NAME_COLLISION
  2. Click "📝 Rename Duplicates" (Tools tab)
  3. Preview mode shows the new O-numbers to be assigned
  4. Execute: Child files automatically renamed to o59000, o59001, etc.
  5. System updates:
     • Physical filename (O57001.nc → o59000.nc)
     • Internal O-number (O57001 → O59000)
     • Database program_number

Result: All files have unique O-numbers (NO _dup suffix!)
  • Parent keeps original: O57001.nc
  • Child 1: o59000.nc
  • Child 2: o59001.nc
  • All are production-ready with proper O-numbers

═══════════════════════════════════════════════════════════════════════════════
                    4. VALIDATION STATUS LEGEND
═══════════════════════════════════════════════════════════════════════════════

The database uses a 5-color validation system to categorize issues by severity.

═══════════════════════════════════════════════════════════════════════════════

🔴 RED - CRITICAL (Highest Priority)
═══════════════════════════════════════════════════════════════════
Status: CRITICAL

What It Means:
  • Critical dimensional errors that will produce WRONG parts
  • CB or OB dimensions way outside tolerance (>±0.2-0.3mm)
  • Thickness errors beyond ±0.02"
  • Part CANNOT be used without G-code correction

Examples:
  • CB TOO SMALL: Spec=71.0mm, G-code=66.0mm (-4.96mm)
  • OB TOO LARGE: Spec=64.1mm, G-code=66.5mm (+2.40mm)
  • THICKNESS ERROR: Spec=0.75", Calculated=0.80" (+0.05")

Action Required: ⚠️ IMMEDIATE FIX NEEDED
  • Stop production
  • Fix G-code before running
  • These errors will cause part failures or machine crashes

───────────────────────────────────────────────────────────────────

🟠 ORANGE - BORE WARNING (High Priority)
═══════════════════════════════════════════════════════════════════
Status: BORE_WARNING

What It Means:
  • Bore dimensions at tolerance limits (CB/OB within ±0.1-0.2mm)
  • Part is still within spec but close to the edge
  • May cause fit issues in assembly

Examples:
  • CB at tolerance limit: Spec=38.1mm, G-code=38.2mm (+0.10mm)
  • OB at tolerance limit: Spec=64.1mm, G-code=64.0mm (-0.10mm)

Action Required: 🔍 VERIFY CAREFULLY
  • Check dimensions carefully during setup
  • Verify first article measurement
  • Part is technically acceptable but borderline
  • Consider adjusting G-code for better margin

───────────────────────────────────────────────────────────────────

🟣 PURPLE - DIMENSIONAL (Medium Priority)
═══════════════════════════════════════════════════════════════════
Status: DIMENSIONAL

What It Means:
  • P-code and thickness mismatches (setup dimension issues)
  • Wrong work offset for part thickness
  • Drill depth calculations slightly off (±0.01-0.02")
  • Work offsets don't match part thickness

Examples:
  • P-CODE MISMATCH: Thickness 1.00" expects P15/P16, but found [17,18]
  • Thickness mismatch: Spec=0.75", Calculated=0.76" (+0.01")

Action Required: 🔧 REVIEW SETUP
  • Check work offset (P-code) settings
  • Verify drill depth matches part thickness
  • Part may run but could have setup issues
  • Update P-codes or drill depth to match

───────────────────────────────────────────────────────────────────

🟡 YELLOW - WARNING (Low Priority)
═══════════════════════════════════════════════════════════════════
Status: WARNING

What It Means:
  • General warnings that don't affect critical dimensions
  • P-code pairing issues (missing OP1 or OP2)
  • Multiple P-codes found (possible copy/paste error)
  • OD slightly off (non-critical)

Examples:
  • P-CODE PAIRING: P15 found but P16 missing
  • MULTIPLE P-CODES: Found [15,16,17,18] - should only have one pair
  • OD tolerance check: Spec=5.75", G-code=5.71" (-0.04")

Action Required: 📋 REVIEW WHEN CONVENIENT
  • Check for copy/paste errors
  • Verify P-code pairing
  • Not urgent but should be fixed eventually

───────────────────────────────────────────────────────────────────

🟢 GREEN - PASS (No Issues)
═══════════════════════════════════════════════════════════════════
Status: PASS

What It Means:
  • All validations passed ✓
  • Dimensions within spec ✓
  • P-codes match thickness ✓
  • Ready to run ✓

Action Required: ✅ None - Good to go!

Color    Status         Severity    Production Impact    Action
------   ------------   ---------   ------------------   ---------
🔴 RED    CRITICAL       CRITICAL    Part failure/crash   IMMEDIATE
🟠 ORANGE BORE_WARNING   HIGH        Possible fit issues  Before 1st
🟣 PURPLE DIMENSIONAL    MEDIUM      Setup errors         Before run
🟡 YELLOW WARNING        LOW         Minor issues         When ready
🟢 GREEN  PASS           NONE        None                 N/A

TOLERANCE REFERENCE
───────────────────────────────────────────────────────────────────────────────
CB (Center Bore):
  • Acceptable:  title_cb to (title_cb + 0.1mm)
  • Orange:      ±0.1 to ±0.2mm or ±0.3mm
  • Red:         < -0.2mm or > +0.3mm

OB (Outer Bore / Hub Diameter):
  • Acceptable:  (title_ob - 0.1mm) to title_ob
  • Orange:      ±0.1 to ±0.2mm or ±0.3mm
  • Red:         < -0.3mm or > +0.2mm

Thickness:
  • Acceptable:  ±0.01"
  • Purple:      ±0.01 to ±0.02"
  • Red:         > ±0.02"

OD (Outer Diameter):
  • Acceptable:  ±0.05"
  • Yellow:      ±0.05 to ±0.1"
  • Red:         > ±0.1"

═══════════════════════════════════════════════════════════════════════════════
                    5. FILTERING TIPS
═══════════════════════════════════════════════════════════════════════════════

Multi-Select Filters
───────────────────────────────────────────────────────────────────────────────
  • Click Type/Material/Status/Duplicate Type dropdowns
  • Check multiple boxes to filter
  • Shows "3 selected" when multiple items chosen
  • Click "Apply Filters" button to filter results
  • Click "Reset Filters" to clear all filters

Common Filter Combinations
───────────────────────────────────────────────────────────────────────────────
Focus on Issues Only:
  • Status: Select CRITICAL + BORE_WARNING + DIMENSIONAL
  • Result: See only files needing attention

Production-Ready Files:
  • Status: Select only PASS
  • Duplicate Type: Leave empty or uncheck all
  • Result: Clean, validated files ready to run

View All Duplicates:
  • Duplicate Type: Select SOLID + NAME_COLLISION + CONTENT_DUP
  • Result: See all duplicate files for cleanup

View Only SOLID Duplicates (same content, different names):
  • Duplicate Type: Select only SOLID
  • Result: Files you can safely delete (keep one copy)

View Name Collisions (CRITICAL - different content, same name):
  • Duplicate Type: Select only NAME_COLLISION
  • Result: Files that MUST be manually reviewed and renamed

View by Material:
  • Material: Select specific materials (e.g., 1018, 4140)
  • Result: See files for specific material types

View by Outer Diameter:
  • OD Range: Enter min/max values
  • Result: See files within specific size range

═══════════════════════════════════════════════════════════════════════════════
                    QUICK REFERENCE - RECOMMENDED WORKFLOW
═══════════════════════════════════════════════════════════════════════════════

INITIAL SETUP (First Time):
  1. Scan Folder → Load all files
  2. Find Repeats → Detect duplicates
  3. Review & Compare → Use Compare Files
  4. Clean Up → Rename or Delete duplicates
  5. Verify → Check for _dup files and duplicates

DAILY PRODUCTION USE:
  1. Scan New Only → Add new files
  2. Filter by Status → Focus on PASS files
  3. Export CSV → Document production files
  4. Organize by OD → Group files for easy access

TROUBLESHOOTING:
  • If Copy Filtered not working → Run Find Repeats first
  • If duplicates showing → Use Rename Duplicates or Compare Files
  • If Rename Duplicates does nothing → Check that view is filtered
  • If validation errors → Fix G-code and re-scan

═══════════════════════════════════════════════════════════════════════════════

For more documentation, see project README files in the application directory.

═══════════════════════════════════════════════════════════════════════════════
"""

        text.insert("1.0", legend_content)

        # Configure text tags for colored examples
        text.tag_configure('red', foreground='#ff6b6b')
        text.tag_configure('orange', foreground='#ffa500')
        text.tag_configure('purple', foreground='#da77f2')
        text.tag_configure('yellow', foreground='#ffd43b')
        text.tag_configure('green', foreground='#69db7c')

        text.config(state=tk.DISABLED)

        # Close button
        btn_close = tk.Button(legend_window, text="Close", command=legend_window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 11, "bold"), width=20, height=2)
        btn_close.pack(pady=10)

    def create_auto_backup(self, operation_name="operation"):
        """
        Create an automatic backup before destructive operations.
        Silent operation - no user prompts, returns backup path or None if failed.

        Args:
            operation_name: Name of the operation triggering backup (for filename)

        Returns:
            str: Path to backup file if successful, None if failed
        """
        import shutil
        from datetime import datetime

        try:
            backups_dir = os.path.join(os.path.dirname(self.db_path), "database_backups", "auto")
            os.makedirs(backups_dir, exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            # Sanitize operation name for filename
            safe_op_name = "".join(c if c.isalnum() or c in "-_" else "_" for c in operation_name)
            backup_filename = f"auto_backup_{safe_op_name}_{timestamp}.db"
            backup_path = os.path.join(backups_dir, backup_filename)

            shutil.copy2(self.db_path, backup_path)
            logger.info(f"Auto-backup created: {backup_filename}")

            # Clean up old auto-backups (keep last 20)
            self._cleanup_old_auto_backups(backups_dir, keep=20)

            return backup_path

        except OSError as e:
            logger.error(f"Auto-backup file operation failed: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"Auto-backup failed: {str(e)}", exc_info=True)
            return None

    def _cleanup_old_auto_backups(self, backups_dir, keep=20):
        """Remove old auto-backups, keeping only the most recent ones."""
        try:
            backup_files = []
            for f in os.listdir(backups_dir):
                if f.startswith("auto_backup_") and f.endswith(".db"):
                    full_path = os.path.join(backups_dir, f)
                    backup_files.append((full_path, os.path.getmtime(full_path)))

            # Sort by modification time (newest first)
            backup_files.sort(key=lambda x: x[1], reverse=True)

            # Remove old backups beyond the keep limit
            for backup_path, _ in backup_files[keep:]:
                try:
                    os.remove(backup_path)
                    logger.debug(f"Cleaned up old auto-backup: {os.path.basename(backup_path)}")
                except OSError:
                    pass  # Silently skip if cleanup fails

        except Exception as e:
            logger.warning(f"Auto-backup cleanup error: {str(e)}")

    def create_manual_backup(self):
        """Create a manual backup with timestamp"""
        import shutil
        from datetime import datetime

        backups_dir = os.path.join(os.path.dirname(self.db_path), "database_backups")
        os.makedirs(backups_dir, exist_ok=True)

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        backup_filename = f"gcode_db_backup_{timestamp}.db"
        backup_path = os.path.join(backups_dir, backup_filename)

        try:
            shutil.copy2(self.db_path, backup_path)
            messagebox.showinfo("Backup Created",
                f"Database backed up successfully!\n\n"
                f"Backup saved to:\n{backup_filename}\n\n"
                f"Location: {backups_dir}")
        except Exception as e:
            messagebox.showerror("Backup Failed",
                f"Failed to create backup:\n{str(e)}")

    def create_full_backup(self):
        """Create a full backup including database and all repository files"""
        import shutil
        from datetime import datetime
        import zipfile

        # Let user choose backup location
        backup_location = filedialog.askdirectory(
            title="Select Location for Full Backup",
            initialdir=os.path.expanduser("~")
        )

        if not backup_location:
            return

        # Create timestamped backup folder name
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        backup_name = f"GCode_Full_Backup_{timestamp}"
        backup_folder = os.path.join(backup_location, backup_name)

        try:
            # Create progress window
            progress_window = tk.Toplevel(self.root)
            progress_window.title("Creating Full Backup")
            progress_window.geometry("500x200")
            progress_window.configure(bg=self.bg_color)
            progress_window.transient(self.root)
            progress_window.grab_set()

            # Center window
            progress_window.update_idletasks()
            x = (progress_window.winfo_screenwidth() // 2) - 250
            y = (progress_window.winfo_screenheight() // 2) - 100
            progress_window.geometry(f"500x200+{x}+{y}")

            status_label = tk.Label(progress_window,
                                   text="Preparing backup...",
                                   bg=self.bg_color, fg=self.fg_color,
                                   font=("Arial", 11))
            status_label.pack(pady=20)

            progress_bar = ttk.Progressbar(progress_window, length=400, mode='indeterminate')
            progress_bar.pack(pady=10)
            progress_bar.start(10)

            details_label = tk.Label(progress_window,
                                    text="",
                                    bg=self.bg_color, fg=self.fg_color,
                                    font=("Arial", 9))
            details_label.pack(pady=10)

            progress_window.update()

            # Create backup folder
            os.makedirs(backup_folder, exist_ok=True)

            # 1. Backup database
            status_label.config(text="Backing up database...")
            progress_window.update()

            db_backup_path = os.path.join(backup_folder, "gcode_database.db")
            shutil.copy2(self.db_path, db_backup_path)

            # 2. Get all repository files from database
            status_label.config(text="Collecting repository files...")
            progress_window.update()

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT file_path FROM programs WHERE file_path IS NOT NULL")
            file_paths = [row[0] for row in cursor.fetchall() if row[0]]
            conn.close()

            # 3. Copy repository files maintaining structure
            status_label.config(text="Copying repository files...")
            details_label.config(text=f"Total files: {len(file_paths)}")
            progress_window.update()

            files_copied = 0
            files_missing = 0

            repository_backup = os.path.join(backup_folder, "repository")
            os.makedirs(repository_backup, exist_ok=True)

            for i, file_path in enumerate(file_paths):
                if os.path.exists(file_path):
                    # Maintain folder structure relative to repository
                    if hasattr(self, 'repository_path') and self.repository_path:
                        try:
                            rel_path = os.path.relpath(file_path, self.repository_path)
                        except:
                            rel_path = os.path.basename(file_path)
                    else:
                        rel_path = os.path.basename(file_path)

                    dest_path = os.path.join(repository_backup, rel_path)
                    os.makedirs(os.path.dirname(dest_path), exist_ok=True)

                    try:
                        shutil.copy2(file_path, dest_path)
                        files_copied += 1
                    except Exception as e:
                        files_missing += 1
                else:
                    files_missing += 1

                # Update progress every 10 files
                if i % 10 == 0:
                    details_label.config(text=f"Copied: {files_copied} | Missing: {files_missing} | Total: {len(file_paths)}")
                    progress_window.update()

            # 4. Copy versions folder (entire folder with all version history)
            if os.path.exists(self.versions_path):
                status_label.config(text="Backing up version history...")
                progress_window.update()

                versions_backup = os.path.join(backup_folder, "versions")
                try:
                    shutil.copytree(self.versions_path, versions_backup)
                    # Count files in versions
                    version_files = sum([len(files) for r, d, files in os.walk(versions_backup)])
                    details_label.config(text=f"Backed up {version_files} version files")
                except Exception as e:
                    details_label.config(text=f"Warning: Could not backup versions folder: {e}")
                progress_window.update()

            # 5. Copy revised_repository folder if it exists
            if os.path.exists(self.revised_repository_path):
                status_label.config(text="Backing up revised repository...")
                progress_window.update()

                revised_backup = os.path.join(backup_folder, "revised_repository")
                try:
                    shutil.copytree(self.revised_repository_path, revised_backup)
                    # Count files in revised
                    revised_files = len([f for f in os.listdir(revised_backup) if os.path.isfile(os.path.join(revised_backup, f))])
                    details_label.config(text=f"Backed up {revised_files} revised files")
                except Exception as e:
                    details_label.config(text=f"Warning: Could not backup revised_repository: {e}")
                progress_window.update()

            # 6. Copy archive folder if it exists (7,915+ historical archive files)
            archive_path = os.path.join(os.path.dirname(self.repository_path), 'archive')
            if os.path.exists(archive_path):
                status_label.config(text="Backing up archive folder...")
                progress_window.update()

                archive_backup = os.path.join(backup_folder, "archive")
                try:
                    shutil.copytree(archive_path, archive_backup)
                    # Count files in archive
                    archive_files = sum([len(files) for r, d, files in os.walk(archive_backup)])
                    details_label.config(text=f"Backed up {archive_files} archive files")
                except Exception as e:
                    details_label.config(text=f"Warning: Could not backup archive: {e}")
                progress_window.update()

            # 7. Create backup info file
            status_label.config(text="Creating backup info...")
            progress_window.update()

            # Count version, revised, and archive files
            version_count = 0
            if os.path.exists(os.path.join(backup_folder, "versions")):
                version_count = sum([len(files) for r, d, files in os.walk(os.path.join(backup_folder, "versions"))])

            revised_count = 0
            if os.path.exists(os.path.join(backup_folder, "revised_repository")):
                revised_count = len([f for f in os.listdir(os.path.join(backup_folder, "revised_repository"))
                                    if os.path.isfile(os.path.join(os.path.join(backup_folder, "revised_repository"), f))])

            archive_count = 0
            if os.path.exists(os.path.join(backup_folder, "archive")):
                archive_count = sum([len(files) for r, d, files in os.walk(os.path.join(backup_folder, "archive"))])

            info_path = os.path.join(backup_folder, "BACKUP_INFO.txt")
            with open(info_path, 'w') as f:
                f.write(f"GCode Database Full Backup\n")
                f.write(f"="*50 + "\n\n")
                f.write(f"Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Created by: {self.current_username}\n\n")
                f.write(f"Database records: {len(file_paths)}\n")
                f.write(f"Repository files copied: {files_copied}\n")
                f.write(f"Repository files missing: {files_missing}\n")
                f.write(f"Version history files: {version_count}\n")
                f.write(f"Revised repository files: {revised_count}\n")
                f.write(f"Archive files: {archive_count}\n\n")
                f.write(f"Contents:\n")
                f.write(f"  - gcode_database.db (database file with all records, including soft-deleted)\n")
                f.write(f"  - repository/ (current active .nc files)\n")
                f.write(f"  - revised_repository/ (edited/revised .nc files)\n")
                f.write(f"  - versions/ (complete version history for all programs)\n")
                f.write(f"  - archive/ (historical archive files - 7,915+ files)\n\n")
                f.write(f"Total files backed up: {files_copied + version_count + revised_count + archive_count}\n\n")
                f.write(f"To Restore:\n")
                f.write(f"  1. Copy gcode_database.db to your program folder\n")
                f.write(f"  2. Copy repository/ contents to your repository location\n")
                f.write(f"  3. Copy revised_repository/ to maintain edited files\n")
                f.write(f"  4. Copy versions/ to restore complete version history\n")
                f.write(f"  5. Copy archive/ to restore historical archive files\n")
                f.write(f"  6. Update file paths in database if repository location changed\n\n")
                f.write(f"IMPORTANT: This backup includes ALL files:\n")
                f.write(f"  • Current repository files\n")
                f.write(f"  • All version history (originals before edits)\n")
                f.write(f"  • Revised/edited files\n")
                f.write(f"  • Historical archive files (7,915+ files)\n")
                f.write(f"  • Complete database with metadata (including soft-deleted records)\n")

            progress_bar.stop()
            progress_window.destroy()

            # Show success message
            messagebox.showinfo("Full Backup Complete",
                f"Full backup created successfully!\n\n"
                f"Location: {backup_folder}\n\n"
                f"✓ Database: Backed up (includes soft-deleted)\n"
                f"✓ Repository files: {files_copied}\n"
                f"✓ Version history: {version_count} files\n"
                f"✓ Revised repository: {revised_count} files\n"
                f"✓ Archive files: {archive_count} files\n"
                f"Files missing: {files_missing}\n\n"
                f"Total backed up: {files_copied + version_count + revised_count + archive_count} files\n\n"
                f"Backup includes:\n"
                f"  • Database with all records (including soft-deleted)\n"
                f"  • Current repository files\n"
                f"  • Complete version history\n"
                f"  • Revised/edited files\n"
                f"  • Historical archive files (7,915+ files)\n"
                f"  • Backup info file")

        except Exception as e:
            if 'progress_window' in locals():
                progress_window.destroy()
            messagebox.showerror("Full Backup Failed",
                f"Failed to create full backup:\n{str(e)}")

    def restore_from_backup(self):
        """Restore database from a backup file"""
        import shutil
        from datetime import datetime

        backups_dir = os.path.join(os.path.dirname(self.db_path), "database_backups")

        # Let user select backup file
        backup_file = filedialog.askopenfilename(
            title="Select Backup to Restore",
            initialdir=backups_dir if os.path.exists(backups_dir) else os.path.dirname(self.db_path),
            filetypes=[("Database files", "*.db"), ("All files", "*.*")]
        )

        if not backup_file:
            return

        # Confirm restoration
        result = messagebox.askyesno(
            "Confirm Restore",
            f"Restore database from:\n{os.path.basename(backup_file)}\n\n"
            f"⚠️ WARNING ⚠️\n"
            f"This will replace your current database!\n"
            f"All current data will be lost!\n\n"
            f"A backup of the current database will be created first.\n\n"
            f"Continue?",
            icon='warning'
        )

        if not result:
            return

        try:
            # Create backup of current database first
            current_backup_dir = os.path.join(os.path.dirname(self.db_path), "database_backups")
            os.makedirs(current_backup_dir, exist_ok=True)
            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            current_backup = os.path.join(current_backup_dir, f"before_restore_{timestamp}.db")
            shutil.copy2(self.db_path, current_backup)

            # Restore from selected backup
            shutil.copy2(backup_file, self.db_path)

            messagebox.showinfo("Restore Complete",
                f"Database restored successfully!\n\n"
                f"Restored from: {os.path.basename(backup_file)}\n\n"
                f"Previous database saved as:\n{os.path.basename(current_backup)}\n\n"
                f"Please restart the application to load the restored database.")

        except Exception as e:
            messagebox.showerror("Restore Failed",
                f"Failed to restore database:\n{str(e)}")

    def view_backups(self):
        """View and manage database backups"""
        import shutil
        from datetime import datetime

        backups_dir = os.path.join(os.path.dirname(self.db_path), "database_backups")
        os.makedirs(backups_dir, exist_ok=True)

        # Create window
        backup_window = tk.Toplevel(self.root)
        backup_window.title("Database Backups")
        backup_window.geometry("900x600")
        backup_window.configure(bg=self.bg_color)

        tk.Label(backup_window,
                text="Database Backup Manager",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=15)

        # Treeview for backup list
        tree_frame = tk.Frame(backup_window, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        columns = ('filename', 'records', 'date', 'size')
        tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=15)

        tree.heading('filename', text='Backup File')
        tree.heading('records', text='Records')
        tree.heading('date', text='Date Created')
        tree.heading('size', text='Size (MB)')

        tree.column('filename', width=350)
        tree.column('records', width=100)
        tree.column('date', width=200)
        tree.column('size', width=100)

        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscroll=scrollbar.set)

        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        def refresh_backup_list():
            # Clear existing items
            for item in tree.get_children():
                tree.delete(item)

            # Get backup files
            if not os.path.exists(backups_dir):
                tree.insert('', tk.END, values=("No backups found", "", "", ""))
                return

            backup_files = [f for f in os.listdir(backups_dir) if f.endswith('.db')]

            if not backup_files:
                tree.insert('', tk.END, values=("No backups found - use 'Backup Now' to create one", "", "", ""))
                return

            for backup_file in sorted(backup_files, reverse=True):
                backup_path = os.path.join(backups_dir, backup_file)

                # Get stats
                stat = os.stat(backup_path)
                size_mb = f"{stat.st_size / (1024 * 1024):.2f}"
                created = datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")

                # Get record count
                try:
                    conn = sqlite3.connect(backup_path)
                    cursor = conn.cursor()
                    cursor.execute("SELECT COUNT(*) FROM programs")
                    count = cursor.fetchone()[0]
                    conn.close()
                except:
                    count = "Error"

                tree.insert('', tk.END, values=(backup_file, count, created, size_mb))

        def delete_backup():
            selection = tree.selection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a backup to delete.")
                return

            item = selection[0]
            filename = tree.item(item)['values'][0]

            if "No backups found" in filename:
                return

            result = messagebox.askyesno(
                "Confirm Delete",
                f"Delete backup '{filename}'?\n\n"
                f"This cannot be undone!",
                icon='warning'
            )

            if result:
                try:
                    backup_path = os.path.join(backups_dir, filename)
                    os.remove(backup_path)
                    refresh_backup_list()
                    messagebox.showinfo("Deleted", f"Backup '{filename}' deleted successfully.")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to delete backup:\n{str(e)}")

        def restore_selected():
            selection = tree.selection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a backup to restore.")
                return

            item = selection[0]
            filename = tree.item(item)['values'][0]

            if "No backups found" in filename:
                return

            backup_path = os.path.join(backups_dir, filename)

            result = messagebox.askyesno(
                "Confirm Restore",
                f"Restore database from:\n{filename}\n\n"
                f"⚠️ WARNING ⚠️\n"
                f"This will replace your current database!\n\n"
                f"A backup of current database will be created first.\n\n"
                f"Continue?",
                icon='warning'
            )

            if result:
                try:
                    # Backup current database
                    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
                    current_backup = os.path.join(backups_dir, f"before_restore_{timestamp}.db")
                    shutil.copy2(self.db_path, current_backup)

                    # Restore
                    shutil.copy2(backup_path, self.db_path)

                    messagebox.showinfo("Restore Complete",
                        f"Database restored from {filename}!\n\n"
                        f"Current database backed up as:\n{os.path.basename(current_backup)}\n\n"
                        f"Please restart the application.")
                    backup_window.destroy()

                except Exception as e:
                    messagebox.showerror("Error", f"Failed to restore:\n{str(e)}")

        # Initial load
        refresh_backup_list()

        # Info label
        info_text = f"Backup location: {backups_dir}"
        tk.Label(backup_window, text=info_text,
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9)).pack(pady=5)

        # Button frame
        btn_frame = tk.Frame(backup_window, bg=self.bg_color)
        btn_frame.pack(pady=15)

        tk.Button(btn_frame, text="💾 Backup Now", command=lambda: [self.create_manual_backup(), refresh_backup_list()],
                 bg="#1976D2", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="📂 Restore", command=restore_selected,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="🗑️ Delete", command=delete_backup,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="🔄 Refresh", command=refresh_backup_list,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=14).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="❌ Close", command=backup_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=14).pack(side=tk.LEFT, padx=5)

    # ===== Repository Management Methods =====

    def refresh_repository_scan(self):
        """Refresh repository scan - rescan all repository files and update database values"""
        try:
            # Confirm with user
            confirm = messagebox.askyesno(
                "Refresh Repository Scan",
                "This will RE-PARSE all files in the repository folder and update:\n"
                "  • CB/OB dimensions (from G-code)\n"
                "  • Round size detection\n"
                "  • Thickness and hub dimensions\n"
                "  • Validation status (clear incorrect warnings)\n"
                "  • In-correct-range status\n\n"
                "This will take several minutes for all files.\n\n"
                "Continue?",
                icon='question'
            )

            if not confirm:
                return

            # Create progress window
            progress_window = tk.Toplevel(self.root)
            progress_window.title("Refreshing Repository")
            progress_window.geometry("600x400")
            progress_window.configure(bg=self.bg_color)
            progress_window.transient(self.root)
            progress_window.grab_set()

            tk.Label(progress_window, text="🔄 Refreshing Repository Scan...",
                    bg=self.bg_color, fg=self.fg_color,
                    font=("Arial", 12, "bold")).pack(pady=10)

            # Progress text
            progress_text = tk.Text(progress_window, height=20, width=70,
                                   bg="#2B2B2B", fg="#FFFFFF", font=("Consolas", 9))
            progress_text.pack(pady=10, padx=20, fill=tk.BOTH, expand=True)

            def log(message):
                try:
                    if progress_text.winfo_exists():
                        progress_text.insert(tk.END, message + "\n")
                        progress_text.see(tk.END)
                        progress_window.update()
                except tk.TclError:
                    pass

            log("Starting repository refresh...")
            log("-" * 60)

            # Get all managed programs
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            programs = cursor.fetchall()
            total = len(programs)
            log(f"Found {total} programs in repository")
            log("")

            # Statistics
            stats = {
                'reparsed': 0,
                'errors': 0
            }

            # Process each program
            for i, (prog_num, file_path) in enumerate(programs):
                if i % 100 == 0:
                    log(f"Progress: {i}/{total} programs processed...")

                try:
                    # Re-parse the entire file to update all values
                    if file_path and os.path.exists(file_path):
                        # Parse the file
                        parse_result = self.parser.parse_file(file_path)

                        # Determine validation status (prioritized by severity)
                        import json
                        validation_status = "PASS"
                        if parse_result.validation_issues:
                            validation_status = "CRITICAL"  # RED - Critical errors
                        elif parse_result.tool_home_status == "CRITICAL":
                            validation_status = "TOOL_HOME_CRITICAL"  # DARK RED - G53 Z-16 or beyond
                        elif parse_result.bore_warnings:
                            validation_status = "BORE_WARNING"  # ORANGE - Bore dimension warnings
                        elif parse_result.tool_home_status == "WARNING":
                            validation_status = "TOOL_HOME_WARNING"  # AMBER - G53 Z mismatch
                        elif parse_result.dimensional_issues:
                            validation_status = "DIMENSIONAL"  # PURPLE - P-code/thickness mismatches
                        elif parse_result.validation_warnings:
                            validation_status = "WARNING"  # YELLOW - General warnings

                        # Update database with all parsed values including validation
                        cursor.execute("""
                            UPDATE programs
                            SET title = ?,
                                outer_diameter = ?,
                                thickness = ?,
                                thickness_display = ?,
                                center_bore = ?,
                                hub_diameter = ?,
                                hub_height = ?,
                                counter_bore_diameter = ?,
                                counter_bore_depth = ?,
                                cb_from_gcode = ?,
                                ob_from_gcode = ?,
                                round_size = ?,
                                round_size_confidence = ?,
                                round_size_source = ?,
                                validation_status = ?,
                                validation_issues = ?,
                                validation_warnings = ?,
                                bore_warnings = ?,
                                dimensional_issues = ?,
                                tool_home_status = ?,
                                tool_home_issues = ?
                            WHERE program_number = ?
                        """, (
                            parse_result.title,
                            parse_result.outer_diameter,
                            parse_result.thickness,
                            parse_result.thickness_display,
                            parse_result.center_bore,
                            parse_result.hub_diameter,
                            parse_result.hub_height,
                            parse_result.counter_bore_diameter,
                            parse_result.counter_bore_depth,
                            parse_result.cb_from_gcode,
                            parse_result.ob_from_gcode,
                            parse_result.outer_diameter,  # round_size = OD
                            'HIGH',  # confidence
                            'Re-parsed',  # source
                            validation_status,
                            json.dumps(parse_result.validation_issues) if parse_result.validation_issues else None,
                            json.dumps(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                            json.dumps(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                            json.dumps(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                            parse_result.tool_home_status,
                            json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                            prog_num
                        ))

                        # Update in_correct_range status
                        if parse_result.outer_diameter:
                            in_range = 1 if self.is_in_correct_range(prog_num, parse_result.outer_diameter) else 0
                            cursor.execute("""
                                UPDATE programs
                                SET in_correct_range = ?
                                WHERE program_number = ?
                            """, (in_range, prog_num))

                        stats['reparsed'] += 1

                except Exception as e:
                    log(f"  ERROR {prog_num}: {str(e)}")
                    stats['errors'] += 1

            conn.commit()
            conn.close()

            log("")
            log("-" * 60)
            log("REFRESH COMPLETE!")
            log(f"Total programs: {total}")
            log(f"Files re-parsed: {stats['reparsed']}")
            log(f"Errors: {stats['errors']}")
            log("")
            log("Refreshing display...")

            # Refresh the results display
            self.refresh_results()

            # Refresh available filter values to update dropdowns
            self.refresh_filter_values()

            log("Done!")

            # Add close button
            tk.Button(progress_window, text="Close",
                     command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold")).pack(pady=10)

            messagebox.showinfo(
                "Refresh Complete",
                f"Repository scan refreshed!\n\n"
                f"Programs scanned: {total:,}\n"
                f"Files re-parsed: {stats['reparsed']}\n"
                f"Errors: {stats['errors']}"
            )

        except Exception as e:
            messagebox.showerror("Refresh Error", f"Error refreshing repository:\n{str(e)}")

    def show_repository_stats(self):
        """Show ONLY repository (managed) files statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Only count managed files (is_managed = 1)
        cursor.execute("SELECT COUNT(*) FROM programs WHERE is_managed = 1")
        managed_count = cursor.fetchone()[0]

        # Count versions
        cursor.execute("SELECT COUNT(*) FROM program_versions")
        versions_count = cursor.fetchone()[0]

        # Repository size
        repo_size = 0
        if os.path.exists(self.repository_path):
            for file in os.listdir(self.repository_path):
                file_path = os.path.join(self.repository_path, file)
                if os.path.isfile(file_path):
                    repo_size += os.path.getsize(file_path)

        # Versions size
        versions_size = 0
        if os.path.exists(self.versions_path):
            for root, _, files in os.walk(self.versions_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    versions_size += os.path.getsize(file_path)

        conn.close()

        # Create stats dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Repository Statistics")
        dialog.geometry("500x350")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Title
        tk.Label(dialog, text="📊 Repository Statistics",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        tk.Label(dialog, text="(Managed files in repository/ folder only)",
                font=("Arial", 9, "italic"), bg=self.bg_color, fg="#888888").pack(pady=2)

        # Stats frame
        stats_frame = tk.Frame(dialog, bg=self.bg_color)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Display stats
        stats_data = [
            ("Repository Files:", f"{managed_count}"),
            ("", ""),
            ("Total Versions:", f"{versions_count}"),
            ("", ""),
            ("Repository Size:", f"{repo_size / (1024 * 1024):.2f} MB"),
            ("Versions Size:", f"{versions_size / (1024 * 1024):.2f} MB"),
            ("Total Storage:", f"{(repo_size + versions_size) / (1024 * 1024):.2f} MB"),
        ]

        for label, value in stats_data:
            if label:  # Skip empty rows for spacing
                row = tk.Frame(stats_frame, bg=self.bg_color)
                row.pack(fill=tk.X, pady=5)

                tk.Label(row, text=label, font=("Arial", 11), bg=self.bg_color, fg=self.fg_color,
                        anchor='w').pack(side=tk.LEFT)
                tk.Label(row, text=value, font=("Arial", 11, "bold"), bg=self.bg_color, fg=self.accent_color,
                        anchor='e').pack(side=tk.RIGHT)

        # Buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="🔄 Refresh", command=lambda: [dialog.destroy(), self.show_repository_stats()],
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

    # ========================================================================
    # REVISED REPOSITORY METHODS
    # ========================================================================

    def refresh_revised_scan(self):
        """Scan and refresh the revised repository files"""
        if not os.path.exists(self.revised_repository_path):
            messagebox.showwarning("Not Found", "Revised repository folder does not exist.")
            return

        # Scan revised repository files
        revised_files = []
        for file in os.listdir(self.revised_repository_path):
            file_path = os.path.join(self.revised_repository_path, file)
            if os.path.isfile(file_path) and not file.startswith('.'):
                revised_files.append(file_path)

        if not revised_files:
            messagebox.showinfo("Empty", "No files found in revised repository.")
            self.refresh_results(view_mode='revised')
            return

        # Process each file
        added = 0
        updated = 0
        for file_path in revised_files:
            try:
                result = self.parser.parse_file(file_path)
                if result:
                    # Check if already in database
                    conn = sqlite3.connect(self.db_path, timeout=30.0)
                    cursor = conn.cursor()
                    cursor.execute("SELECT id FROM programs WHERE file_path = ?", (file_path,))
                    existing = cursor.fetchone()

                    if existing:
                        # Update existing
                        self.update_program_from_result(result, file_path)
                        updated += 1
                    else:
                        # Add new
                        self.add_program_from_result(result, file_path, is_managed=True)
                        added += 1
                    conn.close()
            except Exception as e:
                logger.error(f"Error processing revised file {file_path}: {e}")

        messagebox.showinfo("Scan Complete",
                          f"Revised Repository Scan Complete\n\n"
                          f"Added: {added}\n"
                          f"Updated: {updated}\n"
                          f"Total files: {len(revised_files)}")

        self.refresh_results(view_mode='revised')

    def show_revised_stats(self):
        """Show revised repository statistics"""
        # Count files in revised repository
        revised_count = 0
        revised_size = 0

        if os.path.exists(self.revised_repository_path):
            for file in os.listdir(self.revised_repository_path):
                file_path = os.path.join(self.revised_repository_path, file)
                if os.path.isfile(file_path):
                    revised_count += 1
                    revised_size += os.path.getsize(file_path)

        # Count in database that are in revised repository
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM programs WHERE file_path LIKE ?",
                      (f"%revised_repository%",))
        db_revised_count = cursor.fetchone()[0]
        conn.close()

        # Create stats dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Revised Repository Statistics")
        dialog.geometry("450x300")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        tk.Label(dialog, text="📊 Revised Repository Statistics",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg="#FFD700").pack(pady=10)

        tk.Label(dialog, text="(Hand-refined programs in revised_repository/ folder)",
                font=("Arial", 9, "italic"), bg=self.bg_color, fg="#888888").pack(pady=2)

        stats_frame = tk.Frame(dialog, bg=self.bg_color)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        stats_data = [
            ("Files in Folder:", f"{revised_count}"),
            ("Files in Database:", f"{db_revised_count}"),
            ("", ""),
            ("Total Size:", f"{revised_size / (1024 * 1024):.2f} MB"),
        ]

        for label, value in stats_data:
            if label:
                row = tk.Frame(stats_frame, bg=self.bg_color)
                row.pack(fill=tk.X, pady=5)
                tk.Label(row, text=label, font=("Arial", 11), bg=self.bg_color, fg=self.fg_color,
                        anchor='w').pack(side=tk.LEFT)
                tk.Label(row, text=value, font=("Arial", 11, "bold"), bg=self.bg_color, fg="#FFD700",
                        anchor='e').pack(side=tk.RIGHT)

        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="🔄 Refresh", command=lambda: [dialog.destroy(), self.show_revised_stats()],
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

    def import_to_revised_repository(self):
        """Import selected program from main repository to revised repository"""
        if not self.require_permission('move_files', 'import to revised repository'):
            return

        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to import to revised repository")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found in database")
            return

        source_path = result[0]

        if not os.path.exists(source_path):
            messagebox.showerror("Error", f"Source file not found:\n{source_path}")
            return

        # Determine destination path
        filename = os.path.basename(source_path)
        dest_path = os.path.join(self.revised_repository_path, filename)

        # Check if already exists
        if os.path.exists(dest_path):
            if not messagebox.askyesno("File Exists",
                                       f"A file with this name already exists in revised repository.\n\n"
                                       f"Overwrite?"):
                return

        try:
            # Copy file to revised repository
            shutil.copy2(source_path, dest_path)

            # Add to database as revised
            result = self.parser.parse_file(dest_path)
            if result:
                self.add_program_from_result(result, dest_path, is_managed=True)

            self.log_activity('IMPORT_TO_REVISED', program_number, f"Imported to revised repository: {filename}")

            messagebox.showinfo("Success", f"Program {program_number} imported to revised repository")
            self.refresh_results(view_mode='revised')

        except Exception as e:
            messagebox.showerror("Error", f"Failed to import:\n{e}")

    def move_to_main_repository(self):
        """Move selected program from revised repository to main repository"""
        if not self.require_permission('move_files', 'move to main repository'):
            return

        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to move to main repository")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get file path from database
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found in database")
            return

        source_path = result[0]

        if not self.is_in_revised_repository(source_path):
            messagebox.showwarning("Not Revised", "This file is not in the revised repository")
            return

        if not os.path.exists(source_path):
            messagebox.showerror("Error", f"Source file not found:\n{source_path}")
            return

        # Determine destination path
        filename = os.path.basename(source_path)
        dest_path = os.path.join(self.repository_path, filename)

        # Check if already exists in main repo
        if os.path.exists(dest_path):
            if not messagebox.askyesno("File Exists",
                                       f"A file with this name already exists in main repository.\n\n"
                                       f"This will replace the existing file. Continue?"):
                return

        try:
            # Move file to main repository
            shutil.move(source_path, dest_path)

            # Update database path
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("UPDATE programs SET file_path = ? WHERE program_number = ?",
                         (dest_path, program_number))
            conn.commit()
            conn.close()

            self.log_activity('MOVE_TO_MAIN', program_number, f"Moved from revised to main: {filename}")

            messagebox.showinfo("Success", f"Program {program_number} moved to main repository")
            self.refresh_results(view_mode='repository')

        except Exception as e:
            messagebox.showerror("Error", f"Failed to move:\n{e}")

    def delete_from_revised_repository(self):
        """Delete selected program from revised repository"""
        if not self.require_permission('delete_files', 'delete from revised repository'):
            return

        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to delete")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get file path
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found")
            conn.close()
            return

        file_path = result[0]

        if not self.is_in_revised_repository(file_path):
            messagebox.showwarning("Not Revised", "This file is not in the revised repository")
            conn.close()
            return

        if not messagebox.askyesno("Confirm Delete",
                                  f"Delete {program_number} from revised repository?\n\n"
                                  f"This will permanently delete the file."):
            conn.close()
            return

        try:
            # Delete file
            if os.path.exists(file_path):
                os.remove(file_path)

            # Remove from database
            cursor.execute("DELETE FROM programs WHERE program_number = ? AND file_path = ?",
                         (program_number, file_path))
            conn.commit()
            conn.close()

            self.log_activity('DELETE_REVISED', program_number, f"Deleted from revised repository")

            messagebox.showinfo("Deleted", f"Program {program_number} deleted from revised repository")
            self.refresh_results(view_mode='revised')

        except Exception as e:
            conn.close()
            messagebox.showerror("Error", f"Failed to delete:\n{e}")

    def export_from_revised(self):
        """Export selected program from revised repository"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to export")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get file path
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found")
            return

        source_path = result[0]

        if not os.path.exists(source_path):
            messagebox.showerror("Error", f"File not found:\n{source_path}")
            return

        # Ask for destination
        dest_path = filedialog.asksaveasfilename(
            title="Export Program",
            initialfile=os.path.basename(source_path),
            defaultextension=".nc",
            filetypes=[("NC Files", "*.nc"), ("All Files", "*.*")]
        )

        if dest_path:
            try:
                shutil.copy2(source_path, dest_path)
                messagebox.showinfo("Exported", f"Program exported to:\n{dest_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Export failed:\n{e}")

    def compare_revised_with_main(self):
        """Compare selected revised program with main repository version"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a revised program to compare")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get revised file path
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found")
            return

        revised_path = result[0]

        # Find corresponding main repository file
        filename = os.path.basename(revised_path)
        main_path = os.path.join(self.repository_path, filename)

        if not os.path.exists(main_path):
            messagebox.showinfo("No Match", f"No corresponding file found in main repository:\n{filename}")
            return

        if not os.path.exists(revised_path):
            messagebox.showerror("Error", f"Revised file not found:\n{revised_path}")
            return

        # Read both files
        try:
            with open(main_path, 'r', errors='ignore') as f:
                main_content = f.readlines()
            with open(revised_path, 'r', errors='ignore') as f:
                revised_content = f.readlines()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read files:\n{e}")
            return

        # Create comparison window
        compare_window = tk.Toplevel(self.root)
        compare_window.title(f"Compare: {program_number}")
        compare_window.geometry("1200x700")
        compare_window.configure(bg=self.bg_color)

        # Title
        tk.Label(compare_window, text=f"Comparing {program_number}: Main vs Revised",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Two panes
        panes = tk.Frame(compare_window, bg=self.bg_color)
        panes.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Main repository pane
        main_frame = tk.Frame(panes, bg=self.bg_color)
        main_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        tk.Label(main_frame, text="Main Repository", font=("Arial", 11, "bold"),
                bg=self.bg_color, fg="#4CAF50").pack()
        tk.Label(main_frame, text=f"Lines: {len(main_content)}", font=("Arial", 9),
                bg=self.bg_color, fg="#888888").pack()

        main_text = scrolledtext.ScrolledText(main_frame, bg=self.input_bg, fg=self.fg_color,
                                              font=("Consolas", 9), width=60, height=30)
        main_text.pack(fill=tk.BOTH, expand=True, pady=5)
        main_text.insert(tk.END, ''.join(main_content))
        main_text.config(state=tk.DISABLED)

        # Revised repository pane
        revised_frame = tk.Frame(panes, bg=self.bg_color)
        revised_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5)

        tk.Label(revised_frame, text="Revised Repository", font=("Arial", 11, "bold"),
                bg=self.bg_color, fg="#FFD700").pack()
        tk.Label(revised_frame, text=f"Lines: {len(revised_content)}", font=("Arial", 9),
                bg=self.bg_color, fg="#888888").pack()

        revised_text = scrolledtext.ScrolledText(revised_frame, bg=self.input_bg, fg=self.fg_color,
                                                 font=("Consolas", 9), width=60, height=30)
        revised_text.pack(fill=tk.BOTH, expand=True, pady=5)
        revised_text.insert(tk.END, ''.join(revised_content))
        revised_text.config(state=tk.DISABLED)

        # Summary of differences
        diff_count = sum(1 for a, b in zip(main_content, revised_content) if a != b)
        diff_count += abs(len(main_content) - len(revised_content))

        tk.Label(compare_window, text=f"Differences: ~{diff_count} lines differ",
                font=("Arial", 10), bg=self.bg_color, fg="#FF9800").pack(pady=5)

        tk.Button(compare_window, text="Close", command=compare_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(pady=10)

    def find_revised_differences(self):
        """Find all programs that exist in both repositories with differences"""
        if not os.path.exists(self.revised_repository_path):
            messagebox.showwarning("Not Found", "Revised repository folder does not exist.")
            return

        # Get list of files in both repositories
        main_files = set(os.listdir(self.repository_path)) if os.path.exists(self.repository_path) else set()
        revised_files = set(os.listdir(self.revised_repository_path))

        # Find common files
        common_files = main_files.intersection(revised_files)

        if not common_files:
            messagebox.showinfo("No Matches", "No common files found between main and revised repositories")
            return

        # Compare each common file
        differences = []
        identical = []

        for filename in common_files:
            main_path = os.path.join(self.repository_path, filename)
            revised_path = os.path.join(self.revised_repository_path, filename)

            try:
                with open(main_path, 'rb') as f:
                    main_hash = hashlib.md5(f.read()).hexdigest()
                with open(revised_path, 'rb') as f:
                    revised_hash = hashlib.md5(f.read()).hexdigest()

                if main_hash != revised_hash:
                    differences.append(filename)
                else:
                    identical.append(filename)
            except Exception as e:
                logger.error(f"Error comparing {filename}: {e}")

        # Show results
        result_window = tk.Toplevel(self.root)
        result_window.title("Repository Comparison Results")
        result_window.geometry("600x500")
        result_window.configure(bg=self.bg_color)

        tk.Label(result_window, text="Repository Comparison Results",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Summary
        tk.Label(result_window, text=f"Common files: {len(common_files)} | Different: {len(differences)} | Identical: {len(identical)}",
                font=("Arial", 10), bg=self.bg_color, fg="#888888").pack(pady=5)

        # Different files list
        tk.Label(result_window, text="Files with Differences:", font=("Arial", 11, "bold"),
                bg=self.bg_color, fg="#FF9800").pack(pady=(10, 5), anchor="w", padx=20)

        diff_listbox = tk.Listbox(result_window, bg=self.input_bg, fg=self.fg_color,
                                  font=("Consolas", 10), height=15, width=60)
        diff_listbox.pack(fill=tk.BOTH, expand=True, padx=20, pady=5)

        for filename in sorted(differences):
            diff_listbox.insert(tk.END, filename)

        if not differences:
            diff_listbox.insert(tk.END, "(No differences found - all common files are identical)")

        tk.Button(result_window, text="Close", command=result_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12).pack(pady=10)

    def show_all_programs_stats(self):
        """Show ALL programs statistics (repository + external combined)"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Count all programs
        cursor.execute("SELECT COUNT(*) FROM programs WHERE file_path IS NOT NULL")
        total_count = cursor.fetchone()[0]

        # Count managed files
        cursor.execute("SELECT COUNT(*) FROM programs WHERE is_managed = 1")
        managed_count = cursor.fetchone()[0]

        # Count external files
        external_count = total_count - managed_count

        # Count versions
        cursor.execute("SELECT COUNT(*) FROM program_versions")
        versions_count = cursor.fetchone()[0]

        # Repository size
        repo_size = 0
        if os.path.exists(self.repository_path):
            for file in os.listdir(self.repository_path):
                file_path = os.path.join(self.repository_path, file)
                if os.path.isfile(file_path):
                    repo_size += os.path.getsize(file_path)

        # Versions size
        versions_size = 0
        if os.path.exists(self.versions_path):
            for root, _, files in os.walk(self.versions_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    versions_size += os.path.getsize(file_path)

        conn.close()

        # Create stats dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("All Programs Statistics")
        dialog.geometry("500x400")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Title
        tk.Label(dialog, text="📊 All Programs Statistics",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        tk.Label(dialog, text="(Repository + External files combined)",
                font=("Arial", 9, "italic"), bg=self.bg_color, fg="#888888").pack(pady=2)

        # Stats frame
        stats_frame = tk.Frame(dialog, bg=self.bg_color)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Display stats
        managed_pct = (managed_count / max(total_count, 1)) * 100
        external_pct = (external_count / max(total_count, 1)) * 100

        stats_data = [
            ("Total Programs:", f"{total_count}"),
            ("", ""),
            ("Managed Files (Repository):", f"{managed_count} ({managed_pct:.1f}%)"),
            ("External Files:", f"{external_count} ({external_pct:.1f}%)"),
            ("", ""),
            ("Total Versions:", f"{versions_count}"),
            ("", ""),
            ("Repository Size:", f"{repo_size / (1024 * 1024):.2f} MB"),
            ("Versions Size:", f"{versions_size / (1024 * 1024):.2f} MB"),
            ("Total Storage:", f"{(repo_size + versions_size) / (1024 * 1024):.2f} MB"),
        ]

        for label, value in stats_data:
            if label:  # Skip empty rows for spacing
                row = tk.Frame(stats_frame, bg=self.bg_color)
                row.pack(fill=tk.X, pady=5)

                tk.Label(row, text=label, font=("Arial", 11), bg=self.bg_color, fg=self.fg_color,
                        anchor='w').pack(side=tk.LEFT)
                tk.Label(row, text=value, font=("Arial", 11, "bold"), bg=self.bg_color, fg=self.accent_color,
                        anchor='e').pack(side=tk.RIGHT)

        # Buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="🔄 Refresh", command=lambda: [dialog.destroy(), self.show_all_programs_stats()],
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

    def show_external_stats(self):
        """Show ONLY external (non-managed) files statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Only count external files (is_managed = 0 or NULL)
        cursor.execute("SELECT COUNT(*) FROM programs WHERE (is_managed = 0 OR is_managed IS NULL) AND file_path IS NOT NULL")
        external_count = cursor.fetchone()[0]

        conn.close()

        # Create stats dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("External Files Statistics")
        dialog.geometry("500x300")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.root)
        dialog.grab_set()

        # Title
        tk.Label(dialog, text="📊 External Files Statistics",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        tk.Label(dialog, text="(Scanned files NOT in repository)",
                font=("Arial", 9, "italic"), bg=self.bg_color, fg="#888888").pack(pady=2)

        # Stats frame
        stats_frame = tk.Frame(dialog, bg=self.bg_color)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Display stats
        stats_data = [
            ("External Files:", f"{external_count}"),
            ("", ""),
            ("Note:", "External files remain in their original locations"),
            ("", "(USB drives, network folders, etc.)"),
        ]

        for label, value in stats_data:
            if label:  # Skip empty rows for spacing
                row = tk.Frame(stats_frame, bg=self.bg_color)
                row.pack(fill=tk.X, pady=5)

                if label == "Note:":
                    tk.Label(row, text=label, font=("Arial", 11, "italic"), bg=self.bg_color, fg="#888888",
                            anchor='w').pack(side=tk.LEFT)
                    tk.Label(row, text=value, font=("Arial", 11, "italic"), bg=self.bg_color, fg="#888888",
                            anchor='e').pack(side=tk.RIGHT)
                else:
                    tk.Label(row, text=label, font=("Arial", 11), bg=self.bg_color, fg=self.fg_color,
                            anchor='w').pack(side=tk.LEFT)
                    tk.Label(row, text=value, font=("Arial", 11, "bold"), bg=self.bg_color, fg=self.accent_color,
                            anchor='e').pack(side=tk.RIGHT)

        # Buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="🔄 Refresh", command=lambda: [dialog.destroy(), self.show_external_stats()],
                 bg=self.accent_color, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                 width=12, height=2).pack(side=tk.LEFT, padx=5)

    def delete_from_repository(self):
        """Delete selected program from repository (and optionally from database)"""
        # Permission check
        if not self.require_permission('delete_files', 'delete from repository'):
            return

        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to delete")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get program info
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path, is_managed, title FROM programs WHERE program_number = ?",
                      (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result:
            messagebox.showerror("Error", "Program not found in database")
            return

        file_path, is_managed, title = result

        if not is_managed:
            messagebox.showinfo("Not in Repository",
                              f"{program_number} is not in the repository.\n\n"
                              "Use 'Remove from Database' in the External tab instead.")
            return

        # Confirm deletion
        response = messagebox.askyesnocancel(
            "Delete from Repository",
            f"Delete {program_number} from repository?\n\n"
            f"Title: {title}\n"
            f"File: {file_path}\n\n"
            "Choose:\n"
            "• YES - Delete file from repository AND remove from database\n"
            "• NO - Delete file from repository but keep database entry\n"
            "• CANCEL - Don't delete anything"
        )

        if response is None:  # Cancel
            return

        # Create auto-backup before this destructive operation
        backup_path = self.create_auto_backup("delete_from_repository")
        if backup_path:
            logger.info("Auto-backup created before deletion from repository")

        try:
            # Delete the file from repository
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
                logger.info(f"Deleted file from repository: {file_path}")

            if response:  # YES - also remove from database
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("DELETE FROM programs WHERE program_number = ?", (program_number,))
                conn.commit()
                conn.close()

                self.log_activity('delete_from_repository', program_number, {
                    'file_path': file_path,
                    'removed_from_db': True
                })

                messagebox.showinfo("Success", f"{program_number} deleted from repository and database")
            else:  # NO - just update is_managed flag
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("UPDATE programs SET is_managed = 0, file_path = NULL WHERE program_number = ?",
                             (program_number,))
                conn.commit()
                conn.close()

                self.log_activity('delete_from_repository', program_number, {
                    'file_path': file_path,
                    'removed_from_db': False
                })

                messagebox.showinfo("Success", f"{program_number} deleted from repository (database entry kept)")

            # Refresh the view
            current_tab = self.view_notebook.index(self.view_notebook.select())
            if current_tab == 1:
                self.refresh_results(view_mode='repository')
            else:
                self.refresh_results(view_mode='all')

        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete file:\n{e}")

    def add_selected_to_repository(self):
        """Add selected external program to repository"""
        # Permission check
        if not self.require_permission('add_files', 'add to repository'):
            return

        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to add to repository")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Migrate to repository
        success = self.migrate_file_to_repository(program_number)

        if success:
            messagebox.showinfo("Success", f"{program_number} added to repository")
            # Refresh view
            current_tab = self.view_notebook.index(self.view_notebook.select())
            if current_tab == 2:
                self.refresh_results(view_mode='external')
            else:
                self.refresh_results(view_mode='all')
        else:
            messagebox.showerror("Error", f"Failed to add {program_number} to repository")

    def remove_from_database(self):
        """Remove selected external program from database (doesn't delete file)"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a program to remove")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get program info
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path, is_managed, title FROM programs WHERE program_number = ?",
                      (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result:
            messagebox.showerror("Error", "Program not found in database")
            return

        file_path, is_managed, title = result

        if is_managed:
            messagebox.showinfo("Repository File",
                              f"{program_number} is in the repository.\n\n"
                              "Use 'Delete from Repository' in the Repository tab instead.")
            return

        # Confirm removal
        response = messagebox.askyesno(
            "Remove from Database",
            f"Remove {program_number} from database?\n\n"
            f"Title: {title}\n"
            f"File: {file_path}\n\n"
            "The external file will NOT be deleted,\n"
            "only the database entry will be removed."
        )

        if not response:
            return

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM programs WHERE program_number = ?", (program_number,))
            conn.commit()
            conn.close()

            self.log_activity('remove_from_database', program_number, {
                'file_path': file_path,
                'was_external': True
            })

            messagebox.showinfo("Success", f"{program_number} removed from database")

            # Refresh view
            current_tab = self.view_notebook.index(self.view_notebook.select())
            if current_tab == 2:
                self.refresh_results(view_mode='external')
            else:
                self.refresh_results(view_mode='all')

        except Exception as e:
            messagebox.showerror("Error", f"Failed to remove from database:\n{e}")

    def export_selected_file(self):
        """Export selected file from repository to a location"""
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a file to export")
            return

        item = self.tree.item(selection[0])
        values = item['values']
        program_number = values[0]

        # Get file path
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT file_path, title FROM programs WHERE program_number = ?", (program_number,))
        result = cursor.fetchone()
        conn.close()

        if not result or not result[0]:
            messagebox.showerror("Error", "File path not found")
            return

        source_file = result[0]

        if not os.path.exists(source_file):
            messagebox.showerror("Error", f"Source file not found:\n{source_file}")
            return

        # Ask for destination
        default_filename = os.path.basename(source_file)
        dest_file = filedialog.asksaveasfilename(
            title="Export File",
            initialfile=default_filename,
            defaultextension=os.path.splitext(default_filename)[1],
            filetypes=[
                ("G-Code files", "*.nc *.gcode"),
                ("All files", "*.*")
            ]
        )

        if not dest_file:
            return

        try:
            shutil.copy2(source_file, dest_file)
            self.log_activity('export_file', program_number, {
                'source': source_file,
                'destination': dest_file
            })
            messagebox.showinfo("Success", f"File exported to:\n{dest_file}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export file:\n{e}")

    def manage_duplicates(self):
        """Master duplicate management dialog - choose which type to manage"""
        # Create management dialog
        mgmt_window = tk.Toplevel(self.root)
        mgmt_window.title("Duplicate Management")
        mgmt_window.geometry("750x600")
        mgmt_window.configure(bg=self.bg_color)
        mgmt_window.transient(self.root)

        # Header
        tk.Label(mgmt_window, text="🔍 Duplicate Management",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=8)

        tk.Label(mgmt_window, text="Choose the type of duplicates to manage:",
                font=("Arial", 9), bg=self.bg_color, fg=self.fg_color).pack(pady=3)

        # Create scrollable canvas
        canvas = tk.Canvas(mgmt_window, bg=self.bg_color, highlightthickness=0)
        scrollbar = ttk.Scrollbar(mgmt_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg=self.bg_color)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Main options frame (inside scrollable canvas)
        options_frame = scrollable_frame

        # Option 1: Content Duplicates (Type 2 & 3)
        content_frame = tk.LabelFrame(options_frame, text="STEP 1: Content Duplicates (Type 2 & 3) - DO THIS FIRST",
                                     bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 10, "bold"), relief=tk.RIDGE, bd=1)
        content_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(content_frame, text="Files with identical content (same OR different names)",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 8)).pack(anchor=tk.W, padx=8, pady=2)

        tk.Label(content_frame,
                text="• Type 2: o12345, o12345, o12345 (same name) • Type 3: o62000, o62500 (different names)",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Label(content_frame,
                text="• SHA256 hash match • Keeps parent/lowest # • Moves to deleted/",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Button(content_frame, text="🗑️ Delete Content Duplicates (Type 2 & 3)",
                 command=lambda: (mgmt_window.destroy(), self.delete_content_duplicates()),
                 bg="#E65100", fg=self.fg_color,
                 font=("Arial", 9, "bold"), width=35).pack(pady=5)

        # Option 2: Name Duplicates (Type 1)
        name_frame = tk.LabelFrame(options_frame, text="STEP 2: Name Conflicts (Type 1) - DO THIS SECOND",
                                  bg=self.bg_color, fg=self.fg_color,
                                  font=("Arial", 10, "bold"), relief=tk.RIDGE, bd=1)
        name_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(name_frame, text="Same base name but different content (versions/revisions)",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 8)).pack(anchor=tk.W, padx=8, pady=2)

        tk.Label(name_frame,
                text="• Type 1: o12345, o12345(1), o12345(2) with different dimensions",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Label(name_frame,
                text="• Keeps 1st file • Renames others to correct range • Updates file + database + registry",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Button(name_frame, text="✏️ Rename Name Conflicts (Type 1)",
                 command=lambda: (mgmt_window.destroy(), self.rename_name_duplicates()),
                 bg="#7B1FA2", fg=self.fg_color,
                 font=("Arial", 9, "bold"), width=35).pack(pady=5)

        # Option 3: Fix Underscore Suffixes
        underscore_frame = tk.LabelFrame(options_frame, text="STEP 3: Fix Underscore Suffixes - CLEANUP",
                                        bg=self.bg_color, fg=self.fg_color,
                                        font=("Arial", 10, "bold"), relief=tk.RIDGE, bd=1)
        underscore_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(underscore_frame, text="Files with underscore suffixes (o12345_1.nc, o12345_2.nc)",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 8)).pack(anchor=tk.W, padx=8, pady=2)

        tk.Label(underscore_frame,
                text="• Finds: o#####_#.nc patterns • Renames to correct range • Updates database + registry",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Button(underscore_frame, text="🔧 Fix Underscore Suffix Files",
                 command=lambda: (mgmt_window.destroy(), self.fix_underscore_suffix_files()),
                 bg="#FF6B00", fg=self.fg_color,
                 font=("Arial", 9, "bold"), width=35).pack(pady=5)

        # Option 4: Scan/Report Only
        scan_frame = tk.LabelFrame(options_frame, text="Scan for Duplicates",
                                  bg=self.bg_color, fg=self.fg_color,
                                  font=("Arial", 10, "bold"), relief=tk.RIDGE, bd=1)
        scan_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(scan_frame, text="Report all duplicates (no changes)",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 8)).pack(anchor=tk.W, padx=8, pady=2)

        tk.Label(scan_frame,
                text="• Read-only • Content + Name • Safe preview of duplicates",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        tk.Button(scan_frame, text="🔍 Scan for Duplicates (Report Only)",
                 command=lambda: (mgmt_window.destroy(), self.scan_for_duplicates()),
                 bg="#1976D2", fg=self.fg_color,
                 font=("Arial", 9, "bold"), width=28).pack(pady=5)

        # Option 4: Delete REPEAT Status Files
        repeat_frame = tk.LabelFrame(options_frame, text="REPEAT Status Files",
                                    bg=self.bg_color, fg=self.fg_color,
                                    font=("Arial", 10, "bold"), relief=tk.RIDGE, bd=1)
        repeat_frame.pack(fill=tk.X, pady=5, padx=10)

        tk.Label(repeat_frame, text="Files marked REPEAT by 'Find Repeats'",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 8)).pack(anchor=tk.W, padx=8, pady=2)

        tk.Label(repeat_frame,
                text="• validation_status='REPEAT' • Keeps parents • Moves to deleted/",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 8), justify=tk.LEFT).pack(anchor=tk.W, padx=15, pady=2)

        button_frame = tk.Frame(repeat_frame, bg=self.bg_color)
        button_frame.pack(pady=5)

        tk.Button(button_frame, text="🔍 Re-scan",
                 command=lambda: (mgmt_window.destroy(), self.rescan_repository_duplicates()),
                 bg="#1976D2", fg=self.fg_color,
                 font=("Arial", 8, "bold"), width=18).pack(side=tk.LEFT, padx=3)

        tk.Button(button_frame, text="🗑️ Clean",
                 command=lambda: (mgmt_window.destroy(), self.delete_repeat_status_files()),
                 bg="#C62828", fg=self.fg_color,
                 font=("Arial", 8, "bold"), width=18).pack(side=tk.LEFT, padx=3)

        # Close button (outside scrollable frame)
        close_frame = tk.Frame(mgmt_window, bg=self.bg_color)
        close_frame.pack(side=tk.BOTTOM, pady=5)

        tk.Button(close_frame, text="Cancel", command=mgmt_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 9), width=12).pack()

    def rescan_repository_duplicates(self):
        """Re-scan all repository files and update REPEAT status based on current duplicate detection"""
        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Re-scan Repository for Duplicates")
        progress_window.geometry("1000x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="🔍 Re-scan Repository for Duplicates",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text.insert(tk.END, "Re-scanning repository files for duplicates...\n\n")
        progress_text.insert(tk.END, "This will verify which files should have REPEAT status.\n\n")
        progress_text.see(tk.END)
        self.root.update()

        try:
            import hashlib
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            # Get all repository files
            cursor.execute("""
                SELECT program_number, file_path, title, duplicate_type, parent_file, validation_status
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_files = cursor.fetchall()
            progress_text.insert(tk.END, f"Found {len(all_files)} files in repository\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Calculate hashes for all files to detect content duplicates
            progress_text.insert(tk.END, "Step 1: Calculating file hashes for content analysis...\n")
            progress_text.see(tk.END)
            self.root.update()

            file_hashes = {}  # hash -> [(prog_num, title, file_path, old_status), ...]
            missing_files = []

            for idx, (prog_num, file_path, title, dup_type, parent_file, val_status) in enumerate(all_files, 1):
                if idx % 50 == 0:
                    progress_text.insert(tk.END, f"  Processed {idx}/{len(all_files)} files...\n")
                    progress_text.see(tk.END)
                    self.root.update()

                if file_path and os.path.exists(file_path):
                    try:
                        sha256_hash = hashlib.sha256()
                        with open(file_path, 'rb') as f:
                            for byte_block in iter(lambda: f.read(4096), b""):
                                sha256_hash.update(byte_block)
                        file_hash = sha256_hash.hexdigest()

                        if file_hash not in file_hashes:
                            file_hashes[file_hash] = []
                        file_hashes[file_hash].append((prog_num, title, file_path, val_status, dup_type, parent_file))
                    except Exception as e:
                        progress_text.insert(tk.END, f"  ⚠️ Error reading {prog_num}: {e}\n")
                else:
                    missing_files.append(prog_num)

            progress_text.insert(tk.END, f"\nCompleted hash calculation for {len(all_files) - len(missing_files)} files\n")
            if missing_files:
                progress_text.insert(tk.END, f"⚠️ Skipped {len(missing_files)} missing files\n")
            progress_text.insert(tk.END, f"\n")
            progress_text.see(tk.END)
            self.root.update()

            # Analyze duplicates
            progress_text.insert(tk.END, "Step 2: Analyzing duplicates...\n\n")
            progress_text.see(tk.END)
            self.root.update()

            content_duplicates = {h: files for h, files in file_hashes.items() if len(files) > 1}

            progress_text.insert(tk.END, f"Found {len(content_duplicates)} groups with duplicate content\n")
            progress_text.insert(tk.END, f"Total duplicate files: {sum(len(files) - 1 for files in content_duplicates.values())}\n\n")

            # Determine which files should be marked as REPEAT
            files_to_mark_repeat = []
            files_to_clear_repeat = []

            for file_hash, duplicates in content_duplicates.items():
                # Sort by: parent files first, then by program number
                parent_files = [f for f in duplicates if f[4] == 'parent']  # dup_type == 'parent'
                child_files = [f for f in duplicates if f[4] != 'parent']

                if parent_files:
                    # Keep first parent, mark others as REPEAT
                    keeper = sorted(parent_files, key=lambda x: x[0])[0]  # Lowest program number parent

                    for dup in parent_files[1:] if len(parent_files) > 1 else []:
                        if dup[3] != 'REPEAT':  # val_status
                            files_to_mark_repeat.append((dup[0], keeper[0], 'duplicate parent'))

                    for dup in child_files:
                        if dup[3] != 'REPEAT':
                            files_to_mark_repeat.append((dup[0], keeper[0], 'duplicate child'))
                else:
                    # No parent files, keep lowest program number
                    keeper = sorted(duplicates, key=lambda x: x[0])[0]

                    for dup in duplicates[1:]:
                        if dup[3] != 'REPEAT':
                            files_to_mark_repeat.append((dup[0], keeper[0], 'content duplicate'))

            # Find files marked as REPEAT but are NOT duplicates anymore
            for file_hash, files in file_hashes.items():
                if len(files) == 1:  # Only one file with this hash
                    prog_num, title, file_path, val_status, dup_type, parent_file = files[0]
                    if val_status == 'REPEAT':
                        files_to_clear_repeat.append(prog_num)

            progress_text.insert(tk.END, f"{'='*90}\n")
            progress_text.insert(tk.END, f"ANALYSIS RESULTS\n")
            progress_text.insert(tk.END, f"{'='*90}\n\n")
            progress_text.insert(tk.END, f"Files to mark as REPEAT: {len(files_to_mark_repeat)}\n")
            progress_text.insert(tk.END, f"Files to clear REPEAT status: {len(files_to_clear_repeat)}\n\n")

            # Show preview
            if files_to_mark_repeat:
                progress_text.insert(tk.END, f"Files to mark as REPEAT (first 30):\n")
                for prog_num, parent, reason in files_to_mark_repeat[:30]:
                    progress_text.insert(tk.END, f"  → {prog_num} ({reason} of {parent})\n")
                if len(files_to_mark_repeat) > 30:
                    progress_text.insert(tk.END, f"  ... and {len(files_to_mark_repeat) - 30} more\n")
                progress_text.insert(tk.END, f"\n")

            if files_to_clear_repeat:
                progress_text.insert(tk.END, f"Files to clear REPEAT status (not duplicates):\n")
                for prog_num in files_to_clear_repeat[:30]:
                    progress_text.insert(tk.END, f"  ✓ {prog_num} (unique file)\n")
                if len(files_to_clear_repeat) > 30:
                    progress_text.insert(tk.END, f"  ... and {len(files_to_clear_repeat) - 30} more\n")

            progress_text.insert(tk.END, f"\n")
            progress_text.see(tk.END)
            self.root.update()

            # Confirmation buttons
            def confirm_update():
                progress_text.insert(tk.END, f"\n{'='*90}\n")
                progress_text.insert(tk.END, f"UPDATING VALIDATION STATUS\n")
                progress_text.insert(tk.END, f"{'='*90}\n\n")
                progress_text.see(tk.END)

                marked_count = 0
                cleared_count = 0

                # Mark files as REPEAT
                for prog_num, parent, reason in files_to_mark_repeat:
                    try:
                        cursor.execute("""
                            UPDATE programs
                            SET validation_status = 'REPEAT',
                                parent_file = ?,
                                duplicate_type = 'child'
                            WHERE program_number = ?
                        """, (parent, prog_num))
                        marked_count += 1

                        if marked_count % 50 == 0:
                            progress_text.insert(tk.END, f"  Marked {marked_count} files as REPEAT...\n")
                            progress_text.see(tk.END)
                            self.root.update()
                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR marking {prog_num}: {e}\n")

                # Clear REPEAT status from unique files
                for prog_num in files_to_clear_repeat:
                    try:
                        # Reset to PASS status (or you could keep original status)
                        cursor.execute("""
                            UPDATE programs
                            SET validation_status = 'PASS',
                                parent_file = NULL,
                                duplicate_type = NULL
                            WHERE program_number = ?
                        """, (prog_num,))
                        cleared_count += 1

                        if cleared_count % 50 == 0:
                            progress_text.insert(tk.END, f"  Cleared {cleared_count} REPEAT statuses...\n")
                            progress_text.see(tk.END)
                            self.root.update()
                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR clearing {prog_num}: {e}\n")

                conn.commit()

                progress_text.insert(tk.END, f"\n{'='*90}\n")
                progress_text.insert(tk.END, f"COMPLETE\n")
                progress_text.insert(tk.END, f"{'='*90}\n\n")
                progress_text.insert(tk.END, f"✓ Marked as REPEAT: {marked_count} files\n")
                progress_text.insert(tk.END, f"✓ Cleared REPEAT status: {cleared_count} files\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('rescan_repository_duplicates', 'batch', {
                    'marked_repeat': marked_count,
                    'cleared_repeat': cleared_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_update():
                conn.close()
                progress_window.destroy()

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Update Status", command=confirm_update,
                     bg="#1976D2", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_update,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def delete_repeat_status_files(self):
        """Remove files with REPEAT validation status from repository (moves to deleted folder)"""
        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Clean REPEAT Status Files")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="🗑️ Clean REPEAT Status Files",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text.insert(tk.END, "Analyzing REPEAT status files in repository...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all REPEAT status files from repository
            cursor.execute("""
                SELECT program_number, file_path, title, parent_file
                FROM programs
                WHERE is_managed = 1 AND validation_status = 'REPEAT'
                ORDER BY program_number
            """)

            repeat_files = cursor.fetchall()
            progress_text.insert(tk.END, f"Found {len(repeat_files)} REPEAT status files in repository\n\n")
            progress_text.see(tk.END)
            self.root.update()

            if not repeat_files:
                progress_text.insert(tk.END, "✓ No REPEAT status files found!\n\n")
                progress_text.insert(tk.END, "All repository files have other validation statuses.\n")
                progress_text.see(tk.END)

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            # Show preview of what will be removed
            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"REPEAT FILES TO BE REMOVED\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")

            for prog_num, file_path, title, parent_file in repeat_files[:50]:
                progress_text.insert(tk.END, f"  ✗ REMOVE: {prog_num}")
                if parent_file:
                    progress_text.insert(tk.END, f" (child of {parent_file})")
                progress_text.insert(tk.END, f"\n     Title: {title[:60]}\n")

            if len(repeat_files) > 50:
                progress_text.insert(tk.END, f"\n... and {len(repeat_files) - 50} more files\n")

            progress_text.insert(tk.END, f"\n{'='*80}\n")
            progress_text.insert(tk.END, f"SUMMARY\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")
            progress_text.insert(tk.END, f"Files to remove: {len(repeat_files)}\n")
            progress_text.insert(tk.END, f"Action: Move to deleted/ folder\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Confirmation buttons
            def confirm_clean():
                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"REMOVING REPEAT FILES\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.see(tk.END)

                removed_count = 0
                error_count = 0

                for prog_num, file_path, title, parent_file in repeat_files:
                    try:
                        # Move physical file to deleted folder
                        if file_path and os.path.exists(file_path):
                            import shutil, time
                            filename = os.path.basename(file_path)
                            deleted_file_path = os.path.join(self.deleted_path, filename)

                            # If file already exists in deleted folder, add timestamp
                            if os.path.exists(deleted_file_path):
                                timestamp = time.strftime("%Y%m%d_%H%M%S")
                                name, ext = os.path.splitext(filename)
                                deleted_file_path = os.path.join(self.deleted_path, f"{name}_{timestamp}{ext}")

                            shutil.move(file_path, deleted_file_path)

                        # Remove from database
                        cursor.execute("DELETE FROM programs WHERE program_number = ?", (prog_num,))

                        progress_text.insert(tk.END, f"  ✓ Removed: {prog_num}\n")
                        removed_count += 1

                        if removed_count % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR removing {prog_num}: {e}\n")
                        error_count += 1

                conn.commit()

                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"COMPLETE\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.insert(tk.END, f"Successfully removed: {removed_count} files\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count} files\n")
                progress_text.insert(tk.END, f"\nFiles moved to: deleted/\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('delete_repeat_status_files', 'batch', {
                    'removed_count': removed_count,
                    'error_count': error_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_clean():
                conn.close()
                progress_window.destroy()

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Confirm Clean", command=confirm_clean,
                     bg="#C62828", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_clean,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def delete_content_duplicates(self):
        """Find and delete files with duplicate content (same hash), keeping parent files"""
        import hashlib

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Delete Content Duplicates")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="🧹 Delete Content Duplicates",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text.insert(tk.END, "Analyzing repository files for content duplicates...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all managed files from repository
            cursor.execute("""
                SELECT program_number, file_path, duplicate_type, parent_file
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_files = cursor.fetchall()
            progress_text.insert(tk.END, f"Found {len(all_files)} files in repository\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Calculate hashes for all files
            progress_text.insert(tk.END, "Calculating file hashes...\n")
            progress_text.see(tk.END)
            self.root.update()

            file_hashes = {}  # hash -> list of (program_number, file_path, duplicate_type, parent_file)
            missing_files = []

            for idx, (prog_num, file_path, dup_type, parent_file) in enumerate(all_files, 1):
                if idx % 50 == 0:
                    progress_text.insert(tk.END, f"  Processed {idx}/{len(all_files)} files...\n")
                    progress_text.see(tk.END)
                    self.root.update()

                if not file_path or not os.path.exists(file_path):
                    missing_files.append((prog_num, file_path))
                    continue

                try:
                    # Calculate SHA256 hash
                    sha256_hash = hashlib.sha256()
                    with open(file_path, 'rb') as f:
                        for byte_block in iter(lambda: f.read(4096), b""):
                            sha256_hash.update(byte_block)
                    file_hash = sha256_hash.hexdigest()

                    if file_hash not in file_hashes:
                        file_hashes[file_hash] = []
                    file_hashes[file_hash].append((prog_num, file_path, dup_type, parent_file))
                except Exception as e:
                    progress_text.insert(tk.END, f"  ERROR reading {prog_num}: {e}\n")

            progress_text.insert(tk.END, f"\nHash calculation complete!\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Find duplicate groups (hashes with multiple files)
            duplicate_groups = {h: files for h, files in file_hashes.items() if len(files) > 1}

            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"DUPLICATE ANALYSIS\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")
            progress_text.insert(tk.END, f"Total files analyzed: {len(all_files)}\n")
            progress_text.insert(tk.END, f"Unique content: {len(file_hashes)}\n")
            progress_text.insert(tk.END, f"Duplicate groups: {len(duplicate_groups)}\n")

            if missing_files:
                progress_text.insert(tk.END, f"Missing files: {len(missing_files)}\n")

            progress_text.insert(tk.END, f"\n")
            progress_text.see(tk.END)
            self.root.update()

            if not duplicate_groups:
                progress_text.insert(tk.END, "✓ No content duplicates found!\n\n")
                progress_text.insert(tk.END, "All files in repository have unique content.\n")
                progress_text.see(tk.END)
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            # Analyze each duplicate group and determine what to delete
            files_to_delete = []  # List of (program_number, file_path, reason)

            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"DUPLICATE GROUPS\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")

            for hash_val, duplicates in duplicate_groups.items():
                progress_text.insert(tk.END, f"Group ({len(duplicates)} files with identical content):\n")

                # Sort by: parent files first, then by program number
                # Parent files (duplicate_type = 'parent' or parent_file IS NULL) should be kept
                parent_files = [f for f in duplicates if f[2] == 'parent' or not f[3]]
                child_files = [f for f in duplicates if f[2] != 'parent' and f[3]]

                if parent_files:
                    # Keep the first parent (or lowest program number if multiple parents)
                    parent_files_sorted = sorted(parent_files, key=lambda x: x[0])
                    keeper = parent_files_sorted[0]
                    progress_text.insert(tk.END, f"  ✓ KEEP: {keeper[0]} (parent/original)\n")

                    # Mark other parents as duplicates to delete
                    for dup in parent_files_sorted[1:]:
                        files_to_delete.append((dup[0], dup[1], f"duplicate of parent {keeper[0]}"))
                        progress_text.insert(tk.END, f"  ✗ DELETE: {dup[0]} (duplicate parent)\n")

                    # Mark all children as duplicates to delete
                    for dup in child_files:
                        files_to_delete.append((dup[0], dup[1], f"duplicate of parent {keeper[0]}"))
                        progress_text.insert(tk.END, f"  ✗ DELETE: {dup[0]} (duplicate child)\n")
                else:
                    # No parent files, keep the one with lowest program number
                    duplicates_sorted = sorted(duplicates, key=lambda x: x[0])
                    keeper = duplicates_sorted[0]
                    progress_text.insert(tk.END, f"  ✓ KEEP: {keeper[0]} (lowest program number)\n")

                    for dup in duplicates_sorted[1:]:
                        files_to_delete.append((dup[0], dup[1], f"duplicate of {keeper[0]}"))
                        progress_text.insert(tk.END, f"  ✗ DELETE: {dup[0]}\n")

                progress_text.insert(tk.END, f"\n")
                progress_text.see(tk.END)
                self.root.update()

            # Summary
            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"SUMMARY\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")
            progress_text.insert(tk.END, f"Files to delete: {len(files_to_delete)}\n")
            progress_text.insert(tk.END, f"Files to keep: {len(file_hashes)}\n\n")

            if files_to_delete:
                progress_text.insert(tk.END, f"Files marked for deletion:\n")
                for prog_num, file_path, reason in files_to_delete[:20]:
                    progress_text.insert(tk.END, f"  • {prog_num} - {reason}\n")
                if len(files_to_delete) > 20:
                    progress_text.insert(tk.END, f"  ... and {len(files_to_delete) - 20} more\n")

            progress_text.insert(tk.END, f"\n")
            progress_text.see(tk.END)
            self.root.update()

            # Confirmation buttons
            def confirm_delete():
                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"DELETING FILES\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.see(tk.END)

                deleted_count = 0
                error_count = 0

                for prog_num, file_path, reason in files_to_delete:
                    try:
                        # Move physical file to deleted folder instead of deleting
                        if os.path.exists(file_path):
                            import shutil
                            filename = os.path.basename(file_path)
                            deleted_file_path = os.path.join(self.deleted_path, filename)

                            # If file already exists in deleted folder, add timestamp
                            if os.path.exists(deleted_file_path):
                                import time
                                timestamp = time.strftime("%Y%m%d_%H%M%S")
                                name, ext = os.path.splitext(filename)
                                deleted_file_path = os.path.join(self.deleted_path, f"{name}_{timestamp}{ext}")

                            shutil.move(file_path, deleted_file_path)

                        # Remove from database
                        cursor.execute("DELETE FROM programs WHERE program_number = ?", (prog_num,))

                        progress_text.insert(tk.END, f"  ✓ Moved to deleted/: {prog_num}\n")
                        deleted_count += 1

                        if deleted_count % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR moving {prog_num}: {e}\n")
                        error_count += 1

                conn.commit()

                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"COMPLETE\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.insert(tk.END, f"Successfully deleted: {deleted_count} files\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count} files\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('delete_content_duplicates', 'batch', {
                    'deleted_count': deleted_count,
                    'error_count': error_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_delete():
                conn.close()
                progress_window.destroy()

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Confirm Delete", command=confirm_delete,
                     bg="#D32F2F", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_delete,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def scan_for_duplicates(self):
        """Scan repository for all types of duplicates and show report"""
        import hashlib

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Duplicate Scan Report")
        progress_window.geometry("1000x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="🔍 Duplicate Scan Report",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text.insert(tk.END, "Scanning repository for duplicates...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all managed files from repository
            cursor.execute("""
                SELECT program_number, title, file_path
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_files = cursor.fetchall()
            progress_text.insert(tk.END, f"Found {len(all_files)} files in repository\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Group by program number (name duplicates)
            name_groups = {}
            import re
            for prog_num, title, file_path in all_files:
                # Skip records with None program_number
                if not prog_num:
                    continue
                # Extract base program number (remove suffixes like (1), (2))
                base_num = re.sub(r'\(\d+\)$', '', prog_num)

                if base_num not in name_groups:
                    name_groups[base_num] = []
                name_groups[base_num].append((prog_num, title, file_path))

            # Find name duplicates
            name_duplicates = {k: v for k, v in name_groups.items() if len(v) > 1}

            # Calculate hashes for content duplicates
            progress_text.insert(tk.END, "Calculating file hashes for content analysis...\n")
            progress_text.see(tk.END)
            self.root.update()

            file_hashes = {}
            for idx, (prog_num, title, file_path) in enumerate(all_files, 1):
                if idx % 50 == 0:
                    progress_text.insert(tk.END, f"  Processed {idx}/{len(all_files)} files...\n")
                    progress_text.see(tk.END)
                    self.root.update()

                if file_path and os.path.exists(file_path):
                    try:
                        sha256_hash = hashlib.sha256()
                        with open(file_path, 'rb') as f:
                            for byte_block in iter(lambda: f.read(4096), b""):
                                sha256_hash.update(byte_block)
                        file_hash = sha256_hash.hexdigest()

                        if file_hash not in file_hashes:
                            file_hashes[file_hash] = []
                        file_hashes[file_hash].append((prog_num, title, file_path))
                    except:
                        pass

            # Find content duplicates
            content_duplicates = {h: files for h, files in file_hashes.items() if len(files) > 1}

            # Generate report
            progress_text.insert(tk.END, f"\n{'='*90}\n")
            progress_text.insert(tk.END, f"DUPLICATE SCAN REPORT\n")
            progress_text.insert(tk.END, f"{'='*90}\n\n")

            progress_text.insert(tk.END, f"Total repository files: {len(all_files)}\n")
            progress_text.insert(tk.END, f"Name duplicate groups: {len(name_duplicates)}\n")
            progress_text.insert(tk.END, f"Content duplicate groups: {len(content_duplicates)}\n\n")

            # Section 1: Name Duplicates
            if name_duplicates:
                progress_text.insert(tk.END, f"{'='*90}\n")
                progress_text.insert(tk.END, f"NAME DUPLICATES (Same base program number, different titles/content)\n")
                progress_text.insert(tk.END, f"{'='*90}\n\n")

                for base_num, files in sorted(name_duplicates.items())[:20]:
                    progress_text.insert(tk.END, f"Base: {base_num} ({len(files)} files)\n")
                    for prog_num, title, file_path in files:
                        progress_text.insert(tk.END, f"  • {prog_num}: {title[:50]}\n")
                    progress_text.insert(tk.END, f"\n")

                if len(name_duplicates) > 20:
                    progress_text.insert(tk.END, f"... and {len(name_duplicates) - 20} more groups\n\n")
            else:
                progress_text.insert(tk.END, "✓ No name duplicates found\n\n")

            # Section 2: Content Duplicates
            if content_duplicates:
                progress_text.insert(tk.END, f"{'='*90}\n")
                progress_text.insert(tk.END, f"CONTENT DUPLICATES (Exact file content match)\n")
                progress_text.insert(tk.END, f"{'='*90}\n\n")

                for hash_val, files in list(content_duplicates.items())[:20]:
                    progress_text.insert(tk.END, f"Group ({len(files)} files with identical content):\n")
                    for prog_num, title, file_path in files:
                        progress_text.insert(tk.END, f"  • {prog_num}: {title[:50]}\n")
                    progress_text.insert(tk.END, f"\n")

                if len(content_duplicates) > 20:
                    progress_text.insert(tk.END, f"... and {len(content_duplicates) - 20} more groups\n\n")
            else:
                progress_text.insert(tk.END, "✓ No content duplicates found\n\n")

            # Summary and recommendations
            progress_text.insert(tk.END, f"{'='*90}\n")
            progress_text.insert(tk.END, f"RECOMMENDATIONS\n")
            progress_text.insert(tk.END, f"{'='*90}\n\n")

            if name_duplicates:
                progress_text.insert(tk.END, f"→ Name Duplicates: Use '✏️ Rename Name Duplicates' to consolidate\n")
            if content_duplicates:
                progress_text.insert(tk.END, f"→ Content Duplicates: Use '🧹 Delete Content Duplicates' to remove\n")

            if not name_duplicates and not content_duplicates:
                progress_text.insert(tk.END, f"✓ Repository is clean - no duplicates found!\n")

            progress_text.see(tk.END)
            conn.close()

            # Close button
            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def rename_name_duplicates(self):
        """Rename files with same base name but different content/title"""
        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Rename Name Duplicates")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="✏️ Rename Name Duplicates",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text.insert(tk.END, "Analyzing name duplicates...\n\n")
        progress_text.see(tk.END)
        self.root.update()

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get all managed files from repository
            cursor.execute("""
                SELECT program_number, title, file_path
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_files = cursor.fetchall()
            progress_text.insert(tk.END, f"Found {len(all_files)} files in repository\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Group by base program number (remove suffixes like (1), (2))
            import re
            name_groups = {}
            for prog_num, title, file_path in all_files:
                # Skip records with None program_number
                if not prog_num:
                    continue
                base_num = re.sub(r'\(\d+\)$', '', prog_num)

                if base_num not in name_groups:
                    name_groups[base_num] = []
                name_groups[base_num].append((prog_num, title, file_path))

            # Find name duplicates (multiple files with same base number)
            name_duplicates = {k: v for k, v in name_groups.items() if len(v) > 1}

            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"NAME DUPLICATE ANALYSIS\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")
            progress_text.insert(tk.END, f"Name duplicate groups found: {len(name_duplicates)}\n\n")

            if not name_duplicates:
                progress_text.insert(tk.END, "✓ No name duplicates found!\n\n")
                progress_text.insert(tk.END, "All files have unique base program numbers.\n")
                progress_text.see(tk.END)
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            # Show duplicates and prepare rename suggestions
            renames_to_apply = []  # (old_prog_num, new_prog_num, round_size)
            assigned_numbers = set()  # Track numbers we've already assigned in this session

            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"DUPLICATE GROUPS (Will keep first, rename others)\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")

            for base_num, files in sorted(name_duplicates.items())[:30]:
                progress_text.insert(tk.END, f"Base: {base_num} ({len(files)} files)\n")

                # Keep first file, rename others
                for idx, (prog_num, title, file_path) in enumerate(files):
                    if idx == 0:
                        progress_text.insert(tk.END, f"  ✓ KEEP: {prog_num} - {title[:40]}\n")
                    else:
                        # Get round size for this duplicate file
                        cursor.execute("SELECT round_size FROM programs WHERE program_number = ?", (prog_num,))
                        round_result = cursor.fetchone()
                        round_size = round_result[0] if round_result and round_result[0] else None

                        if round_size:
                            # Find next available number in correct range for this round size
                            # Keep trying until we find one not already assigned in this session
                            new_prog_num = None
                            attempts = 0
                            max_attempts = 100  # Prevent infinite loop

                            while attempts < max_attempts:
                                candidate = self.find_next_available_number(round_size)
                                if not candidate:
                                    break  # No more available numbers

                                # Check if already exists in database OR already assigned in this session
                                cursor.execute("SELECT COUNT(*) FROM programs WHERE program_number = ?", (candidate,))
                                exists = cursor.fetchone()[0] > 0

                                if not exists and candidate not in assigned_numbers:
                                    new_prog_num = candidate
                                    assigned_numbers.add(new_prog_num)  # Mark as assigned
                                    break
                                else:
                                    # This number is taken, temporarily mark it in registry to get next one
                                    cursor.execute("UPDATE program_number_registry SET status = 'IN_USE' WHERE program_number = ?", (candidate,))
                                    conn.commit()  # Commit immediately to avoid locking
                                    attempts += 1

                            if new_prog_num:
                                # Get the range info to show in output
                                range_info = self.get_range_for_round_size(round_size)
                                if range_info:
                                    range_start, range_end = range_info
                                    renames_to_apply.append((prog_num, new_prog_num, round_size))
                                    progress_text.insert(tk.END, f"  ✏️ RENAME: {prog_num} → {new_prog_num} ({round_size}\" range: o{range_start}-o{range_end}) - {title[:40]}\n")
                                else:
                                    renames_to_apply.append((prog_num, new_prog_num, round_size))
                                    progress_text.insert(tk.END, f"  ✏️ RENAME: {prog_num} → {new_prog_num} ({round_size}\") - {title[:40]}\n")
                            else:
                                progress_text.insert(tk.END, f"  ⚠️ SKIP: {prog_num} - No available numbers for {round_size}\" - {title[:40]}\n")
                        else:
                            # No round size detected - use free range (o1000-o9999)
                            # Keep trying until we find one not already assigned
                            new_prog_num = None
                            attempts = 0
                            max_attempts = 100

                            while attempts < max_attempts:
                                cursor.execute("""
                                    SELECT MIN(program_number)
                                    FROM program_number_registry
                                    WHERE status = 'AVAILABLE'
                                    AND CAST(REPLACE(program_number, 'o', '') AS INTEGER) BETWEEN 1000 AND 9999
                                """)
                                free_result = cursor.fetchone()
                                if not free_result or not free_result[0]:
                                    break  # No more available numbers

                                candidate = free_result[0]

                                # Check if already exists in database OR already assigned in this session
                                cursor.execute("SELECT COUNT(*) FROM programs WHERE program_number = ?", (candidate,))
                                exists = cursor.fetchone()[0] > 0

                                if not exists and candidate not in assigned_numbers:
                                    new_prog_num = candidate
                                    assigned_numbers.add(new_prog_num)  # Mark as assigned
                                    break
                                else:
                                    # This number is taken, temporarily mark it in registry to get next one
                                    cursor.execute("UPDATE program_number_registry SET status = 'IN_USE' WHERE program_number = ?", (candidate,))
                                    conn.commit()  # Commit immediately to avoid locking
                                    attempts += 1

                            if new_prog_num:
                                renames_to_apply.append((prog_num, new_prog_num, None))
                                progress_text.insert(tk.END, f"  ✏️ RENAME: {prog_num} → {new_prog_num} (free range) - {title[:40]}\n")
                            else:
                                progress_text.insert(tk.END, f"  ⚠️ SKIP: {prog_num} - No round size, no free numbers - {title[:40]}\n")

                progress_text.insert(tk.END, f"\n")
                progress_text.see(tk.END)
                self.root.update()

            if len(name_duplicates) > 30:
                progress_text.insert(tk.END, f"... and {len(name_duplicates) - 30} more groups\n\n")

            # Summary
            progress_text.insert(tk.END, f"{'='*80}\n")
            progress_text.insert(tk.END, f"SUMMARY\n")
            progress_text.insert(tk.END, f"{'='*80}\n\n")
            progress_text.insert(tk.END, f"Files to rename: {len(renames_to_apply)}\n\n")

            if renames_to_apply:
                progress_text.insert(tk.END, f"Rename list (first 20):\n")
                for item in renames_to_apply[:20]:
                    old_num, new_num = item[0], item[1]
                    round_size = item[2] if len(item) > 2 else None
                    if round_size:
                        progress_text.insert(tk.END, f"  • {old_num} → {new_num} ({round_size}\")\n")
                    else:
                        progress_text.insert(tk.END, f"  • {old_num} → {new_num} (free range)\n")
                if len(renames_to_apply) > 20:
                    progress_text.insert(tk.END, f"  ... and {len(renames_to_apply) - 20} more\n")

            progress_text.insert(tk.END, f"\n")
            progress_text.see(tk.END)
            self.root.update()

            # Confirmation buttons
            def confirm_rename():
                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"RENAMING FILES\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.see(tk.END)

                renamed_count = 0
                error_count = 0

                for item in renames_to_apply:
                    old_num, new_num = item[0], item[1]
                    try:
                        # Get current file path
                        cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (old_num,))
                        result = cursor.fetchone()
                        if not result or not result[0]:
                            progress_text.insert(tk.END, f"  ✗ ERROR: No file path for {old_num}\n")
                            error_count += 1
                            continue

                        old_file_path = result[0]

                        # Skip if file doesn't exist
                        if not os.path.exists(old_file_path):
                            progress_text.insert(tk.END, f"  ⚠️ SKIP: File not found for {old_num}\n")
                            error_count += 1
                            continue

                        # Generate new file path
                        old_dir = os.path.dirname(old_file_path)
                        old_filename = os.path.basename(old_file_path)

                        # Create new filename - match exactly the program number
                        # Example: program_number = o85000 -> filename = o85000.nc
                        new_filename = f"{new_num}.nc"
                        new_file_path = os.path.join(old_dir, new_filename)

                        # Read file content and update internal program number
                        with open(old_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        # Replace first line program number (e.g., O12345 -> O12346)
                        import re
                        # Match O-number at start of line (case insensitive)
                        old_num_numeric = old_num.replace('o', '').replace('O', '')
                        new_num_numeric = new_num.replace('o', '').replace('O', '')

                        # Replace O-number in first line
                        lines = content.split('\n')
                        if lines and re.match(r'^[oO]\d+', lines[0].strip()):
                            lines[0] = re.sub(r'^[oO]\d+', f'O{new_num_numeric}', lines[0].strip())
                            content = '\n'.join(lines)

                        # Write to new file
                        with open(new_file_path, 'w', encoding='utf-8') as f:
                            f.write(content)

                        # Delete old file
                        os.remove(old_file_path)

                        # Update database with new program number and file path
                        cursor.execute("UPDATE programs SET program_number = ?, file_path = ? WHERE program_number = ?",
                                     (new_num, new_file_path, old_num))

                        # Update registry: mark old number as AVAILABLE, new number as IN_USE
                        cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE', file_path = NULL WHERE program_number = ?", (old_num,))
                        cursor.execute("UPDATE program_number_registry SET status = 'IN_USE', file_path = ? WHERE program_number = ?", (new_file_path, new_num))

                        progress_text.insert(tk.END, f"  ✓ Renamed: {old_num} → {new_num} (file + internal + registry)\n")
                        renamed_count += 1

                        if renamed_count % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR renaming {old_num}: {e}\n")
                        error_count += 1

                conn.commit()

                progress_text.insert(tk.END, f"\n{'='*80}\n")
                progress_text.insert(tk.END, f"COMPLETE\n")
                progress_text.insert(tk.END, f"{'='*80}\n\n")
                progress_text.insert(tk.END, f"Successfully renamed: {renamed_count} files\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count} files\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('rename_name_duplicates', 'batch', {
                    'renamed_count': renamed_count,
                    'error_count': error_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_rename():
                # Rollback temporary IN_USE markings in registry
                for num in assigned_numbers:
                    cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE' WHERE program_number = ?", (num,))
                conn.commit()
                conn.close()
                progress_window.destroy()

            # Set window close handler to ensure cleanup even if user closes window with X button
            progress_window.protocol("WM_DELETE_WINDOW", cancel_rename)

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Confirm Rename", command=confirm_rename,
                     bg="#7B1FA2", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_rename,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            # Rollback temporary IN_USE markings if they exist
            if 'assigned_numbers' in locals() and 'cursor' in locals() and 'conn' in locals():
                try:
                    for num in assigned_numbers:
                        cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE' WHERE program_number = ?", (num,))
                    conn.commit()
                except:
                    pass  # Ignore errors during cleanup

            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            # Close connection if it exists
            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def fix_underscore_suffix_files(self):
        """Fix files with underscore suffix patterns (o12345_1.nc) by renaming to correct ranges"""

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Fix Underscore Suffix Files")
        progress_window.geometry("800x600")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)
        progress_window.grab_set()

        tk.Label(progress_window, text="🔧 Fix Underscore Suffix Files",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack(pady=10)

        # Info frame
        info_frame = tk.Frame(progress_window, bg=self.bg_color)
        info_frame.pack(fill=tk.X, padx=20, pady=5)

        tk.Label(info_frame,
                text="This will find and rename files with underscore suffix patterns (o12345_1.nc, o12345_2.nc)\n"
                     "to available numbers in their correct round size ranges.",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9), justify=tk.LEFT).pack(anchor=tk.W)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        scrollbar = ttk.Scrollbar(text_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        progress_text = tk.Text(text_frame, height=25, yscrollcommand=scrollbar.set,
                               bg="#2B2B2B", fg="#FFFFFF", font=("Consolas", 9), wrap=tk.WORD)
        scrollbar.config(command=progress_text.yview)
        progress_text.pack(fill=tk.BOTH, expand=True)

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            progress_text.insert(tk.END, "Scanning for files with underscore suffixes...\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Find all repository files with underscore suffix patterns in program_number or filename
            # Pattern: o#####_# (5 digits followed by underscore and more digits)
            # Use INSTR to find actual underscore characters (not SQL wildcard _)
            cursor.execute("""
                SELECT program_number, file_path, round_size, title
                FROM programs
                WHERE is_managed = 1
                AND (
                    INSTR(program_number, '_') > 0
                    OR program_number LIKE 'o%(%'
                )
                ORDER BY program_number
            """)

            underscore_files = cursor.fetchall()

            if not underscore_files:
                progress_text.insert(tk.END, "No files with underscore suffixes found.\n")
                progress_text.see(tk.END)

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            progress_text.insert(tk.END, f"Found {len(underscore_files)} files with underscore/parenthesis patterns\n\n")

            # Group and analyze
            renames_to_apply = []
            assigned_numbers = set()  # Track numbers already assigned in this session

            for prog_num, file_path, round_size, title in underscore_files:
                progress_text.insert(tk.END, f"Analyzing: {prog_num}\n")
                progress_text.insert(tk.END, f"  File: {os.path.basename(file_path)}\n")
                progress_text.insert(tk.END, f"  Title: {title or 'N/A'}\n")

                if round_size:
                    progress_text.insert(tk.END, f"  Round Size: {round_size}\"\n")

                    # Find next available number - keep trying until we get one not already assigned
                    new_prog_num = None
                    attempts = 0
                    max_attempts = 100

                    while attempts < max_attempts:
                        candidate = self.find_next_available_number(round_size)
                        if not candidate:
                            break

                        # Check if already exists in database OR already assigned in this session
                        cursor.execute("SELECT COUNT(*) FROM programs WHERE program_number = ?", (candidate,))
                        exists = cursor.fetchone()[0] > 0

                        if not exists and candidate not in assigned_numbers:
                            new_prog_num = candidate
                            assigned_numbers.add(new_prog_num)
                            break
                        else:
                            # Temporarily mark as IN_USE to get next number
                            cursor.execute("UPDATE program_number_registry SET status = 'IN_USE' WHERE program_number = ?", (candidate,))
                            conn.commit()  # Commit immediately to avoid locking and ensure next query sees updated status
                            attempts += 1

                    if new_prog_num:
                        renames_to_apply.append((prog_num, new_prog_num, round_size, file_path, title))
                        progress_text.insert(tk.END, f"  ✓ Will rename to: {new_prog_num} ({round_size}\" range)\n")
                    else:
                        progress_text.insert(tk.END, f"  ✗ No available numbers in {round_size}\" range\n")
                else:
                    progress_text.insert(tk.END, f"  Round Size: Not detected\n")

                    # Use free range - keep trying until we get one not already assigned
                    new_prog_num = None
                    attempts = 0
                    max_attempts = 100

                    while attempts < max_attempts:
                        cursor.execute("""
                            SELECT MIN(program_number)
                            FROM program_number_registry
                            WHERE status = 'AVAILABLE'
                            AND CAST(REPLACE(program_number, 'o', '') AS INTEGER) BETWEEN 1000 AND 9999
                        """)
                        free_result = cursor.fetchone()
                        if not free_result or not free_result[0]:
                            break

                        candidate = free_result[0]

                        # Check if already exists in database OR already assigned in this session
                        cursor.execute("SELECT COUNT(*) FROM programs WHERE program_number = ?", (candidate,))
                        exists = cursor.fetchone()[0] > 0

                        if not exists and candidate not in assigned_numbers:
                            new_prog_num = candidate
                            assigned_numbers.add(new_prog_num)
                            break
                        else:
                            # Temporarily mark as IN_USE to get next number
                            cursor.execute("UPDATE program_number_registry SET status = 'IN_USE' WHERE program_number = ?", (candidate,))
                            conn.commit()  # Commit immediately to avoid locking and ensure next query sees updated status
                            attempts += 1

                    if new_prog_num:
                        renames_to_apply.append((prog_num, new_prog_num, None, file_path, title))
                        progress_text.insert(tk.END, f"  ✓ Will rename to: {new_prog_num} (free range)\n")
                    else:
                        progress_text.insert(tk.END, f"  ✗ No available numbers in free range\n")

                progress_text.insert(tk.END, "\n")
                progress_text.see(tk.END)
                self.root.update()

            if not renames_to_apply:
                progress_text.insert(tk.END, "\n" + "="*80 + "\n")
                progress_text.insert(tk.END, "No renames possible (no available program numbers)\n")
                progress_text.see(tk.END)

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            # Show summary
            progress_text.insert(tk.END, "="*80 + "\n")
            progress_text.insert(tk.END, f"PREVIEW - {len(renames_to_apply)} files ready to rename:\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")

            for old_num, new_num, round_size, file_path, title in renames_to_apply:
                size_str = f"({round_size}\")" if round_size else "(free range)"
                title_str = title or "UNKNOWN"
                progress_text.insert(tk.END, f"✏️ RENAME: {old_num} → {new_num} {size_str} - {title_str}\n")

            progress_text.insert(tk.END, "\n" + "="*80 + "\n")
            progress_text.insert(tk.END, "Click 'Confirm Rename' to proceed or 'Cancel' to abort.\n")
            progress_text.see(tk.END)

            def confirm_rename():
                progress_text.insert(tk.END, "\n" + "="*80 + "\n")
                progress_text.insert(tk.END, "STARTING RENAME OPERATIONS...\n")
                progress_text.insert(tk.END, "="*80 + "\n\n")
                progress_text.see(tk.END)

                renamed_count = 0
                error_count = 0

                for old_num, new_num, round_size, old_file_path, title in renames_to_apply:
                    try:
                        progress_text.insert(tk.END, f"Processing: {old_num} → {new_num}\n")

                        # Read the file content
                        if not os.path.exists(old_file_path):
                            progress_text.insert(tk.END, f"  ✗ ERROR: File not found: {old_file_path}\n")
                            error_count += 1
                            continue

                        with open(old_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        # Replace the O-number in the content (case-insensitive)
                        # Remove suffix before replacing (o12345_1 → o12345)
                        base_old_num = old_num.split('_')[0].split('(')[0]
                        new_content = re.sub(
                            rf'(?i)({base_old_num})',
                            new_num,
                            content
                        )

                        # Create new filename - exactly the program number
                        old_dir = os.path.dirname(old_file_path)
                        new_filename = f"{new_num}.nc"
                        new_file_path = os.path.join(old_dir, new_filename)

                        # Rename the file
                        os.rename(old_file_path, new_file_path)
                        progress_text.insert(tk.END, f"  ✓ File renamed: {os.path.basename(old_file_path)} → {new_filename}\n")

                        # Write the updated content
                        with open(new_file_path, 'w', encoding='utf-8') as f:
                            f.write(new_content)
                        progress_text.insert(tk.END, f"  ✓ Internal O-number updated: {base_old_num} → {new_num}\n")

                        # Update database
                        cursor.execute("""
                            UPDATE programs
                            SET program_number = ?,
                                file_path = ?
                            WHERE program_number = ?
                        """, (new_num, new_file_path, old_num))
                        progress_text.insert(tk.END, f"  ✓ Database updated\n")

                        # Update registry: mark old number as AVAILABLE (if it exists), new number as IN_USE
                        cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE', file_path = NULL WHERE program_number = ?", (old_num,))
                        cursor.execute("UPDATE program_number_registry SET status = 'IN_USE', file_path = ? WHERE program_number = ?", (new_file_path, new_num))

                        progress_text.insert(tk.END, f"  ✓ Registry updated\n")
                        progress_text.insert(tk.END, f"  ✅ Complete: {old_num} → {new_num}\n\n")
                        renamed_count += 1

                        if renamed_count % 5 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR: {e}\n\n")
                        error_count += 1

                conn.commit()

                progress_text.insert(tk.END, "="*80 + "\n")
                progress_text.insert(tk.END, "COMPLETE\n")
                progress_text.insert(tk.END, "="*80 + "\n\n")
                progress_text.insert(tk.END, f"Successfully renamed: {renamed_count} files\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count} files\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('fix_underscore_suffixes', 'batch', {
                    'renamed_count': renamed_count,
                    'error_count': error_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_rename():
                # Rollback temporary IN_USE markings in registry
                for num in assigned_numbers:
                    cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE' WHERE program_number = ?", (num,))
                conn.commit()
                conn.close()
                progress_window.destroy()

            # Set window close handler to ensure cleanup even if user closes window with X button
            progress_window.protocol("WM_DELETE_WINDOW", cancel_rename)

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Confirm Rename", command=confirm_rename,
                     bg="#7B1FA2", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_rename,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            # Rollback temporary IN_USE markings if they exist
            if 'assigned_numbers' in locals() and 'cursor' in locals() and 'conn' in locals():
                try:
                    for num in assigned_numbers:
                        cursor.execute("UPDATE program_number_registry SET status = 'AVAILABLE' WHERE program_number = ?", (num,))
                    conn.commit()
                except:
                    pass  # Ignore errors during cleanup

            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            # Close connection if it exists
            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def sync_filenames_with_database(self):
        """Synchronize filenames with their program numbers in the database"""

        # Create auto-backup before this destructive operation
        backup_path = self.create_auto_backup("sync_filenames")
        if backup_path:
            logger.info("Auto-backup created before syncing filenames")

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Sync Filenames with Database")
        progress_window.geometry("800x600")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="🔄 Sync Filenames with Program Numbers",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            progress_text.insert(tk.END, "Scanning for filename mismatches...\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Find all managed files where filename doesn't match program number
            cursor.execute("""
                SELECT program_number, file_path, title
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_files = cursor.fetchall()
            mismatches = []

            for prog_num, file_path, title in all_files:
                if not file_path or not os.path.exists(file_path):
                    continue

                # Get current filename without extension
                current_filename = os.path.basename(file_path)
                current_base = os.path.splitext(current_filename)[0]

                # Read the ACTUAL internal program number from the G-code file
                import re
                internal_prog_num = None
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        # Check first 10 lines for program number (might be after % delimiter)
                        for _ in range(10):
                            line = f.readline().strip()
                            if not line:
                                continue
                            # Look for O-number at start of line (e.g., O96002, o80366)
                            match = re.match(r'^[oO](\d{4,})', line)
                            if match:
                                internal_prog_num = f"o{match.group(1)}"
                                break
                except:
                    pass

                # If we found an internal program number and it doesn't match filename
                if internal_prog_num and current_base.lower() != internal_prog_num.lower():
                    # Expected filename = internal program number
                    expected_base = internal_prog_num
                    mismatches.append((prog_num, file_path, current_base, expected_base, title))

            if not mismatches:
                progress_text.insert(tk.END, "✓ No filename mismatches found!\n\n")
                progress_text.insert(tk.END, "All filenames match their program numbers.\n")
                progress_text.see(tk.END)

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            # Handle collisions by assigning new program numbers in correct range
            resolved_mismatches = []
            reassigned_files = []  # Files that got new program numbers due to collision

            # Track numbers we assign during this operation to avoid duplicates
            newly_assigned_numbers = set()

            # Also track target program numbers we've decided to use (not just newly assigned)
            target_program_numbers = set()

            def find_next_available_number(round_size, cursor, repo_dir):
                """Find the next available program number for this round size using the registry"""
                ranges = self.get_round_size_ranges()
                if round_size in ranges:
                    range_start, range_end, _ = ranges[round_size]
                else:
                    # Use free range
                    range_start, range_end, _ = ranges.get(0.0, (14000, 49999, "Free Range"))

                # Query registry for available numbers in this range
                cursor.execute("""
                    SELECT program_number FROM program_number_registry
                    WHERE status = 'AVAILABLE'
                    ORDER BY program_number
                """)

                available_from_registry = []
                for row in cursor.fetchall():
                    try:
                        num = int(row[0].replace('o', '').replace('O', ''))
                        if range_start <= num <= range_end:
                            if num not in newly_assigned_numbers:
                                available_from_registry.append(num)
                    except:
                        pass

                # Return first available from registry in this range
                if available_from_registry:
                    num = min(available_from_registry)
                    newly_assigned_numbers.add(num)
                    return f"o{num}"

                # If no available in registry for this range, find gaps
                cursor.execute("""
                    SELECT program_number FROM program_number_registry
                    WHERE status = 'IN_USE'
                """)
                used_numbers = set()
                for row in cursor.fetchall():
                    try:
                        num = int(row[0].replace('o', '').replace('O', ''))
                        used_numbers.add(num)
                    except:
                        pass

                # Add newly assigned numbers to used set
                used_numbers.update(newly_assigned_numbers)

                # Also check existing files in repository (in case registry is out of sync)
                for f in os.listdir(repo_dir):
                    match = re.match(r'^[oO](\d+)', f)
                    if match:
                        used_numbers.add(int(match.group(1)))

                # Find first available number in range
                for num in range(range_start, range_end + 1):
                    if num not in used_numbers:
                        newly_assigned_numbers.add(num)
                        return f"o{num}"

                return None  # No available numbers

            for prog_num, file_path, current_base, expected_base, title in mismatches:
                old_dir = os.path.dirname(file_path)
                new_filename = f"{expected_base}.nc"
                new_file_path = os.path.join(old_dir, new_filename)

                # Check if target file already exists or program number is taken
                file_collision = os.path.exists(new_file_path) and new_file_path.lower() != file_path.lower()

                cursor.execute("""
                    SELECT program_number FROM programs
                    WHERE program_number = ? AND program_number != ?
                """, (expected_base, prog_num))
                db_collision = cursor.fetchone() is not None

                # Also check if we've already decided to use this program number for another file
                already_assigned = expected_base.lower() in target_program_numbers

                if file_collision or db_collision or already_assigned:
                    # Collision! Need to assign a new program number
                    # Get round size from the file to determine correct range
                    round_size = None
                    try:
                        # Parse the file to get round size
                        parse_result = self.parser.parse_file(file_path)
                        round_size = parse_result.outer_diameter
                    except:
                        pass

                    # Find next available number in the correct range
                    new_prog_num = find_next_available_number(round_size, cursor, old_dir)

                    if new_prog_num:
                        new_filename = f"{new_prog_num}.nc"
                        new_file_path = os.path.join(old_dir, new_filename)
                        reassigned_files.append((current_base, expected_base, new_prog_num, round_size))
                        resolved_mismatches.append((prog_num, file_path, current_base, new_prog_num, title))
                        # Track this program number as used
                        target_program_numbers.add(new_prog_num.lower())
                    else:
                        # No available numbers - skip this file
                        progress_text.insert(tk.END, f"WARNING: No available numbers for {current_base}.nc\n")
                        continue
                else:
                    # No collision - use the internal program number
                    resolved_mismatches.append((prog_num, file_path, current_base, expected_base, title))
                    # Track this program number as used
                    target_program_numbers.add(expected_base.lower())

            # Use resolved_mismatches for the rest of the operation
            mismatches = resolved_mismatches

            progress_text.insert(tk.END, f"Found {len(mismatches)} filename mismatches to process\n")
            if reassigned_files:
                progress_text.insert(tk.END, f"  - {len(reassigned_files)} files reassigned to new numbers (duplicates)\n")
            progress_text.insert(tk.END, "\n")

            if reassigned_files:
                progress_text.insert(tk.END, "="*80 + "\n")
                progress_text.insert(tk.END, "DUPLICATE FILES - ASSIGNED NEW PROGRAM NUMBERS\n")
                progress_text.insert(tk.END, "="*80 + "\n\n")
                for current, original_internal, new_num, round_size in reassigned_files:
                    progress_text.insert(tk.END, f"File: {current}.nc\n")
                    progress_text.insert(tk.END, f"  Original internal #: {original_internal} (already in use)\n")
                    progress_text.insert(tk.END, f"  New program #: {new_num}")
                    if round_size:
                        progress_text.insert(tk.END, f" ({round_size}\" range)\n")
                    else:
                        progress_text.insert(tk.END, "\n")
                    progress_text.insert(tk.END, "\n")

            if not mismatches:
                progress_text.insert(tk.END, "\n✓ No files to rename.\n")
                progress_text.see(tk.END)

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            progress_text.insert(tk.END, "="*80 + "\n")
            progress_text.insert(tk.END, "FILES TO RENAME\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")

            # Show preview
            for prog_num, file_path, current_base, expected_base, title in mismatches[:50]:
                progress_text.insert(tk.END, f"File: {current_base}.nc\n")
                progress_text.insert(tk.END, f"  Internal program #: {expected_base}\n")
                progress_text.insert(tk.END, f"  Will rename to:     {expected_base}.nc\n")
                progress_text.insert(tk.END, f"  Database will be updated: {prog_num} → {expected_base}\n")
                if title:
                    progress_text.insert(tk.END, f"  Title: {title}\n")
                progress_text.insert(tk.END, "\n")

            if len(mismatches) > 50:
                progress_text.insert(tk.END, f"... and {len(mismatches) - 50} more\n\n")

            progress_text.insert(tk.END, "="*80 + "\n")
            progress_text.insert(tk.END, "Click 'Confirm Rename' to rename files or 'Cancel' to abort.\n")
            progress_text.see(tk.END)

            def confirm_rename():
                progress_text.insert(tk.END, "\n" + "="*80 + "\n")
                progress_text.insert(tk.END, "STARTING FILENAME SYNC...\n")
                progress_text.insert(tk.END, "="*80 + "\n\n")
                progress_text.see(tk.END)

                renamed_count = 0
                error_count = 0

                # Build a set of reassigned program numbers (duplicates that got new numbers)
                reassigned_prog_nums = set(new_num for _, _, new_num, _ in reassigned_files)

                # PHASE 1: Rename all files to temporary names (to handle swaps)
                progress_text.insert(tk.END, "PHASE 1: Moving files to temporary names...\n\n")
                temp_mappings = []  # (prog_num, temp_path, final_path, old_path, rename_type, is_reassigned)

                for prog_num, old_file_path, current_base, expected_base, title in mismatches:
                    try:
                        progress_text.insert(tk.END, f"Processing: {current_base}.nc\n")

                        # Check if this file was reassigned a new number
                        is_reassigned = expected_base in reassigned_prog_nums

                        # Generate paths
                        old_dir = os.path.dirname(old_file_path)
                        new_filename = f"{expected_base}.nc"
                        new_file_path = os.path.join(old_dir, new_filename)

                        # Check if this is just a case change (Windows is case-insensitive)
                        if old_file_path.lower() == new_file_path.lower():
                            # Case-only change - handle in phase 2
                            temp_mappings.append((prog_num, old_file_path, new_file_path, old_file_path, 'case-change', is_reassigned))
                            progress_text.insert(tk.END, f"  -> Will handle as case change\n\n")
                            continue

                        # Create temporary name
                        import time
                        temp_filename = f"_SYNC_TEMP_{int(time.time()*1000)}_{expected_base}.nc"
                        temp_file_path = os.path.join(old_dir, temp_filename)

                        # Rename to temporary
                        os.rename(old_file_path, temp_file_path)
                        temp_mappings.append((prog_num, temp_file_path, new_file_path, old_file_path, 'normal', is_reassigned))
                        progress_text.insert(tk.END, f"  ✓ Moved to temporary location\n\n")

                        if len(temp_mappings) % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR in phase 1: {e}\n\n")
                        error_count += 1

                # PHASE 2: Rename from temporary to final names
                progress_text.insert(tk.END, "\n" + "="*80 + "\n")
                progress_text.insert(tk.END, "PHASE 2: Moving files to final names...\n\n")
                progress_text.see(tk.END)

                for prog_num, temp_path, final_path, old_path, rename_type, is_reassigned in temp_mappings:
                    try:
                        final_base = os.path.splitext(os.path.basename(final_path))[0]
                        progress_text.insert(tk.END, f"Finalizing: {final_base}.nc\n")

                        if rename_type == 'case-change':
                            # Case-only change
                            temp_name = os.path.join(os.path.dirname(temp_path), f"temp_{os.path.basename(temp_path)}")
                            os.rename(temp_path, temp_name)
                            os.rename(temp_name, final_path)
                            progress_text.insert(tk.END, f"  ✓ File renamed (case change)\n")
                        else:
                            # Normal rename from temp to final
                            os.rename(temp_path, final_path)
                            progress_text.insert(tk.END, f"  ✓ File renamed\n")

                        # If this file was reassigned a new program number (duplicate),
                        # update the internal program number in the G-code file
                        if is_reassigned:
                            try:
                                with open(final_path, 'r', encoding='utf-8', errors='ignore') as f:
                                    content = f.read()

                                # Replace O-number in the file (first occurrence)
                                new_o_number = final_base.upper().replace('O', 'O')  # Ensure uppercase O
                                new_num = final_base.replace('o', '').replace('O', '')

                                # Find and replace the O-number line
                                lines = content.split('\n')
                                for i, line in enumerate(lines):
                                    if re.match(r'^[oO]\d{4,}', line.strip()):
                                        # Replace just the O-number, keep the rest of the line (title etc)
                                        lines[i] = re.sub(r'^[oO]\d{4,}', f'O{new_num}', line)
                                        break

                                with open(final_path, 'w', encoding='utf-8') as f:
                                    f.write('\n'.join(lines))

                                progress_text.insert(tk.END, f"  ✓ Internal program # updated to O{new_num}\n")
                            except Exception as e:
                                progress_text.insert(tk.END, f"  ⚠ Could not update internal #: {e}\n")

                        # Update database - FIRST update file_path so we can always find the file
                        # Then update program_number separately
                        new_program_number = final_base

                        # Step 1: Update file_path immediately (critical - so we can find the file)
                        cursor.execute("""
                            UPDATE programs
                            SET file_path = ?
                            WHERE program_number = ?
                        """, (final_path, prog_num))
                        conn.commit()  # Commit file_path change immediately

                        # Step 2: Try to update program_number (may fail if duplicate)
                        try:
                            if prog_num != new_program_number:
                                cursor.execute("""
                                    UPDATE programs
                                    SET program_number = ?
                                    WHERE program_number = ?
                                """, (new_program_number, prog_num))
                        except sqlite3.IntegrityError:
                            # Program number already exists - delete this duplicate entry
                            # The file was already renamed, so just remove this orphan record
                            cursor.execute("DELETE FROM programs WHERE program_number = ?", (prog_num,))
                            progress_text.insert(tk.END, f"  ⚠ Removed duplicate record (merged with existing {new_program_number})\n")
                        progress_text.insert(tk.END, f"  ✓ Database updated (program_number: {prog_num} → {new_program_number})\n")

                        # Update registry: mark old number as AVAILABLE, new number as IN_USE
                        if prog_num != new_program_number:
                            cursor.execute("""
                                UPDATE program_number_registry
                                SET status = 'AVAILABLE', file_path = NULL
                                WHERE program_number = ?
                            """, (prog_num,))

                            cursor.execute("""
                                UPDATE program_number_registry
                                SET status = 'IN_USE', file_path = ?
                                WHERE program_number = ?
                            """, (final_path, new_program_number))
                            progress_text.insert(tk.END, f"  ✓ Registry updated (freed {prog_num}, assigned {new_program_number})\n")
                        else:
                            # Same program number, just update file path
                            cursor.execute("""
                                UPDATE program_number_registry
                                SET file_path = ?
                                WHERE program_number = ?
                            """, (final_path, prog_num))
                            progress_text.insert(tk.END, f"  ✓ Registry updated\n")

                        # Clear FILENAME MISMATCH warning (keep other issues)
                        # Note: We must use new_program_number since we already updated it
                        cursor.execute("""
                            SELECT validation_issues, validation_status
                            FROM programs
                            WHERE program_number = ?
                        """, (new_program_number,))
                        val_result = cursor.fetchone()

                        if val_result and val_result[0] and 'FILENAME MISMATCH' in val_result[0]:
                            old_issues = val_result[0]
                            # Remove FILENAME MISMATCH portion
                            # Handle both JSON arrays and pipe-separated strings
                            import json
                            issues_list = []

                            # Try parsing as JSON first
                            try:
                                if isinstance(old_issues, str) and old_issues.strip().startswith('['):
                                    issues_list = json.loads(old_issues)
                                else:
                                    # Fall back to pipe-separated
                                    issues_list = [issue.strip() for issue in old_issues.split('|')]
                            except:
                                # Fall back to pipe-separated
                                issues_list = [issue.strip() for issue in old_issues.split('|')]

                            # Keep only non-filename-mismatch issues
                            remaining_issues = [i for i in issues_list if not str(i).startswith('FILENAME MISMATCH')]

                            if remaining_issues:
                                # Keep other issues, just remove filename mismatch
                                # Store back as JSON if original was JSON
                                if isinstance(old_issues, str) and old_issues.strip().startswith('['):
                                    new_issues = json.dumps(remaining_issues)
                                else:
                                    new_issues = '|'.join(remaining_issues)
                                new_status = 'CRITICAL' if any('CRITICAL' in str(i) for i in remaining_issues) else 'WARN'
                                cursor.execute("""
                                    UPDATE programs
                                    SET validation_issues = ?,
                                        validation_status = ?
                                    WHERE program_number = ?
                                """, (new_issues, new_status, new_program_number))
                                progress_text.insert(tk.END, f"  ✓ Filename mismatch cleared (other issues remain)\n")
                            else:
                                # No other issues - clear everything
                                cursor.execute("""
                                    UPDATE programs
                                    SET validation_status = NULL,
                                        validation_issues = NULL,
                                        validation_warnings = NULL
                                    WHERE program_number = ?
                                """, (new_program_number,))
                                progress_text.insert(tk.END, f"  ✓ All validation errors cleared\n")
                        else:
                            progress_text.insert(tk.END, f"  ✓ No validation errors to clear\n")

                        progress_text.insert(tk.END, f"  ✅ Complete\n\n")
                        renamed_count += 1

                        if renamed_count % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR in phase 2: {e}\n\n")
                        error_count += 1

                conn.commit()

                progress_text.insert(tk.END, "="*80 + "\n")
                progress_text.insert(tk.END, "COMPLETE\n")
                progress_text.insert(tk.END, "="*80 + "\n\n")
                progress_text.insert(tk.END, f"Successfully renamed: {renamed_count} files\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count} files\n")
                progress_text.see(tk.END)

                # Log activity
                self.log_activity('sync_filenames', 'batch', {
                    'renamed_count': renamed_count,
                    'error_count': error_count
                })

                # Refresh the view
                self.refresh_results()

                # Close database connection
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_rename():
                conn.close()
                progress_window.destroy()

            # Button frame
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Confirm Rename", command=confirm_rename,
                     bg="#7B1FA2", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_rename,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=18, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            # Close connection if it exists
            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def export_repository_by_round_size(self):
        """Export repository files organized by round size folders"""

        # Ask user to select export destination
        export_root = filedialog.askdirectory(
            title="Select Export Destination Folder",
            initialdir=os.path.expanduser("~")
        )

        if not export_root:
            return  # User cancelled

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Export Repository by Round Size")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)

        tk.Label(progress_window, text="📦 Export Repository by Round Size",
                font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Progress text
        text_frame = tk.Frame(progress_window, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        progress_text = tk.Text(text_frame, bg=self.input_bg, fg=self.fg_color,
                               font=("Consolas", 9), wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, command=progress_text.yview)
        progress_text.configure(yscrollcommand=scrollbar.set)

        progress_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            progress_text.insert(tk.END, f"Export Destination: {export_root}\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Define standard round size folders
            # Map detected sizes to standard folder names
            standard_folders = {
                # Exact matches
                5.75: "5.75",
                6.0: "6.0",
                6.25: "6.25",
                6.5: "6.5",
                7.0: "7.0",
                7.5: "7.5",
                8.0: "8.0",
                8.5: "8.5",
                9.5: "9.5",
                10.25: "10.25",
                10.5: "10.5",
                13.0: "13.0",
            }

            # Function to map any round size to nearest standard folder
            def get_folder_for_round_size(round_size):
                if not round_size:
                    return "NO_ROUND_SIZE"

                # Check for exact match
                if round_size in standard_folders:
                    return standard_folders[round_size]

                # Find nearest standard size
                nearest = min(standard_folders.keys(), key=lambda x: abs(x - round_size))
                return standard_folders[nearest]

            # Get repository path
            repo_path = self.repository_path
            if not repo_path:
                progress_text.insert(tk.END, "ERROR: No repository path configured\n")
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            # Get ALL repository files:
            # - In repository folder
            # - Has file_path set
            # - Any extension (or no extension)
            # - Include files with or without round size
            cursor.execute("""
                SELECT program_number, file_path, round_size, title
                FROM programs
                WHERE is_managed = 1
                  AND file_path IS NOT NULL
                  AND file_path LIKE ?
                ORDER BY round_size, program_number
            """, (f"{repo_path}%",))

            all_files = cursor.fetchall()

            if not all_files:
                progress_text.insert(tk.END, "No repository files found to export.\n")
                progress_text.see(tk.END)
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            # Filter to only files that actually exist
            verified_files = []
            skipped_count = 0
            for prog_num, file_path, round_size, title in all_files:
                if file_path and os.path.exists(file_path):
                    verified_files.append((prog_num, file_path, round_size, title))
                else:
                    skipped_count += 1

            all_files = verified_files

            if not all_files:
                progress_text.insert(tk.END, "No files found that actually exist.\n")
                progress_text.insert(tk.END, f"(Skipped {skipped_count} database entries with missing files)\n")
                progress_text.see(tk.END)
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            progress_text.insert(tk.END, f"Found {len(all_files)} repository files to export\n")
            if skipped_count > 0:
                progress_text.insert(tk.END, f"(Skipped {skipped_count} entries with missing files)\n")
            progress_text.insert(tk.END, "\nExporting ALL files from repository:\n")
            progress_text.insert(tk.END, "  ✓ All extensions (.nc, .txt, no extension)\n")
            progress_text.insert(tk.END, "  ✓ Organized by round size\n")
            progress_text.insert(tk.END, "  ✓ Only files that actually exist\n\n")
            progress_text.insert(tk.END, "Organizing files by round size...\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Group files by folder
            files_by_folder = {}
            for prog_num, file_path, round_size, title in all_files:
                folder_name = get_folder_for_round_size(round_size)

                if folder_name not in files_by_folder:
                    files_by_folder[folder_name] = []

                files_by_folder[folder_name].append((prog_num, file_path, round_size, title))

            # Show organization summary
            progress_text.insert(tk.END, "EXPORT ORGANIZATION:\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")

            for folder_name in sorted(files_by_folder.keys()):
                file_count = len(files_by_folder[folder_name])
                progress_text.insert(tk.END, f"📁 {folder_name}/ ({file_count} files)\n")

            progress_text.insert(tk.END, f"\n{'='*80}\n")
            progress_text.insert(tk.END, f"Total: {len(all_files)} files in {len(files_by_folder)} folders\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Start export
            progress_text.insert(tk.END, "="*80 + "\n")
            progress_text.insert(tk.END, "STARTING EXPORT...\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.see(tk.END)

            exported_count = 0
            error_count = 0
            created_folders = set()

            for folder_name in sorted(files_by_folder.keys()):
                # Create folder
                folder_path = os.path.join(export_root, folder_name)
                if not os.path.exists(folder_path):
                    os.makedirs(folder_path)
                    created_folders.add(folder_name)
                    progress_text.insert(tk.END, f"📁 Created folder: {folder_name}/\n")

                progress_text.insert(tk.END, f"\nExporting to {folder_name}/:\n")

                # Copy files to this folder
                for prog_num, file_path, round_size, title in files_by_folder[folder_name]:
                    try:
                        # Check if file_path is None or empty
                        if not file_path:
                            progress_text.insert(tk.END, f"  ⚠️ SKIP: {prog_num} - No file path in database (run Repair File Paths)\n")
                            error_count += 1
                            continue

                        if not os.path.exists(file_path):
                            progress_text.insert(tk.END, f"  ⚠️ SKIP: {prog_num} - File not found: {file_path}\n")
                            error_count += 1
                            continue

                        # Copy file
                        filename = os.path.basename(file_path)
                        dest_path = os.path.join(folder_path, filename)

                        import shutil
                        shutil.copy2(file_path, dest_path)

                        progress_text.insert(tk.END, f"  ✓ {prog_num} - {filename}\n")
                        exported_count += 1

                        if exported_count % 50 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        progress_text.insert(tk.END, f"  ✗ ERROR copying {prog_num}: {e}\n")
                        error_count += 1

                progress_text.see(tk.END)
                self.root.update()

            # Summary
            progress_text.insert(tk.END, f"\n{'='*80}\n")
            progress_text.insert(tk.END, "EXPORT COMPLETE\n")
            progress_text.insert(tk.END, "="*80 + "\n\n")
            progress_text.insert(tk.END, f"Export Location: {export_root}\n\n")
            progress_text.insert(tk.END, f"Folders Created: {len(created_folders)}\n")
            progress_text.insert(tk.END, f"Files Exported: {exported_count}\n")
            if error_count > 0:
                progress_text.insert(tk.END, f"Errors: {error_count}\n")
            progress_text.insert(tk.END, f"\nTotal Size: {len(files_by_folder)} folders, {exported_count} files\n")
            progress_text.see(tk.END)

            # Log activity
            self.log_activity('export_repository', 'export', {
                'export_root': export_root,
                'folders_created': len(created_folders),
                'files_exported': exported_count,
                'error_count': error_count
            })

            conn.close()

            # Show completion message
            messagebox.showinfo(
                "Export Complete",
                f"Repository exported successfully!\n\n"
                f"Location: {export_root}\n"
                f"Folders: {len(created_folders)}\n"
                f"Files: {exported_count}\n"
                f"Errors: {error_count}"
            )

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

        except Exception as e:
            progress_text.insert(tk.END, f"\n\nERROR: {e}\n")
            import traceback
            progress_text.insert(tk.END, traceback.format_exc())
            progress_text.see(tk.END)

            # Close connection if it exists
            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def fix_program_number_formatting(self):
        """Fix program numbers that are missing leading zeros (e.g., o1000 -> o01000)"""

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Fix Program Number Formatting")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)

        # Title
        title_label = tk.Label(progress_window,
                              text="🔢 Fix Program Number Formatting",
                              font=("Arial", 14, "bold"),
                              bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=10)

        # Info
        info_label = tk.Label(progress_window,
                             text="This will add leading zeros to program numbers (o1000 → o01000).\n"
                                  "All program numbers should be in the format o##### (5 digits).",
                             font=("Arial", 10),
                             bg=self.bg_color, fg=self.fg_color,
                             justify=tk.LEFT)
        info_label.pack(pady=5, padx=20, anchor=tk.W)

        # Scrolled text for output
        output_frame = tk.Frame(progress_window, bg=self.bg_color)
        output_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        output_text = scrolledtext.ScrolledText(output_frame,
                                                wrap=tk.WORD,
                                                width=100, height=35,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True)

        progress_window.update()

        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "SCANNING FOR INCORRECTLY FORMATTED PROGRAM NUMBERS\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            # Find all programs with incorrect format (missing leading zeros)
            cursor.execute("""
                SELECT program_number, file_path, title
                FROM programs
                WHERE LENGTH(program_number) < 6
                ORDER BY CAST(REPLACE(program_number, 'o', '') AS INTEGER)
            """)

            incorrect_programs = cursor.fetchall()
            output_text.insert(tk.END, f"Found {len(incorrect_programs)} programs with incorrect formatting\n\n")

            if not incorrect_programs:
                output_text.insert(tk.END, "✅ All program numbers are correctly formatted!\n")
                conn.close()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "FIX PREVIEW\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            fixes = []
            for old_num, file_path, title in incorrect_programs[:50]:  # Show first 50
                new_num = self.format_program_number(old_num)

                output_text.insert(tk.END, f"Program: {old_num} → {new_num}\n")
                output_text.insert(tk.END, f"  Title: {title}\n")
                output_text.insert(tk.END, f"  File: {os.path.basename(file_path) if file_path else 'None'}\n\n")

                fixes.append((old_num, new_num, file_path, title))
                progress_window.update()

            if len(incorrect_programs) > 50:
                output_text.insert(tk.END, f"... and {len(incorrect_programs) - 50} more programs\n\n")

            # Include all programs for fixing, not just the displayed ones
            for old_num, file_path, title in incorrect_programs[50:]:
                new_num = self.format_program_number(old_num)
                fixes.append((old_num, new_num, file_path, title))

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, f"Total programs to fix: {len(fixes)}\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            # Ask user to confirm
            def apply_fixes():
                output_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                output_text.insert(tk.END, "APPLYING FIXES\n")
                output_text.insert(tk.END, "=" * 80 + "\n\n")

                fixed_count = 0
                error_count = 0

                for old_num, new_num, file_path, title in fixes:
                    try:
                        # Check if new number already exists
                        cursor.execute("SELECT COUNT(*) FROM programs WHERE program_number = ?", (new_num,))
                        if cursor.fetchone()[0] > 0 and new_num != old_num:
                            output_text.insert(tk.END, f"⚠️ SKIP: {old_num} → {new_num} (target already exists)\n")
                            error_count += 1
                            continue

                        # Rename file if it exists
                        if file_path and os.path.exists(file_path):
                            old_dir = os.path.dirname(file_path)
                            new_filename = f"{new_num}.nc"
                            new_file_path = os.path.join(old_dir, new_filename)

                            # Only rename if filenames are different
                            if file_path != new_file_path:
                                os.rename(file_path, new_file_path)
                                file_path = new_file_path

                        # Update programs table
                        cursor.execute("""
                            UPDATE programs
                            SET program_number = ?, file_path = ?
                            WHERE program_number = ?
                        """, (new_num, file_path, old_num))

                        # Update registry table
                        cursor.execute("""
                            UPDATE program_number_registry
                            SET program_number = ?, file_path = ?
                            WHERE program_number = ?
                        """, (new_num, file_path, old_num))

                        conn.commit()
                        fixed_count += 1
                        output_text.insert(tk.END, f"✓ Fixed: {old_num} → {new_num}\n")
                    except Exception as e:
                        error_count += 1
                        output_text.insert(tk.END, f"❌ Error fixing {old_num}: {e}\n")

                    progress_window.update()

                output_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                output_text.insert(tk.END, "FIX COMPLETE\n")
                output_text.insert(tk.END, "=" * 80 + "\n\n")
                output_text.insert(tk.END, f"✅ Fixed: {fixed_count}\n")
                output_text.insert(tk.END, f"❌ Errors: {error_count}\n")
                output_text.insert(tk.END, "\nAll program numbers now have proper leading zeros!\n")

                confirm_btn.pack_forget()
                cancel_btn.pack_forget()

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_fix():
                conn.close()
                progress_window.destroy()

            # Buttons
            button_frame = tk.Frame(progress_window, bg=self.bg_color)
            button_frame.pack(pady=10)

            confirm_btn = tk.Button(button_frame, text="✓ Apply Fixes",
                                    command=apply_fixes,
                                    bg="#4CAF50", fg="white", font=("Arial", 11, "bold"),
                                    width=15)
            confirm_btn.pack(side=tk.LEFT, padx=5)

            cancel_btn = tk.Button(button_frame, text="✗ Cancel",
                                   command=cancel_fix,
                                   bg="#f44336", fg="white", font=("Arial", 11, "bold"),
                                   width=15)
            cancel_btn.pack(side=tk.LEFT, padx=5)

        except Exception as e:
            if 'output_text' in locals():
                output_text.insert(tk.END, f"\n❌ ERROR: {str(e)}\n")
                import traceback
                output_text.insert(tk.END, f"\n{traceback.format_exc()}\n")

            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def move_to_correct_range(self):
        """
        Move programs to their correct range based on round size.

        This function prioritizes using proper round size ranges before free ranges.
        It finds and moves two types of programs:
        1. Programs outside their correct range (e.g., o01010 with 7.0" → o70000-o79999)
        2. Programs in free ranges (1000-9999, 14000-49999) that have real round sizes
           and can be consolidated into their proper round size ranges

        This ensures proper round size ranges are filled before using overflow free ranges.
        """
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Create progress window
            progress_window = tk.Toplevel(self.root)
            progress_window.title("Move to Correct Range")
            progress_window.geometry("1000x700")
            progress_window.configure(bg=self.bg_color)
            progress_window.transient(self.root)

            tk.Label(progress_window, text="🎯 Move Programs to Correct Range",
                    font=("Arial", 14, "bold"), bg=self.bg_color, fg=self.fg_color).pack(pady=10)

            # Progress text
            text_frame = tk.Frame(progress_window, bg=self.bg_color)
            text_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

            progress_text = scrolledtext.ScrolledText(text_frame, bg=self.input_bg, fg=self.fg_color,
                                                     font=("Consolas", 9), wrap=tk.WORD)
            progress_text.pack(fill=tk.BOTH, expand=True)

            progress_text.insert(tk.END, "=" * 80 + "\n")
            progress_text.insert(tk.END, "SCANNING FOR PROGRAMS TO MOVE\n")
            progress_text.insert(tk.END, "=" * 80 + "\n")
            progress_text.insert(tk.END, "Looking for:\n")
            progress_text.insert(tk.END, "  1. Programs outside their correct round size range\n")
            progress_text.insert(tk.END, "  2. Programs in free ranges that can move to proper ranges\n")
            progress_text.insert(tk.END, "=" * 80 + "\n\n")
            progress_text.see(tk.END)
            self.root.update()

            # Get programs that need to be moved
            # A program is in wrong range if:
            # 1. It has a round_size OR outer_diameter (OD column in GUI)
            # 2. Its program number doesn't match the range for that round size

            cursor.execute("""
                SELECT program_number, file_path, round_size, outer_diameter, title
                FROM programs
                WHERE is_managed = 1
                  AND file_path IS NOT NULL
                  AND (round_size IS NOT NULL OR outer_diameter IS NOT NULL)
                ORDER BY COALESCE(round_size, outer_diameter), program_number
            """)

            all_programs = cursor.fetchall()

            needs_move = []

            # Define free ranges
            FREE_RANGE_1 = (1000, 9999)    # round_size 0.0
            FREE_RANGE_2 = (14000, 49999)  # round_size -1.0

            for prog_num, file_path, round_size, outer_diameter, title in all_programs:
                # Use round_size if available, otherwise use outer_diameter (OD column)
                effective_round_size = round_size if round_size is not None else outer_diameter

                if effective_round_size is None:
                    continue  # Skip if both are NULL

                # Determine correct range for this round size
                correct_range = self.get_range_for_round_size(effective_round_size)

                if not correct_range:
                    continue  # Unknown round size

                range_start, range_end = correct_range

                # Extract number from program number
                num_str = prog_num.replace('o', '').replace('O', '')
                try:
                    prog_int = int(num_str)
                except:
                    continue

                # Check if program needs to be moved:
                # 1. Program is outside its correct range (wrong range)
                # 2. Program is in a free range BUT has a real round size (not 0.0 or -1.0)
                #    This prioritizes using proper round size ranges before free ranges

                in_free_range_1 = (FREE_RANGE_1[0] <= prog_int <= FREE_RANGE_1[1])
                in_free_range_2 = (FREE_RANGE_2[0] <= prog_int <= FREE_RANGE_2[1])
                in_any_free_range = in_free_range_1 or in_free_range_2

                # Has a real round size (not free range sizes 0.0 or -1.0)
                has_real_round_size = effective_round_size not in (0.0, -1.0)

                # Check if outside correct range
                outside_correct_range = (prog_int < range_start or prog_int > range_end)

                # Move if: outside range OR (in free range AND has real round size)
                if outside_correct_range or (in_any_free_range and has_real_round_size):
                    needs_move.append((prog_num, file_path, effective_round_size, title, range_start, range_end))

            progress_text.insert(tk.END, f"Found {len(needs_move)} programs to move\n\n")

            if not needs_move:
                progress_text.insert(tk.END, "✓ All programs are already in correct ranges!\n")
                progress_text.insert(tk.END, "✓ No programs in free ranges need consolidation!\n")
                progress_text.see(tk.END)
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                conn.close()
                return

            progress_text.insert(tk.END, "=" * 80 + "\n")
            progress_text.insert(tk.END, "PREVIEW - Programs to Move\n")
            progress_text.insert(tk.END, "=" * 80 + "\n\n")

            # Define free ranges for status reporting
            FREE_RANGE_1 = (1000, 9999)
            FREE_RANGE_2 = (14000, 49999)

            # Show preview (first 50)
            for prog_num, file_path, round_size, title, range_start, range_end in needs_move[:50]:
                num_str = prog_num.replace('o', '').replace('O', '')
                prog_int = int(num_str)

                # Determine reason for move
                in_free_range_1 = (FREE_RANGE_1[0] <= prog_int <= FREE_RANGE_1[1])
                in_free_range_2 = (FREE_RANGE_2[0] <= prog_int <= FREE_RANGE_2[1])

                if in_free_range_1:
                    reason = "📦 Currently in Free Range 1 (o1000-o9999)"
                elif in_free_range_2:
                    reason = "📦 Currently in Free Range 2 (o14000-o49999)"
                else:
                    reason = "⚠️ Currently in wrong range"

                progress_text.insert(tk.END, f"Program: {prog_num}\n")
                progress_text.insert(tk.END, f"  {reason}\n")
                progress_text.insert(tk.END, f"  Round size: {round_size}\"\n")
                progress_text.insert(tk.END, f"  Correct range: o{range_start:05d} - o{range_end:05d}\n")
                progress_text.insert(tk.END, f"  Title: {title[:50] if title else '(no title)'}\n")
                progress_text.insert(tk.END, f"  → Will move to first available in correct range\n\n")

            if len(needs_move) > 50:
                progress_text.insert(tk.END, f"... and {len(needs_move) - 50} more programs\n\n")

            progress_text.insert(tk.END, "=" * 80 + "\n")
            progress_text.insert(tk.END, f"Total: {len(needs_move)} programs will be moved\n")
            progress_text.insert(tk.END, "=" * 80 + "\n")
            progress_text.see(tk.END)

            def apply_move():
                progress_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                progress_text.insert(tk.END, "MOVING PROGRAMS\n")
                progress_text.insert(tk.END, "=" * 80 + "\n\n")
                progress_text.see(tk.END)
                self.root.update()

                moved_count = 0
                error_count = 0
                assigned_numbers = set()

                for prog_num, file_path, round_size, title, range_start, range_end in needs_move:
                    try:
                        # Find next available number in correct range
                        new_number = self.find_next_available_number_in_range(
                            range_start, range_end, assigned_numbers
                        )

                        if not new_number:
                            progress_text.insert(tk.END, f"✗ {prog_num}: No available numbers in range\n")
                            error_count += 1
                            continue

                        assigned_numbers.add(new_number)

                        # Check if file exists
                        if not os.path.exists(file_path):
                            progress_text.insert(tk.END, f"✗ {prog_num}: File not found\n")
                            error_count += 1
                            continue

                        # Read file content
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        # Update internal O-number in file
                        old_num_plain = prog_num.replace('o', '').replace('O', '')
                        new_num_plain = new_number.replace('o', '').replace('O', '')

                        # Update O-number at start of line
                        updated_content = re.sub(
                            rf'^[oO]{old_num_plain}\b',
                            new_number.upper(),
                            content,
                            flags=re.MULTILINE
                        )

                        # Update O-number in comments
                        updated_content = re.sub(
                            rf'\b[oO]{old_num_plain}\b',
                            new_number.upper(),
                            updated_content
                        )

                        # Add legacy comment
                        from datetime import datetime
                        today = datetime.now().strftime("%Y-%m-%d")
                        legacy_comment = f"(MOVED FROM {prog_num.upper()} ON {today} - RANGE CORRECTION)\n"

                        # Insert after first O-number line
                        lines = updated_content.split('\n')
                        for i, line in enumerate(lines):
                            if re.match(rf'^[oO]{new_num_plain}\b', line):
                                lines.insert(i + 1, legacy_comment)
                                break
                        updated_content = '\n'.join(lines)

                        # Create new file path
                        old_dir = os.path.dirname(file_path)
                        new_file_path = os.path.join(old_dir, f"{new_number}.nc")

                        # Write to new file
                        with open(new_file_path, 'w', encoding='utf-8') as f:
                            f.write(updated_content)

                        # Delete old file
                        if os.path.exists(file_path) and file_path != new_file_path:
                            os.remove(file_path)

                        # Update database
                        cursor.execute("""
                            UPDATE programs
                            SET program_number = ?, file_path = ?
                            WHERE program_number = ?
                        """, (new_number, new_file_path, prog_num))

                        # Update registry - mark old as AVAILABLE
                        cursor.execute("""
                            UPDATE program_number_registry
                            SET status = 'AVAILABLE', file_path = NULL
                            WHERE program_number = ?
                        """, (prog_num,))

                        # Update registry - mark new as IN_USE
                        cursor.execute("""
                            UPDATE program_number_registry
                            SET status = 'IN_USE', file_path = ?
                            WHERE program_number = ?
                        """, (new_file_path, new_number))

                        conn.commit()
                        moved_count += 1

                        progress_text.insert(tk.END, f"✓ {prog_num} → {new_number} (Round {round_size}\")\n")

                        if moved_count % 10 == 0:
                            progress_text.see(tk.END)
                            self.root.update()

                    except Exception as e:
                        error_count += 1
                        progress_text.insert(tk.END, f"✗ Error moving {prog_num}: {e}\n")

                progress_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                progress_text.insert(tk.END, "COMPLETE\n")
                progress_text.insert(tk.END, "=" * 80 + "\n\n")
                progress_text.insert(tk.END, f"Successfully moved: {moved_count} programs\n")
                if error_count > 0:
                    progress_text.insert(tk.END, f"Errors: {error_count}\n")
                progress_text.see(tk.END)

                # Refresh the view
                self.refresh_results()

                # Close database
                conn.close()

                # Update button
                btn_frame.pack_forget()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_move():
                conn.close()
                progress_window.destroy()

            # Buttons
            btn_frame = tk.Frame(progress_window, bg=self.bg_color)
            btn_frame.pack(pady=10)

            tk.Button(btn_frame, text="✓ Move Programs", command=apply_move,
                     bg="#E91E63", fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=20, height=2).pack(side=tk.LEFT, padx=10)

            tk.Button(btn_frame, text="✗ Cancel", command=cancel_move,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                     width=20, height=2).pack(side=tk.LEFT, padx=10)

        except Exception as e:
            messagebox.showerror("Error", f"Failed to scan programs: {str(e)}")
            import traceback
            traceback.print_exc()

    def find_next_available_number_in_range(self, range_start, range_end, assigned_numbers):
        """Find next available program number in specified range"""
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        for num in range(range_start, range_end + 1):
            prog_num = self.format_program_number(num)

            if prog_num in assigned_numbers:
                continue

            # Check registry
            cursor.execute("""
                SELECT status FROM program_number_registry
                WHERE program_number = ?
            """, (prog_num,))

            result = cursor.fetchone()
            if result and result[0] == 'AVAILABLE':
                conn.close()
                return prog_num

        conn.close()
        return None  # No available numbers found

    def repair_file_paths(self):
        """Repair database file_path entries by scanning repository folder and matching files"""

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Repair File Paths")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)

        # Title
        title_label = tk.Label(progress_window,
                              text="🔧 Repair Database File Paths",
                              font=("Arial", 14, "bold"),
                              bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=10)

        # Info
        info_label = tk.Label(progress_window,
                             text="This will scan the repository folder and fix file_path entries in the database.\n"
                                  "It matches files on disk to their database entries and updates incorrect paths.",
                             font=("Arial", 10),
                             bg=self.bg_color, fg=self.fg_color,
                             justify=tk.LEFT)
        info_label.pack(pady=5, padx=20, anchor=tk.W)

        # Scrolled text for output
        output_frame = tk.Frame(progress_window, bg=self.bg_color)
        output_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        output_text = scrolledtext.ScrolledText(output_frame,
                                                wrap=tk.WORD,
                                                width=100, height=35,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True)

        progress_window.update()

        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "SCANNING REPOSITORY FOLDER\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            # Get repository path from class instance
            repo_path = self.repository_path
            if not repo_path:
                output_text.insert(tk.END, "❌ ERROR: No repository path configured\n")
                conn.close()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            output_text.insert(tk.END, f"Repository Path: {repo_path}\n\n")

            if not os.path.exists(repo_path):
                output_text.insert(tk.END, f"❌ ERROR: Repository path does not exist\n")
                conn.close()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            # Scan repository for all .nc files
            output_text.insert(tk.END, "Scanning for .nc files...\n")
            progress_window.update()

            nc_files = {}  # program_number -> full_path
            for root, dirs, files in os.walk(repo_path):
                for filename in files:
                    if filename.lower().endswith('.nc'):
                        full_path = os.path.join(root, filename)
                        base_name = os.path.splitext(filename)[0].lower()
                        nc_files[base_name] = full_path

            output_text.insert(tk.END, f"Found {len(nc_files)} .nc files in repository\n\n")
            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "CHECKING DATABASE ENTRIES\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")
            progress_window.update()

            # Get all managed programs
            cursor.execute("""
                SELECT program_number, file_path, title
                FROM programs
                WHERE is_managed = 1
                ORDER BY program_number
            """)

            all_programs = cursor.fetchall()
            output_text.insert(tk.END, f"Found {len(all_programs)} managed programs in database\n\n")

            # Check each program's file_path
            needs_repair = []
            import re
            for prog_num, file_path, title in all_programs:
                # Skip records with None program_number
                if not prog_num:
                    continue
                # Check if file exists at stored path
                if file_path and os.path.exists(file_path):
                    continue  # Path is correct

                # File doesn't exist at stored path - try to find it
                # Strip any suffixes like (1), _1, etc. to get base program number
                # Remove suffix patterns: (1), (2), _1, _2, etc.
                base_prog = re.sub(r'[\(_]\d+[\)]?$', '', prog_num).lower()

                # Try multiple variations
                possible_names = [
                    prog_num.lower(),  # Exact match: o00801(2)
                    base_prog,  # Without suffixes: o00801
                    prog_num.replace('(', '_').replace(')', '').lower(),  # Convert () to _: o00801_2
                ]

                found_path = None
                for name in possible_names:
                    if name in nc_files:
                        found_path = nc_files[name]
                        break

                # Only add to needs_repair if we're actually changing something
                # (Either found a new path, or old path was None/invalid)
                if found_path or not file_path or not os.path.exists(file_path):
                    needs_repair.append((prog_num, file_path, found_path, title))

            output_text.insert(tk.END, f"Found {len(needs_repair)} entries that need repair\n\n")

            if not needs_repair:
                output_text.insert(tk.END, "✅ All file paths are correct! No repairs needed.\n")
                conn.close()
                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)
                return

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "REPAIR PREVIEW\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            fixed_count = 0
            missing_count = 0

            for prog_num, old_path, new_path, title in needs_repair[:50]:  # Show first 50
                output_text.insert(tk.END, f"Program: {prog_num}\n")
                output_text.insert(tk.END, f"  Title: {title}\n")
                output_text.insert(tk.END, f"  Current DB path: {old_path if old_path else '(empty)'}\n")

                if new_path:
                    output_text.insert(tk.END, f"  ✓ Found at: {new_path}\n")
                    fixed_count += 1
                else:
                    output_text.insert(tk.END, f"  ❌ File not found in repository\n")
                    missing_count += 1

                output_text.insert(tk.END, "\n")
                progress_window.update()

            if len(needs_repair) > 50:
                output_text.insert(tk.END, f"... and {len(needs_repair) - 50} more entries\n\n")

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, f"SUMMARY:\n")
            output_text.insert(tk.END, f"  • Can be fixed: {fixed_count}\n")
            output_text.insert(tk.END, f"  • Missing files: {missing_count}\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            # Ask user to confirm
            def apply_repairs():
                output_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                output_text.insert(tk.END, "APPLYING REPAIRS\n")
                output_text.insert(tk.END, "=" * 80 + "\n\n")

                repaired = 0
                failed = 0

                for prog_num, old_path, new_path, title in needs_repair:
                    if new_path:
                        try:
                            # Update programs table
                            cursor.execute("""
                                UPDATE programs
                                SET file_path = ?
                                WHERE program_number = ?
                            """, (new_path, prog_num))

                            # Update registry table
                            cursor.execute("""
                                UPDATE program_number_registry
                                SET file_path = ?
                                WHERE program_number = ?
                            """, (new_path, prog_num))

                            conn.commit()
                            repaired += 1
                            output_text.insert(tk.END, f"✓ Fixed: {prog_num}\n")
                        except Exception as e:
                            failed += 1
                            output_text.insert(tk.END, f"❌ Error fixing {prog_num}: {e}\n")
                    else:
                        # File not found - clear the file_path
                        try:
                            cursor.execute("""
                                UPDATE programs
                                SET file_path = NULL
                                WHERE program_number = ?
                            """, (prog_num,))

                            cursor.execute("""
                                UPDATE program_number_registry
                                SET file_path = NULL
                                WHERE program_number = ?
                            """, (prog_num,))

                            conn.commit()
                            failed += 1
                            output_text.insert(tk.END, f"⚠️ Cleared path for missing file: {prog_num}\n")
                        except Exception as e:
                            failed += 1
                            output_text.insert(tk.END, f"❌ Error clearing {prog_num}: {e}\n")

                    progress_window.update()

                output_text.insert(tk.END, "\n" + "=" * 80 + "\n")
                output_text.insert(tk.END, "REPAIR COMPLETE\n")
                output_text.insert(tk.END, "=" * 80 + "\n\n")
                output_text.insert(tk.END, f"✅ Repaired: {repaired}\n")
                output_text.insert(tk.END, f"⚠️ Missing files: {failed}\n")
                output_text.insert(tk.END, "\nYou can now try batch rename again!\n")

                confirm_btn.pack_forget()
                cancel_btn.pack_forget()

                tk.Button(progress_window, text="Close", command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

            def cancel_repair():
                conn.close()
                progress_window.destroy()

            # Buttons
            button_frame = tk.Frame(progress_window, bg=self.bg_color)
            button_frame.pack(pady=10)

            confirm_btn = tk.Button(button_frame, text="✓ Apply Repairs",
                                    command=apply_repairs,
                                    bg="#4CAF50", fg="white", font=("Arial", 11, "bold"),
                                    width=15)
            confirm_btn.pack(side=tk.LEFT, padx=5)

            cancel_btn = tk.Button(button_frame, text="✗ Cancel",
                                   command=cancel_repair,
                                   bg="#f44336", fg="white", font=("Arial", 11, "bold"),
                                   width=15)
            cancel_btn.pack(side=tk.LEFT, padx=5)

        except Exception as e:
            if 'output_text' in locals():
                output_text.insert(tk.END, f"\n❌ ERROR: {str(e)}\n")
                import traceback
                output_text.insert(tk.END, f"\n{traceback.format_exc()}\n")

            if 'conn' in locals():
                try:
                    conn.close()
                except:
                    pass

            tk.Button(progress_window, text="Close", command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def detect_and_fix_drive_letter(self):
        """
        Detect current Google Drive location and update all file paths.
        Fixes issue where Google Drive gets different drive letters on different computers.
        """
        # Find where the database currently is - this tells us the current drive letter
        current_db_path = os.path.abspath(self.db_path)
        current_drive = os.path.splitdrive(current_db_path)[0]  # e.g., "L:"

        # Find the repository path from current location
        current_repo_path = os.path.dirname(current_db_path)  # Database folder
        current_repo_files = os.path.join(current_repo_path, "repository")  # Repository subfolder

        if not os.path.exists(current_repo_files):
            messagebox.showerror("Repository Not Found",
                f"Repository folder not found at:\n{current_repo_files}\n\n"
                f"Expected structure:\n"
                f"  {current_repo_path}\\\n"
                f"    ├─ gcode_database.db\n"
                f"    └─ repository\\")
            return

        # Ask user to confirm
        result = messagebox.askyesno(
            "Fix Drive Letter Paths",
            f"Detected Google Drive at: {current_drive}\\\n"
            f"Database: {current_db_path}\n"
            f"Repository: {current_repo_files}\n\n"
            f"This will update ALL file paths in the database to use the current drive letter.\n\n"
            f"Continue?",
            icon='question'
        )

        if not result:
            return

        # Progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Fixing Drive Letter Paths")
        progress_window.geometry("800x600")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window, text="🔧 Fixing Drive Letter Paths",
                 font=("Arial", 14, "bold"),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        output_text = scrolledtext.ScrolledText(progress_window,
                                                wrap=tk.WORD,
                                                width=90, height=30,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        progress_window.update()

        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        output_text.insert(tk.END, f"Current Database Location: {current_db_path}\n")
        output_text.insert(tk.END, f"Current Drive Letter: {current_drive}\n")
        output_text.insert(tk.END, f"Repository Folder: {current_repo_files}\n\n")
        output_text.insert(tk.END, "=" * 80 + "\n\n")
        progress_window.update()

        # Get all programs with file paths
        cursor.execute("SELECT program_number, file_path FROM programs WHERE file_path IS NOT NULL AND file_path != ''")
        programs = cursor.fetchall()

        output_text.insert(tk.END, f"Found {len(programs)} programs with file paths\n\n")
        progress_window.update()

        updated = 0
        already_correct = 0
        fixed_to_repo = 0
        not_found = 0

        for prog_num, old_path in programs:
            if not old_path:
                continue

            # Extract just the filename from old path
            filename = os.path.basename(old_path)

            # Build new path using current repository location
            new_path = os.path.join(current_repo_files, filename)

            # Check if file exists at new location
            if os.path.exists(new_path):
                if old_path != new_path:
                    # Update to new path
                    cursor.execute("UPDATE programs SET file_path = ? WHERE program_number = ?", (new_path, prog_num))
                    cursor.execute("UPDATE program_number_registry SET file_path = ? WHERE program_number = ?", (new_path, prog_num))
                    updated += 1

                    # Show first 20 updates
                    if updated <= 20:
                        old_drive = os.path.splitdrive(old_path)[0]
                        output_text.insert(tk.END, f"✓ {prog_num}: {old_drive}\\ → {current_drive}\\\n")
                else:
                    already_correct += 1
            else:
                # File doesn't exist at new location - maybe different filename
                # Try to find it in repository by program number
                base_num = prog_num.lower()
                if not base_num.startswith('o'):
                    base_num = 'o' + base_num

                found = False
                for ext in ['.nc', '.NC', '']:
                    test_path = os.path.join(current_repo_files, f"{base_num}{ext}")
                    if os.path.exists(test_path):
                        cursor.execute("UPDATE programs SET file_path = ? WHERE program_number = ?", (test_path, prog_num))
                        cursor.execute("UPDATE program_number_registry SET file_path = ? WHERE program_number = ?", (test_path, prog_num))
                        fixed_to_repo += 1
                        found = True
                        break

                if not found:
                    not_found += 1
                    if not_found <= 10:
                        output_text.insert(tk.END, f"⚠️ {prog_num}: File not found in repository\n")

            # Update progress every 100 files
            if (updated + already_correct + fixed_to_repo + not_found) % 100 == 0:
                output_text.see(tk.END)
                progress_window.update()

        conn.commit()
        conn.close()

        output_text.insert(tk.END, f"\n{'=' * 80}\n")
        output_text.insert(tk.END, f"DRIVE LETTER FIX COMPLETE\n")
        output_text.insert(tk.END, f"{'=' * 80}\n\n")
        output_text.insert(tk.END, f"✅ Updated to current drive: {updated}\n")
        output_text.insert(tk.END, f"✓ Already correct: {already_correct}\n")
        output_text.insert(tk.END, f"🔍 Found in repository: {fixed_to_repo}\n")
        output_text.insert(tk.END, f"⚠️ Not found: {not_found}\n")
        output_text.insert(tk.END, f"\nTotal processed: {len(programs)}\n")

        # Refresh UI
        self.refresh_results()

        tk.Button(progress_window, text="Close", command=progress_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def refresh_all_files(self):
        """
        Re-parse all files in the database to update detection fields.
        Useful after parser improvements (like fixing steel ring detection).
        """
        result = messagebox.askyesno(
            "Refresh All Files",
            "This will re-parse ALL files in the database to update:\n"
            "• Part types (steel_ring, standard, hub_centric, etc.)\n"
            "• Dimensions (CB, OB, thickness, hub height)\n"
            "• Validation status and warnings\n"
            "• Detection notes\n\n"
            "This may take several minutes for large databases.\n\n"
            "Continue?",
            icon='question'
        )

        if not result:
            return

        # Progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Refreshing All Files")
        progress_window.geometry("900x700")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window, text="🔄 Refreshing All Files",
                 font=("Arial", 14, "bold"),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        output_text = scrolledtext.ScrolledText(progress_window,
                                                wrap=tk.WORD,
                                                width=100, height=35,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        progress_window.update()

        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        output_text.insert(tk.END, "=" * 80 + "\n")
        output_text.insert(tk.END, "REFRESHING ALL FILES\n")
        output_text.insert(tk.END, "=" * 80 + "\n\n")
        progress_window.update()

        # Get all programs with file paths
        cursor.execute("""
            SELECT program_number, file_path
            FROM programs
            WHERE file_path IS NOT NULL AND file_path != ''
            AND (is_deleted IS NULL OR is_deleted = 0)
            ORDER BY program_number
        """)
        programs = cursor.fetchall()

        output_text.insert(tk.END, f"Found {len(programs)} files to refresh\n\n")
        progress_window.update()

        from improved_gcode_parser import ImprovedGCodeParser
        parser = ImprovedGCodeParser()

        refreshed = 0
        errors = 0
        type_changes = []

        for prog_num, file_path in programs:
            if not os.path.exists(file_path):
                errors += 1
                continue

            try:
                # Get old type before refresh
                cursor.execute("SELECT spacer_type FROM programs WHERE program_number = ?", (prog_num,))
                old_type = cursor.fetchone()[0] if cursor.fetchone() else None

                # Re-parse file
                result = parser.parse_file(file_path)

                # Update ALL detection fields in database
                cursor.execute("""
                    UPDATE programs SET
                        spacer_type = ?,
                        outer_diameter = ?,
                        thickness = ?,
                        center_bore = ?,
                        hub_diameter = ?,
                        hub_height = ?,
                        counter_bore_diameter = ?,
                        counter_bore_depth = ?,
                        validation_status = ?,
                        validation_issues = ?,
                        validation_warnings = ?,
                        crash_issues = ?,
                        crash_warnings = ?,
                        bore_warnings = ?,
                        dimensional_issues = ?,
                        detection_notes = ?
                    WHERE program_number = ?
                """, (
                    result.spacer_type,
                    result.outer_diameter,
                    result.thickness,
                    result.center_bore,
                    result.hub_diameter,
                    result.hub_height,
                    result.counter_bore_diameter,
                    result.counter_bore_depth,
                    # Determine validation status
                    'CRASH_RISK' if result.crash_issues else
                    'CRITICAL' if result.validation_issues else
                    'CRASH_WARNING' if result.crash_warnings else
                    'BORE_WARNING' if result.bore_warnings else
                    'WARNING' if result.validation_warnings else
                    'DIMENSIONAL' if result.dimensional_issues else 'OK',
                    json.dumps(result.validation_issues) if result.validation_issues else None,
                    json.dumps(result.validation_warnings) if result.validation_warnings else None,
                    json.dumps(result.crash_issues) if result.crash_issues else None,
                    json.dumps(result.crash_warnings) if result.crash_warnings else None,
                    json.dumps(result.bore_warnings) if result.bore_warnings else None,
                    json.dumps(result.dimensional_issues) if result.dimensional_issues else None,
                    json.dumps(result.detection_notes) if result.detection_notes else None,
                    prog_num
                ))

                refreshed += 1

                # Track type changes
                if old_type and old_type != result.spacer_type:
                    type_changes.append(f"{prog_num}: {old_type} → {result.spacer_type}")

                # Show progress every 100 files
                if refreshed % 100 == 0:
                    output_text.insert(tk.END, f"Processed {refreshed}/{len(programs)}...\n")
                    output_text.see(tk.END)
                    progress_window.update()

            except Exception as e:
                errors += 1
                if errors <= 10:
                    output_text.insert(tk.END, f"❌ Error parsing {prog_num}: {str(e)}\n")

        conn.commit()
        conn.close()

        output_text.insert(tk.END, f"\n{'=' * 80}\n")
        output_text.insert(tk.END, "REFRESH COMPLETE\n")
        output_text.insert(tk.END, f"{'=' * 80}\n\n")
        output_text.insert(tk.END, f"✅ Successfully refreshed: {refreshed}\n")
        output_text.insert(tk.END, f"❌ Errors: {errors}\n")
        output_text.insert(tk.END, f"🔄 Type changes: {len(type_changes)}\n\n")

        if type_changes:
            output_text.insert(tk.END, "Part type changes detected:\n")
            for change in type_changes[:50]:  # Show first 50
                output_text.insert(tk.END, f"  {change}\n")
            if len(type_changes) > 50:
                output_text.insert(tk.END, f"  ... and {len(type_changes) - 50} more\n")

        # Refresh UI
        self.refresh_results()

        tk.Button(progress_window, text="Close", command=progress_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def sync_validation_status_with_warnings(self):
        """
        Synchronize validation_status with actual warning fields.
        Fixes cases where colors show but details are missing.
        """
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Sync Validation Status")
        progress_window.geometry("800x600")
        progress_window.configure(bg=self.bg_color)

        info_label = tk.Label(progress_window,
                             text="Synchronizing validation status with warning fields...",
                             font=("Arial", 10),
                             bg=self.bg_color, fg=self.fg_color,
                             justify=tk.LEFT)
        info_label.pack(pady=5, padx=20, anchor=tk.W)

        # Scrolled text for output
        output_frame = tk.Frame(progress_window, bg=self.bg_color)
        output_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        output_text = scrolledtext.ScrolledText(output_frame,
                                                wrap=tk.WORD,
                                                width=100, height=25,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True)

        progress_window.update()

        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            output_text.insert(tk.END, "=" * 80 + "\n")
            output_text.insert(tk.END, "VALIDATION STATUS SYNC\n")
            output_text.insert(tk.END, "=" * 80 + "\n\n")

            # Find records with status but potentially no details
            output_text.insert(tk.END, "Checking for mismatched validation statuses...\n")
            progress_window.update()

            cursor.execute("""
                SELECT program_number, validation_status, crash_issues, crash_warnings,
                       validation_warnings, bore_warnings, dimensional_issues
                FROM programs
                WHERE validation_status IN ('CRASH_RISK', 'CRASH_WARNING', 'WARNING', 'DIMENSIONAL')
            """)

            all_records = cursor.fetchall()
            output_text.insert(tk.END, f"Found {len(all_records)} programs with validation statuses\n\n")
            progress_window.update()

            mismatches = 0
            fixed_programs = []

            for row in all_records:
                prog_num, status, crash_issues, crash_warnings, val_warnings, bore_warnings, dim_issues = row

                # Check if warnings are actually empty
                has_crash_issues = crash_issues and (
                    (isinstance(crash_issues, str) and crash_issues.strip() and crash_issues != '[]') or
                    (isinstance(crash_issues, list) and len(crash_issues) > 0)
                )
                has_crash_warnings = crash_warnings and (
                    (isinstance(crash_warnings, str) and crash_warnings.strip() and crash_warnings != '[]') or
                    (isinstance(crash_warnings, list) and len(crash_warnings) > 0)
                )
                has_val_warnings = val_warnings and (
                    (isinstance(val_warnings, str) and val_warnings.strip() and val_warnings != '[]') or
                    (isinstance(val_warnings, list) and len(val_warnings) > 0)
                )
                has_bore_warnings = bore_warnings and (
                    (isinstance(bore_warnings, str) and bore_warnings.strip() and bore_warnings != '[]') or
                    (isinstance(bore_warnings, list) and len(bore_warnings) > 0)
                )
                has_dim_issues = dim_issues and (
                    (isinstance(dim_issues, str) and dim_issues.strip() and dim_issues != '[]') or
                    (isinstance(dim_issues, list) and len(dim_issues) > 0)
                )

                new_status = None

                # If status says CRASH_RISK but no actual crash issues, downgrade
                if status == 'CRASH_RISK' and not has_crash_issues:
                    if has_crash_warnings:
                        new_status = 'CRASH_WARNING'
                    elif has_bore_warnings or has_val_warnings:
                        new_status = 'WARNING'
                    elif has_dim_issues:
                        new_status = 'DIMENSIONAL'
                    else:
                        new_status = 'OK'

                # If status says CRASH_WARNING but no actual crash warnings, downgrade
                elif status == 'CRASH_WARNING' and not has_crash_warnings:
                    if has_bore_warnings or has_val_warnings:
                        new_status = 'WARNING'
                    elif has_dim_issues:
                        new_status = 'DIMENSIONAL'
                    else:
                        new_status = 'OK'

                # If status says WARNING but no actual warnings, downgrade
                elif status == 'WARNING' and not has_bore_warnings and not has_val_warnings:
                    if has_dim_issues:
                        new_status = 'DIMENSIONAL'
                    else:
                        new_status = 'OK'

                # If status says DIMENSIONAL but no actual dimensional issues, clear
                elif status == 'DIMENSIONAL' and not has_dim_issues:
                    new_status = 'OK'

                # Update if mismatch found
                if new_status and new_status != status:
                    cursor.execute("""
                        UPDATE programs
                        SET validation_status = ?
                        WHERE program_number = ?
                    """, (new_status, prog_num))
                    mismatches += 1
                    fixed_programs.append(f"{prog_num}: {status} → {new_status}")

            conn.commit()

            output_text.insert(tk.END, f"\nSync Complete:\n")
            output_text.insert(tk.END, f"  Total programs checked: {len(all_records)}\n")
            output_text.insert(tk.END, f"  Mismatches found and fixed: {mismatches}\n\n")

            if fixed_programs:
                output_text.insert(tk.END, "Programs fixed:\n")
                for fix in fixed_programs[:50]:  # Show first 50
                    output_text.insert(tk.END, f"  {fix}\n")
                if len(fixed_programs) > 50:
                    output_text.insert(tk.END, f"  ... and {len(fixed_programs) - 50} more\n")

            output_text.insert(tk.END, "\n" + "=" * 80 + "\n")
            output_text.insert(tk.END, "SYNC COMPLETE\n")
            output_text.insert(tk.END, "=" * 80 + "\n")

            # Refresh tree view
            self.refresh_results()

        except Exception as e:
            output_text.insert(tk.END, f"\n❌ ERROR: {str(e)}\n")
            import traceback
            output_text.insert(tk.END, traceback.format_exc())
        finally:
            if conn:
                conn.close()

        # Add close button
        tk.Button(progress_window, text="Close", command=progress_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def handle_not_found_files(self, not_found_list):
        """
        Interactive dialog to help locate files that rebase couldn't find.
        """
        if not not_found_list:
            return

        # Create dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Help Locate {len(not_found_list)} Missing Files")
        dialog.geometry("900x700")
        dialog.configure(bg=self.bg_color)

        # Instructions
        tk.Label(dialog, text=f"Rebase couldn't find {len(not_found_list)} files.",
                 font=('Arial', 12, 'bold'),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        tk.Label(dialog, text="Choose an option to resolve these missing files:",
                 font=('Arial', 10),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=5)

        # Option buttons
        frame = tk.Frame(dialog, bg=self.bg_color)
        frame.pack(pady=10)

        def search_custom_folder():
            folder = filedialog.askdirectory(title="Select folder to search for missing files")
            if folder:
                self.search_and_update_missing_files(not_found_list, folder, dialog)

        def mark_as_deleted():
            # Extract program numbers from not_found_list
            # Format is "o80152 (expected: o80152.nc)"
            prog_nums = []
            for item in not_found_list:
                prog_num = item.split(' ')[0]  # Get first part before space
                prog_nums.append(prog_num)

            if messagebox.askyesno("Confirm Mark as Deleted",
                                  f"Mark {len(prog_nums)} missing files as deleted?\n\n"
                                  f"This will set is_deleted=1 for these programs,\n"
                                  f"removing them from the active file list.",
                                  parent=dialog):
                self.mark_files_deleted(prog_nums)
                messagebox.showinfo("Complete", f"{len(prog_nums)} programs marked as deleted", parent=dialog)
                dialog.destroy()

        def skip():
            dialog.destroy()

        tk.Button(frame, text="🔍 Search Custom Folder", command=search_custom_folder,
                  bg="#2196F3", fg=self.fg_color, font=("Arial", 10, "bold"),
                  width=25, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(frame, text="🗑️ Mark as Deleted", command=mark_as_deleted,
                  bg="#FF5722", fg=self.fg_color, font=("Arial", 10, "bold"),
                  width=25, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(frame, text="Skip", command=skip,
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10),
                  width=15, height=2).pack(side=tk.LEFT, padx=5)

        # Show list
        tk.Label(dialog, text="Files not found:", font=('Arial', 10, 'bold'),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        text_frame = tk.Frame(dialog, bg=self.bg_color)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        text = scrolledtext.ScrolledText(text_frame,
                                         wrap=tk.WORD,
                                         width=90, height=25,
                                         font=("Courier New", 9),
                                         bg="#1e1e1e", fg="#ffffff")
        text.pack(fill=tk.BOTH, expand=True)

        for f in not_found_list:
            text.insert(tk.END, f + "\n")
        text.config(state=tk.DISABLED)

    def find_duplicate_programs(self):
        """
        Find programs with same title and dimensions.
        Returns groups of duplicates for user review.
        """
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        # Get all active programs
        cursor.execute("""
            SELECT program_number, title, outer_diameter, thickness,
                   center_bore, hub_diameter, hub_height, spacer_type,
                   file_path, last_modified
            FROM programs
            WHERE (is_deleted IS NULL OR is_deleted = 0)
            ORDER BY title, outer_diameter
        """)

        programs = cursor.fetchall()
        conn.close()

        # Group by normalized signature
        groups = {}
        for prog in programs:
            prog_num, title, od, thick, cb, ob, hub_h, sp_type, path, modified = prog

            # Create signature (normalized)
            norm_title = ' '.join(title.upper().split()) if title else ''

            # Round dimensions to 0.1 precision for matching
            od_key = round(od, 1) if od else None
            thick_key = round(thick, 2) if thick else None
            cb_key = round(cb, 1) if cb else None
            ob_key = round(ob, 1) if ob else None
            hub_key = round(hub_h, 2) if hub_h else None

            signature = (norm_title, od_key, thick_key, cb_key, ob_key, hub_key, sp_type)

            if signature not in groups:
                groups[signature] = []

            groups[signature].append({
                'program_number': prog_num,
                'title': title,
                'od': od,
                'thickness': thick,
                'cb': cb,
                'ob': ob,
                'hub_height': hub_h,
                'type': sp_type,
                'file_path': path,
                'modified': modified
            })

        # Filter to groups with 2+ programs (actual duplicates)
        duplicates = {k: v for k, v in groups.items() if len(v) >= 2}

        return duplicates

    def show_duplicate_browser(self):
        """
        Show dialog with duplicate programs for review and archival.
        """
        duplicates = self.find_duplicate_programs()

        if not duplicates:
            messagebox.showinfo("No Duplicates", "No duplicate programs found!")
            return

        # Create dialog
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Duplicate Programs ({len(duplicates)} groups)")
        dialog.geometry("1400x800")
        dialog.configure(bg=self.bg_color)

        # Summary
        total_dupes = sum(len(v) for v in duplicates.values())
        tk.Label(dialog, text=f"Found {len(duplicates)} duplicate groups ({total_dupes} total programs)",
                 font=('Arial', 12, 'bold'),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        # Instructions
        tk.Label(dialog, text="Select programs to archive, then click 'Archive Selected'. Keep at least one copy of each program.",
                 font=('Arial', 10),
                 bg=self.bg_color, fg="#888888").pack(pady=5)

        # Create treeview
        frame = tk.Frame(dialog, bg=self.bg_color)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        columns = ("Group", "Program #", "Title", "OD", "Thick", "CB", "OB", "Hub H", "Type", "Modified")
        tree = ttk.Treeview(frame, columns=columns, show="headings", selectmode="extended")

        for col in columns:
            tree.heading(col, text=col)
        tree.column("Group", width=60)
        tree.column("Program #", width=100)
        tree.column("Title", width=300)
        tree.column("OD", width=80)
        tree.column("Thick", width=80)
        tree.column("CB", width=80)
        tree.column("OB", width=80)
        tree.column("Hub H", width=80)
        tree.column("Type", width=120)
        tree.column("Modified", width=150)

        # Add scrollbar
        scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        tree.pack(fill=tk.BOTH, expand=True)

        # Populate
        group_num = 1
        for signature, programs in sorted(duplicates.items(), key=lambda x: len(x[1]), reverse=True):
            for i, prog in enumerate(programs):
                group_id = f"G{group_num}" if i == 0 else ""
                tree.insert("", "end", values=(
                    group_id,
                    prog['program_number'],
                    prog['title'],
                    f"{prog['od']:.2f}" if prog['od'] else "",
                    f"{prog['thickness']:.3f}" if prog['thickness'] else "",
                    f"{prog['cb']:.1f}" if prog['cb'] else "",
                    f"{prog['ob']:.1f}" if prog['ob'] else "",
                    f"{prog['hub_height']:.2f}" if prog['hub_height'] else "",
                    prog['type'] or "",
                    prog['modified'] or ""
                ))
            group_num += 1

        # Action buttons
        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        def archive_selected():
            selected = tree.selection()
            if not selected:
                messagebox.showwarning("No Selection", "Select programs to archive", parent=dialog)
                return

            # Get program numbers
            prog_nums = [tree.item(item)['values'][1] for item in selected]

            if messagebox.askyesno("Confirm Archive",
                                  f"Archive {len(prog_nums)} selected programs?\n\n"
                                  f"This will mark them as deleted (is_deleted=1),\n"
                                  f"removing them from the active file list.\n\n"
                                  f"You can view archived files in the\n"
                                  f"'Archived/Deleted Files Browser'.",
                                  parent=dialog):
                self.mark_files_deleted(prog_nums)
                messagebox.showinfo("Complete", f"{len(prog_nums)} programs archived", parent=dialog)
                dialog.destroy()
                # Refresh UI
                self.refresh_results()

        tk.Button(btn_frame, text="📦 Archive Selected", command=archive_selected,
                  bg="#FF5722", fg=self.fg_color, font=("Arial", 10, "bold"),
                  width=20, height=2).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Close", command=dialog.destroy,
                  bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold"),
                  width=15, height=2).pack(side=tk.LEFT, padx=5)

    def search_and_update_missing_files(self, not_found_list, search_folder, parent_dialog):
        """
        Search for missing files in custom folder and update paths.
        """
        progress_window = tk.Toplevel(parent_dialog)
        progress_window.title("Searching for Missing Files")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window, text="🔍 Searching Custom Folder",
                 font=("Arial", 12, "bold"),
                 bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        output_text = scrolledtext.ScrolledText(progress_window,
                                                wrap=tk.WORD,
                                                width=80, height=25,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        progress_window.update()

        output_text.insert(tk.END, f"Searching in: {search_folder}\n")
        output_text.insert(tk.END, f"Looking for {len(not_found_list)} files...\n\n")
        progress_window.update()

        found = 0
        still_missing = 0

        conn = sqlite3.connect(self.db_path, timeout=30.0)
        cursor = conn.cursor()

        for item in not_found_list:
            prog_num = item.split(' ')[0]  # Extract program number

            # Build filename
            base_num = prog_num.lower()
            if not base_num.startswith('o'):
                base_num = 'o' + base_num

            # Try .nc and no extension
            for ext in ['.nc', '.NC', '']:
                filename = f"{base_num}{ext}"
                test_path = os.path.join(search_folder, filename)

                if os.path.exists(test_path):
                    # Found it! Update database
                    cursor.execute("""
                        UPDATE programs
                        SET file_path = ?
                        WHERE program_number = ?
                    """, (test_path, prog_num))

                    cursor.execute("""
                        UPDATE program_number_registry
                        SET file_path = ?
                        WHERE program_number = ?
                    """, (test_path, prog_num))

                    output_text.insert(tk.END, f"✅ Found: {prog_num} → {filename}\n")
                    found += 1
                    break
            else:
                output_text.insert(tk.END, f"❌ Not found: {prog_num}\n")
                still_missing += 1

            output_text.see(tk.END)
            progress_window.update()

        conn.commit()
        conn.close()

        output_text.insert(tk.END, f"\n{'='*60}\n")
        output_text.insert(tk.END, f"Search complete:\n")
        output_text.insert(tk.END, f"  Found and updated: {found}\n")
        output_text.insert(tk.END, f"  Still missing: {still_missing}\n")

        # Refresh UI
        self.refresh_results()

        tk.Button(progress_window, text="Close", command=lambda: [progress_window.destroy(), parent_dialog.destroy()],
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    def quick_rebase_paths(self):
        """
        Fast path rebase - updates all file_path entries to point to current repository location.
        Use this when moving the database between computers where only the base path has changed.
        Much faster than repair_file_paths as it doesn't scan files or check duplicates.
        """
        # Ask user: auto-find or select custom folder?
        from tkinter import simpledialog

        # Create custom dialog for path selection
        path_dialog = tk.Toplevel(self.root)
        path_dialog.title("Select Repository Location")
        path_dialog.geometry("500x300")
        path_dialog.configure(bg=self.bg_color)
        path_dialog.transient(self.root)
        path_dialog.grab_set()

        selected_path = None
        user_choice = None

        def use_default():
            nonlocal user_choice
            user_choice = 'default'
            path_dialog.destroy()

        def select_custom():
            nonlocal selected_path, user_choice
            custom_path = filedialog.askdirectory(
                title="Select Folder Containing G-Code Files",
                initialdir=os.path.dirname(self.repository_path)
            )
            if custom_path:
                selected_path = custom_path
                user_choice = 'custom'
                path_dialog.destroy()
            # If cancelled, keep dialog open

        def cancel():
            nonlocal user_choice
            user_choice = 'cancel'
            path_dialog.destroy()

        # Title
        tk.Label(path_dialog, text="🔄 Rebase File Paths",
                font=("Arial", 14, "bold"),
                bg=self.bg_color, fg=self.fg_color).pack(pady=15)

        # Info text
        info_text = (
            "Where are your G-code files located?\n\n"
            f"Default Repository:\n{self.repository_path}\n\n"
            "Choose an option:"
        )
        tk.Label(path_dialog, text=info_text,
                font=("Arial", 10),
                bg=self.bg_color, fg=self.fg_color,
                justify=tk.LEFT).pack(pady=10, padx=20)

        # Buttons frame
        button_frame = tk.Frame(path_dialog, bg=self.bg_color)
        button_frame.pack(pady=20)

        tk.Button(button_frame, text="📁 Use Default Repository",
                 command=use_default,
                 bg="#4CAF50", fg=self.fg_color,
                 font=("Arial", 10, "bold"),
                 width=25, height=2).pack(pady=5)

        tk.Button(button_frame, text="🔍 Select Custom Folder...",
                 command=select_custom,
                 bg="#2196F3", fg=self.fg_color,
                 font=("Arial", 10, "bold"),
                 width=25, height=2).pack(pady=5)

        tk.Button(button_frame, text="Cancel",
                 command=cancel,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10),
                 width=25).pack(pady=5)

        # Wait for user choice
        self.root.wait_window(path_dialog)

        if user_choice == 'cancel' or user_choice is None:
            return

        # Set the search path based on choice
        if user_choice == 'custom':
            search_paths = [selected_path]
            revised_path = selected_path  # Use same path for revised
        else:
            search_paths = [self.repository_path, self.revised_repository_path]
            revised_path = self.revised_repository_path

        # Confirm with user
        path_display = selected_path if user_choice == 'custom' else f"{self.repository_path}\n{self.revised_repository_path}"
        result = messagebox.askyesno(
            "Quick Path Rebase - Confirm",
            f"This will update ALL managed file paths to search in:\n\n"
            f"{path_display}\n\n"
            "This assumes:\n"
            "• Files are named {{program_number}}.nc\n"
            "• All files are in the selected folder(s)\n"
            "• No duplicate checking needed\n\n"
            "Continue?",
            icon='question'
        )

        if not result:
            return

        # Show progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Quick Path Rebase")
        progress_window.geometry("600x400")
        progress_window.configure(bg=self.bg_color)

        tk.Label(progress_window, text="🔄 Quick Path Rebase",
                font=("Arial", 14, "bold"),
                bg=self.bg_color, fg=self.fg_color).pack(pady=10)

        output_text = scrolledtext.ScrolledText(progress_window,
                                                wrap=tk.WORD,
                                                width=70, height=20,
                                                font=("Courier New", 9),
                                                bg="#1e1e1e", fg="#ffffff")
        output_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        progress_window.update()

        conn = None
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            output_text.insert(tk.END, "=" * 60 + "\n")
            output_text.insert(tk.END, "QUICK PATH REBASE\n")
            output_text.insert(tk.END, "=" * 60 + "\n\n")
            if user_choice == 'custom':
                output_text.insert(tk.END, f"Custom search path: {selected_path}\n\n")
            else:
                output_text.insert(tk.END, f"Repository path: {self.repository_path}\n")
                output_text.insert(tk.END, f"Revised path: {self.revised_repository_path}\n\n")
            progress_window.update()

            # Get all managed programs
            cursor.execute("""
                SELECT program_number, file_path
                FROM programs
                WHERE is_managed = 1
            """)
            programs = cursor.fetchall()

            output_text.insert(tk.END, f"Found {len(programs)} managed programs\n\n")
            output_text.insert(tk.END, "Updating paths...\n")
            progress_window.update()

            updated = 0
            not_found = 0
            already_correct = 0
            not_found_list = []  # Track which programs weren't found

            for prog_num, old_path in programs:
                # Skip if program number is None/NULL
                if not prog_num:
                    not_found += 1
                    not_found_list.append("(NULL program number)")
                    continue

                # Skip if file_path is None/empty (file was deleted/archived/never imported)
                if not old_path or old_path.strip() == '':
                    # Don't count as "not found" - this was intentionally removed
                    already_correct += 1  # Count as "already correct" (correctly removed)
                    continue

                # Build expected filename - handle various formats
                base_num = prog_num.lower()
                if not base_num.startswith('o'):
                    base_num = 'o' + base_num

                # Try searching in the selected path(s)
                filename = f"{base_num}.nc"
                new_path = None

                # Search in all specified paths
                for search_path in search_paths:
                    # Try with .nc extension first
                    test_path = os.path.join(search_path, filename)
                    if os.path.exists(test_path):
                        new_path = test_path
                        break

                    # Try without .nc extension
                    test_path = os.path.join(search_path, base_num)
                    if os.path.exists(test_path):
                        new_path = test_path
                        break

                # If still not found and using default paths, try revised repository
                if not new_path and user_choice == 'default':
                    test_path = os.path.join(revised_path, filename)
                    if os.path.exists(test_path):
                        new_path = test_path

                if new_path and os.path.exists(new_path):
                    if old_path == new_path:
                        already_correct += 1
                    else:
                        # Update the path
                        cursor.execute("""
                            UPDATE programs
                            SET file_path = ?
                            WHERE program_number = ?
                        """, (new_path, prog_num))

                        # Also update registry if it exists
                        cursor.execute("""
                            UPDATE program_number_registry
                            SET file_path = ?
                            WHERE program_number = ?
                        """, (new_path, prog_num))

                        updated += 1
                else:
                    not_found += 1
                    not_found_list.append(f"{prog_num} (expected: {filename})")

                # Progress update every 500 files
                if (updated + not_found + already_correct) % 500 == 0:
                    output_text.insert(tk.END, f"  Processed {updated + not_found + already_correct}/{len(programs)}...\n")
                    output_text.see(tk.END)
                    progress_window.update()

            conn.commit()

            output_text.insert(tk.END, "\n" + "=" * 60 + "\n")
            output_text.insert(tk.END, "COMPLETE\n")
            output_text.insert(tk.END, "=" * 60 + "\n\n")
            output_text.insert(tk.END, f"✅ Updated: {updated}\n")
            output_text.insert(tk.END, f"✓ Already correct: {already_correct}\n")
            output_text.insert(tk.END, f"⚠️ File not found: {not_found}\n")
            output_text.insert(tk.END, f"\nTotal processed: {len(programs)}\n")

            if not_found > 0:
                output_text.insert(tk.END, f"\n⚠️ {not_found} files were not found in the repository.\n")
                output_text.insert(tk.END, "These may have different filenames or be missing.\n\n")
                output_text.insert(tk.END, "Files not found:\n")
                for missing in not_found_list:
                    output_text.insert(tk.END, f"  • {missing}\n")
                output_text.insert(tk.END, "\n")

            output_text.see(tk.END)

            # Refresh UI
            self.refresh_results()

            # If files weren't found, offer interactive help
            if not_found_list:
                # Close this progress window first
                progress_window.destroy()
                # Show interactive dialog
                self.handle_not_found_files(not_found_list)
                return  # Don't show close button since window is destroyed

        except Exception as e:
            output_text.insert(tk.END, f"\n❌ ERROR: {str(e)}\n")
            import traceback
            output_text.insert(tk.END, f"\n{traceback.format_exc()}\n")
        finally:
            if conn:
                conn.close()

        tk.Button(progress_window, text="Close", command=progress_window.destroy,
                 bg=self.button_bg, fg=self.fg_color, font=("Arial", 10, "bold")).pack(pady=10)

    # ===== Program Number Registry Management =====

    def show_registry_window(self):
        """Show the program number registry statistics window"""
        RegistryStatisticsWindow(self.root, self)

    def show_out_of_range_window(self):
        """Show the out-of-range programs window"""
        OutOfRangeWindow(self.root, self)

    def show_batch_rename_window(self):
        """Show the batch rename resolution window"""
        BatchRenameWindow(self.root, self)

    def show_batch_operations(self):
        """Show batch operations window for selected programs"""
        # Get selected items
        selected_items = self.tree.selection()

        if not selected_items:
            messagebox.showwarning(
                "No Selection",
                "Please select one or more programs first.\n\n"
                "Use Ctrl+Click to select multiple items\n"
                "Use Shift+Click to select a range"
            )
            return

        # Get program numbers for selected items
        selected_programs = []
        for item in selected_items:
            values = self.tree.item(item, 'values')
            if values:
                selected_programs.append(values[0])  # program_number is first column

        if not selected_programs:
            messagebox.showwarning("No Programs", "No valid programs selected.")
            return

        # Create batch operations window
        batch_window = tk.Toplevel(self.root)
        batch_window.title(f"Batch Operations - {len(selected_programs)} Selected")
        batch_window.geometry("700x600")
        batch_window.configure(bg=self.bg_color)
        batch_window.transient(self.root)

        # Header
        header = tk.Label(batch_window,
                         text=f"📦 Batch Operations - {len(selected_programs)} Programs Selected",
                         bg=self.bg_color, fg=self.fg_color,
                         font=("Arial", 14, "bold"))
        header.pack(pady=15)

        # Selected programs list
        list_frame = tk.LabelFrame(batch_window, text="Selected Programs",
                                   bg=self.bg_color, fg=self.fg_color,
                                   font=("Arial", 10, "bold"))
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        list_scroll = ttk.Scrollbar(list_frame)
        list_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        programs_list = tk.Listbox(list_frame, yscrollcommand=list_scroll.set,
                                   bg=self.input_bg, fg=self.fg_color,
                                   font=("Consolas", 9), height=10)
        list_scroll.config(command=programs_list.yview)
        programs_list.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        for prog in selected_programs:
            programs_list.insert(tk.END, prog)

        # Operations frame
        ops_frame = tk.LabelFrame(batch_window, text="Available Operations",
                                 bg=self.bg_color, fg=self.fg_color,
                                 font=("Arial", 10, "bold"))
        ops_frame.pack(fill=tk.X, padx=20, pady=10)

        # Operation buttons - 2 columns
        btn_frame = tk.Frame(ops_frame, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        # Left column
        left_col = tk.Frame(btn_frame, bg=self.bg_color)
        left_col.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        tk.Button(left_col, text="📤 Export Selected",
                 command=lambda: self.batch_export(selected_programs, batch_window),
                 bg="#2E7D32", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        tk.Button(left_col, text="🗑️ Delete Selected",
                 command=lambda: self.batch_delete(selected_programs, batch_window),
                 bg="#D32F2F", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        tk.Button(left_col, text="📁 Move to Repository",
                 command=lambda: self.batch_move_to_repository(selected_programs, batch_window),
                 bg="#1976D2", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        # Right column
        right_col = tk.Frame(btn_frame, bg=self.bg_color)
        right_col.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        tk.Button(right_col, text="🔧 Update Material",
                 command=lambda: self.batch_update_material(selected_programs, batch_window),
                 bg="#FF6F00", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        tk.Button(right_col, text="🔄 Re-parse Selected",
                 command=lambda: self.batch_reparse(selected_programs, batch_window),
                 bg="#7B1FA2", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        tk.Button(right_col, text="📊 View Statistics",
                 command=lambda: self.batch_statistics(selected_programs, batch_window),
                 bg="#00796B", fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=20, height=2).pack(pady=5)

        # Close button
        tk.Button(batch_window, text="❌ Close", command=batch_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(pady=10)

    def batch_export(self, program_numbers, parent_window):
        """Export selected programs to a folder"""
        export_dir = filedialog.askdirectory(title="Select Export Directory")
        if not export_dir:
            return

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        success_count = 0
        failed = []

        for prog_num in program_numbers:
            try:
                cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (prog_num,))
                result = cursor.fetchone()
                if result and result[0] and os.path.exists(result[0]):
                    src = result[0]
                    dst = os.path.join(export_dir, os.path.basename(src))
                    import shutil
                    shutil.copy2(src, dst)
                    success_count += 1
                else:
                    failed.append(f"{prog_num} (file not found)")
            except Exception as e:
                failed.append(f"{prog_num} ({str(e)})")

        conn.close()

        msg = f"✅ Exported {success_count} of {len(program_numbers)} programs"
        if failed:
            msg += f"\n\n❌ Failed:\n" + "\n".join(failed[:10])
            if len(failed) > 10:
                msg += f"\n... and {len(failed)-10} more"

        messagebox.showinfo("Export Complete", msg)

    def batch_delete(self, program_numbers, parent_window):
        """Delete selected programs from database"""
        confirm = messagebox.askyesno(
            "Confirm Batch Delete",
            f"Are you sure you want to delete {len(program_numbers)} programs from the database?\n\n"
            "This will NOT delete the physical files, only the database entries."
        )
        if not confirm:
            return

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        for prog_num in program_numbers:
            cursor.execute("DELETE FROM programs WHERE program_number = ?", (prog_num,))

        conn.commit()
        conn.close()

        messagebox.showinfo("Delete Complete", f"✅ Deleted {len(program_numbers)} programs from database")
        parent_window.destroy()
        self.refresh_results()

    def batch_move_to_repository(self, program_numbers, parent_window):
        """Move selected programs to repository"""
        moved = 0
        failed = []

        for prog_num in program_numbers:
            try:
                if self.add_to_repository(prog_num):
                    moved += 1
                else:
                    failed.append(prog_num)
            except Exception as e:
                failed.append(f"{prog_num} ({str(e)})")

        msg = f"✅ Moved {moved} of {len(program_numbers)} programs to repository"
        if failed:
            msg += f"\n\n❌ Failed:\n" + "\n".join(str(f) for f in failed[:10])
            if len(failed) > 10:
                msg += f"\n... and {len(failed)-10} more"

        messagebox.showinfo("Move Complete", msg)
        self.refresh_results()

    def batch_update_material(self, program_numbers, parent_window):
        """Update material for selected programs"""
        # Create dialog to select material
        dialog = tk.Toplevel(parent_window)
        dialog.title("Select Material")
        dialog.geometry("300x200")
        dialog.configure(bg=self.bg_color)
        dialog.transient(parent_window)
        dialog.grab_set()

        tk.Label(dialog, text="Select Material:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 11, "bold")).pack(pady=10)

        material_var = tk.StringVar()
        material_combo = ttk.Combobox(dialog, textvariable=material_var,
                                     values=self.config.get("material_list", []),
                                     state="readonly", width=25)
        material_combo.pack(pady=10)

        def apply_material():
            material = material_var.get()
            if not material:
                messagebox.showwarning("No Material", "Please select a material")
                return

            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            for prog_num in program_numbers:
                cursor.execute("UPDATE programs SET material = ? WHERE program_number = ?",
                             (material, prog_num))

            conn.commit()
            conn.close()

            messagebox.showinfo("Update Complete",
                              f"✅ Updated material to '{material}' for {len(program_numbers)} programs")
            dialog.destroy()
            self.refresh_results()

        tk.Button(dialog, text="Apply", command=apply_material,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(pady=10)

        tk.Button(dialog, text="Cancel", command=dialog.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(pady=5)

    def batch_reparse(self, program_numbers, parent_window):
        """Re-parse selected programs"""
        confirm = messagebox.askyesno(
            "Confirm Re-parse",
            f"Re-parse {len(program_numbers)} selected programs?\n\n"
            "This will update dimensions, validation status, and tool/safety analysis."
        )
        if not confirm:
            return

        from improved_gcode_parser import ImprovedGCodeParser
        parser = ImprovedGCodeParser()

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        success = 0
        failed = []

        for prog_num in program_numbers:
            try:
                cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (prog_num,))
                result = cursor.fetchone()
                if result and result[0] and os.path.exists(result[0]):
                    parse_result = parser.parse_file(result[0])

                    # Calculate validation status
                    # NOTE: Safety and tool validation disabled for now - too many false positives
                    validation_status = "PASS"
                    if parse_result.validation_issues:
                        validation_status = "CRITICAL"
                    elif parse_result.tool_home_status == "CRITICAL":
                        validation_status = "TOOL_HOME_CRITICAL"  # G53 Z-16 or beyond (dangerous)
                    # elif parse_result.safety_blocks_status == "MISSING":
                    #     validation_status = "SAFETY_ERROR"  # DISABLED - too strict
                    # elif parse_result.tool_validation_status == "ERROR":
                    #     validation_status = "TOOL_ERROR"  # DISABLED - needs tuning
                    elif parse_result.bore_warnings:
                        validation_status = "BORE_WARNING"
                    elif parse_result.tool_home_status == "WARNING":
                        validation_status = "TOOL_HOME_WARNING"  # G53 Z doesn't match thickness
                    elif parse_result.dimensional_issues:
                        validation_status = "DIMENSIONAL"
                    # elif parse_result.tool_validation_status == "WARNING":
                    #     validation_status = "TOOL_WARNING"  # DISABLED - needs tuning
                    elif parse_result.validation_warnings:
                        validation_status = "WARNING"

                    # Update database
                    import json
                    cursor.execute("""
                        UPDATE programs SET
                            title = ?, spacer_type = ?, outer_diameter = ?, thickness = ?,
                            thickness_display = ?, center_bore = ?, hub_height = ?, hub_diameter = ?,
                            counter_bore_diameter = ?, counter_bore_depth = ?, material = ?,
                            validation_status = ?, validation_issues = ?, validation_warnings = ?,
                            bore_warnings = ?, dimensional_issues = ?,
                            tools_used = ?, tool_sequence = ?, tool_validation_status = ?,
                            tool_validation_issues = ?, safety_blocks_status = ?, safety_blocks_issues = ?,
                            tool_home_status = ?, tool_home_issues = ?
                        WHERE program_number = ?
                    """, (
                        parse_result.title, parse_result.spacer_type, parse_result.outer_diameter,
                        parse_result.thickness, parse_result.thickness_display, parse_result.center_bore,
                        parse_result.hub_height, parse_result.hub_diameter, parse_result.counter_bore_diameter,
                        parse_result.counter_bore_depth, parse_result.material, validation_status,
                        '|'.join(parse_result.validation_issues) if parse_result.validation_issues else None,
                        '|'.join(parse_result.validation_warnings) if parse_result.validation_warnings else None,
                        '|'.join(parse_result.bore_warnings) if parse_result.bore_warnings else None,
                        '|'.join(parse_result.dimensional_issues) if parse_result.dimensional_issues else None,
                        json.dumps(parse_result.tools_used) if parse_result.tools_used else None,
                        json.dumps(parse_result.tool_sequence) if parse_result.tool_sequence else None,
                        None,  # tool_validation_status - DISABLED
                        None,  # tool_validation_issues - DISABLED
                        None,  # safety_blocks_status - DISABLED
                        None,  # safety_blocks_issues - DISABLED
                        parse_result.tool_home_status,
                        json.dumps(parse_result.tool_home_issues) if parse_result.tool_home_issues else None,
                        prog_num
                    ))
                    success += 1
                else:
                    failed.append(f"{prog_num} (file not found)")
            except Exception as e:
                failed.append(f"{prog_num} ({str(e)})")

        conn.commit()
        conn.close()

        msg = f"✅ Re-parsed {success} of {len(program_numbers)} programs"
        if failed:
            msg += f"\n\n❌ Failed:\n" + "\n".join(failed[:10])
            if len(failed) > 10:
                msg += f"\n... and {len(failed)-10} more"

        messagebox.showinfo("Re-parse Complete", msg)
        self.refresh_results()

    def batch_statistics(self, program_numbers, parent_window):
        """Show statistics for selected programs"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Gather statistics
        stats = {
            'total': len(program_numbers),
            'types': {},
            'materials': {},
            'statuses': {},
            'avg_od': 0,
            'avg_thickness': 0,
            'avg_cb': 0
        }

        od_values = []
        thickness_values = []
        cb_values = []

        for prog_num in program_numbers:
            cursor.execute("""
                SELECT spacer_type, material, validation_status,
                       outer_diameter, thickness, center_bore
                FROM programs WHERE program_number = ?
            """, (prog_num,))
            result = cursor.fetchone()
            if result:
                stype, mat, status, od, thick, cb = result
                stats['types'][stype] = stats['types'].get(stype, 0) + 1
                stats['materials'][mat or 'Unknown'] = stats['materials'].get(mat or 'Unknown', 0) + 1
                stats['statuses'][status or 'N/A'] = stats['statuses'].get(status or 'N/A', 0) + 1

                if od:
                    od_values.append(od)
                if thick:
                    thickness_values.append(thick)
                if cb:
                    cb_values.append(cb)

        conn.close()

        if od_values:
            stats['avg_od'] = sum(od_values) / len(od_values)
        if thickness_values:
            stats['avg_thickness'] = sum(thickness_values) / len(thickness_values)
        if cb_values:
            stats['avg_cb'] = sum(cb_values) / len(cb_values)

        # Display statistics window
        stats_window = tk.Toplevel(parent_window)
        stats_window.title("Batch Statistics")
        stats_window.geometry("500x600")
        stats_window.configure(bg=self.bg_color)
        stats_window.transient(parent_window)

        tk.Label(stats_window, text=f"📊 Statistics for {stats['total']} Selected Programs",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 13, "bold")).pack(pady=15)

        # Stats text
        stats_frame = tk.Frame(stats_window, bg=self.bg_color)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        stats_scroll = ttk.Scrollbar(stats_frame)
        stats_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        stats_text = tk.Text(stats_frame, yscrollcommand=stats_scroll.set,
                            bg=self.input_bg, fg=self.fg_color,
                            font=("Consolas", 10), wrap=tk.WORD)
        stats_scroll.config(command=stats_text.yview)
        stats_text.pack(fill=tk.BOTH, expand=True)

        # Build stats text
        output = f"Total Programs: {stats['total']}\n\n"

        output += "SPACER TYPES:\n"
        for stype, count in sorted(stats['types'].items()):
            pct = (count / stats['total']) * 100
            output += f"  {stype}: {count} ({pct:.1f}%)\n"

        output += "\nMATERIALS:\n"
        for mat, count in sorted(stats['materials'].items()):
            pct = (count / stats['total']) * 100
            output += f"  {mat}: {count} ({pct:.1f}%)\n"

        output += "\nVALIDATION STATUS:\n"
        for status, count in sorted(stats['statuses'].items()):
            pct = (count / stats['total']) * 100
            output += f"  {status}: {count} ({pct:.1f}%)\n"

        output += "\nAVERAGE DIMENSIONS:\n"
        output += f"  Outer Diameter: {stats['avg_od']:.2f} mm\n"
        output += f"  Thickness: {stats['avg_thickness']:.3f} mm\n"
        output += f"  Center Bore: {stats['avg_cb']:.2f} mm\n"

        stats_text.insert(tk.END, output)
        stats_text.config(state=tk.DISABLED)

        tk.Button(stats_window, text="Close", command=stats_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(pady=10)

    # ===== Workflow UI Methods =====

    def sync_registry_ui(self):
        """UI wrapper for syncing the program number registry"""
        # Confirm with user
        confirm = messagebox.askyesno(
            "Sync Program Number Registry",
            "This will update the program number registry with all current programs.\n\n"
            "What it does:\n"
            "  • Marks all existing program numbers as IN_USE\n"
            "  • Marks all unused numbers as AVAILABLE\n"
            "  • Takes about 0.4 seconds\n\n"
            "When to run:\n"
            "  • After scanning new folders\n"
            "  • After deleting programs\n"
            "  • Before batch rename operations\n\n"
            "Do you want to sync the registry now?",
            icon='question'
        )

        if not confirm:
            return

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Syncing Registry")
        progress_window.geometry("600x400")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)
        progress_window.grab_set()

        tk.Label(progress_window, text="🔄 Syncing Program Number Registry...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        # Log text
        log_frame = tk.Frame(progress_window, bg=self.bg_color)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        log_scroll = ttk.Scrollbar(log_frame)
        log_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        log_text = tk.Text(log_frame, height=20, yscrollcommand=log_scroll.set,
                          bg="#2B2B2B", fg="#FFFFFF", font=("Consolas", 9))
        log_scroll.config(command=log_text.yview)
        log_text.pack(fill=tk.BOTH, expand=True)

        def log(message):
            try:
                if log_text.winfo_exists():
                    log_text.insert(tk.END, message + "\n")
                    log_text.see(tk.END)
                    progress_window.update()
            except tk.TclError:
                pass

        # Run sync
        try:
            log("Starting registry sync...")
            log("-" * 60)

            stats = self.populate_program_registry()

            if stats:
                log("-" * 60)
                log("✅ REGISTRY SYNC COMPLETE")
                log(f"Total numbers: {stats['total_generated']:,}")
                log(f"In use: {stats['in_use']:,}")
                log(f"Available: {stats['available']:,}")
                log(f"Duplicates: {stats['duplicates']}")
                log("")
                log("Registry is now up to date!")

                # Add close button
                tk.Button(progress_window, text="Close",
                         command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color,
                         font=("Arial", 10, "bold")).pack(pady=10)

                messagebox.showinfo(
                    "Sync Complete",
                    f"Registry synced successfully!\n\n"
                    f"In use: {stats['in_use']:,}\n"
                    f"Available: {stats['available']:,}\n"
                    f"Total: {stats['total_generated']:,}"
                )
            else:
                log("❌ Sync failed!")
                tk.Button(progress_window, text="Close",
                         command=progress_window.destroy,
                         bg=self.button_bg, fg=self.fg_color,
                         font=("Arial", 10, "bold")).pack(pady=10)

        except Exception as e:
            log(f"❌ Error: {str(e)}")
            tk.Button(progress_window, text="Close",
                     command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold")).pack(pady=10)
            messagebox.showerror("Sync Error", f"Failed to sync registry:\n{str(e)}")

    def detect_round_sizes_ui(self):
        """UI wrapper for detecting round sizes in all programs"""
        # Confirm with user
        confirm = messagebox.askyesno(
            "Detect Round Sizes",
            "This will detect round sizes for all programs in the database.\n\n"
            "Detection methods (in priority order):\n"
            "  1. Title - looks for patterns like '6.25 OD', '10.5 rnd'\n"
            "  2. G-code - uses ob_from_gcode field\n"
            "  3. Dimensions - uses outer_diameter field\n\n"
            "This will update the database with:\n"
            "  • round_size\n"
            "  • round_size_confidence (HIGH/MEDIUM/LOW)\n"
            "  • round_size_source (title/gcode/dimension)\n"
            "  • in_correct_range (0 or 1)\n\n"
            "Do you want to detect round sizes now?",
            icon='question'
        )

        if not confirm:
            return

        # Create progress window
        progress_window = tk.Toplevel(self.root)
        progress_window.title("Detecting Round Sizes")
        progress_window.geometry("700x500")
        progress_window.configure(bg=self.bg_color)
        progress_window.transient(self.root)
        progress_window.grab_set()

        tk.Label(progress_window, text="🎯 Detecting Round Sizes...",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        # Progress bar
        progress_var = tk.DoubleVar()
        progress_bar = ttk.Progressbar(progress_window, variable=progress_var,
                                      maximum=100, length=600)
        progress_bar.pack(pady=10, padx=20)

        # Status label
        status_label = tk.Label(progress_window, text="Starting...",
                               bg=self.bg_color, fg=self.fg_color,
                               font=("Arial", 10))
        status_label.pack(pady=5)

        # Log text
        log_frame = tk.Frame(progress_window, bg=self.bg_color)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        log_scroll = ttk.Scrollbar(log_frame)
        log_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        log_text = tk.Text(log_frame, height=20, yscrollcommand=log_scroll.set,
                          bg="#2B2B2B", fg="#FFFFFF", font=("Consolas", 9))
        log_scroll.config(command=log_text.yview)
        log_text.pack(fill=tk.BOTH, expand=True)

        def log(message):
            try:
                if log_text.winfo_exists():
                    log_text.insert(tk.END, message + "\n")
                    log_text.see(tk.END)
                    progress_window.update()
            except tk.TclError:
                pass

        # Run detection
        try:
            import time
            start_time = time.time()

            log("Fetching all programs...")
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT program_number, title, ob_from_gcode, outer_diameter FROM programs")
            programs = cursor.fetchall()

            total = len(programs)
            log(f"Found {total:,} programs to process")
            log("-" * 60)

            results = {
                'processed': 0,
                'detected_title': 0,
                'detected_gcode': 0,
                'detected_dimension': 0,
                'manual_needed': 0,
                'in_correct_range': 0,
                'out_of_range': 0,
                'errors': 0
            }

            for i, (program_number, title, ob_from_gcode, outer_diameter) in enumerate(programs):
                try:
                    # Update progress
                    if i % 100 == 0:
                        progress_var.set((i / total) * 100)
                        status_label.config(text=f"Processing {i+1}/{total}: {program_number}")
                        progress_window.update()

                    # Detect round size using priority order
                    round_size = None
                    confidence = 'NONE'
                    source = 'MANUAL'

                    # Method 1: Title
                    if title:
                        title_match = self.detect_round_size_from_title(title)
                        if title_match:
                            round_size = title_match
                            confidence = 'HIGH'
                            source = 'title'
                            results['detected_title'] += 1

                    # Method 2: G-code (if title didn't work)
                    if not round_size and ob_from_gcode:
                        if 5.0 <= ob_from_gcode <= 15.0:
                            round_size = ob_from_gcode
                            confidence = 'MEDIUM'
                            source = 'gcode'
                            results['detected_gcode'] += 1

                    # Method 3: Dimensions (if others didn't work)
                    if not round_size and outer_diameter:
                        if 5.0 <= outer_diameter <= 15.0:
                            round_size = outer_diameter
                            confidence = 'LOW'
                            source = 'dimension'
                            results['detected_dimension'] += 1

                    # Check if in correct range
                    in_correct_range = 1 if round_size and self.is_in_correct_range(program_number, round_size) else 0

                    if not round_size:
                        results['manual_needed'] += 1
                    elif in_correct_range:
                        results['in_correct_range'] += 1
                    else:
                        results['out_of_range'] += 1

                    # Update database
                    cursor.execute("""
                        UPDATE programs
                        SET round_size = ?,
                            round_size_confidence = ?,
                            round_size_source = ?,
                            in_correct_range = ?
                        WHERE program_number = ?
                    """, (round_size, confidence, source, in_correct_range, program_number))

                    results['processed'] += 1

                except Exception as e:
                    results['errors'] += 1
                    if results['errors'] <= 5:  # Only log first 5 errors
                        log(f"Error processing {program_number}: {str(e)}")

            conn.commit()
            conn.close()

            elapsed = time.time() - start_time

            # Show results
            progress_var.set(100)
            status_label.config(text="Complete!")
            log("-" * 60)
            log("✅ DETECTION COMPLETE")
            log(f"Total processed: {results['processed']:,}")
            log(f"Detected from title: {results['detected_title']:,} ({results['detected_title']/total*100:.1f}%)")
            log(f"Detected from G-code: {results['detected_gcode']:,} ({results['detected_gcode']/total*100:.1f}%)")
            log(f"Detected from dimensions: {results['detected_dimension']:,} ({results['detected_dimension']/total*100:.1f}%)")
            log(f"Manual input needed: {results['manual_needed']:,} ({results['manual_needed']/total*100:.1f}%)")
            log("")
            log(f"In correct range: {results['in_correct_range']:,}")
            log(f"Out of range: {results['out_of_range']:,}")
            log(f"Errors: {results['errors']}")
            log(f"Time elapsed: {elapsed:.2f} seconds")

            # Add close button
            tk.Button(progress_window, text="Close",
                     command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold")).pack(pady=10)

            messagebox.showinfo(
                "Detection Complete",
                f"Round size detection completed!\n\n"
                f"Detected: {results['detected_title'] + results['detected_gcode'] + results['detected_dimension']:,}\n"
                f"Manual needed: {results['manual_needed']:,}\n"
                f"Out of range: {results['out_of_range']:,}\n\n"
                f"Time: {elapsed:.2f} seconds"
            )

            # Refresh the view to show updated data
            self.refresh_results()

        except Exception as e:
            log(f"❌ Error: {str(e)}")
            tk.Button(progress_window, text="Close",
                     command=progress_window.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold")).pack(pady=10)
            messagebox.showerror("Detection Error", f"Failed to detect round sizes:\n{str(e)}")

    def show_round_size_stats(self):
        """Show statistics about round size detection"""
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            cursor = conn.cursor()

            # Get overall stats
            cursor.execute("""
                SELECT
                    COUNT(*) as total,
                    SUM(CASE WHEN round_size IS NOT NULL THEN 1 ELSE 0 END) as detected,
                    SUM(CASE WHEN round_size IS NULL THEN 1 ELSE 0 END) as not_detected,
                    SUM(CASE WHEN in_correct_range = 1 THEN 1 ELSE 0 END) as in_range,
                    SUM(CASE WHEN in_correct_range = 0 AND round_size IS NOT NULL THEN 1 ELSE 0 END) as out_of_range
                FROM programs
            """)
            overall = cursor.fetchone()

            # Get stats by source
            cursor.execute("""
                SELECT round_size_source, COUNT(*) as count
                FROM programs
                WHERE round_size IS NOT NULL
                GROUP BY round_size_source
            """)
            by_source = cursor.fetchall()

            # Get stats by round size
            cursor.execute("""
                SELECT
                    round_size,
                    COUNT(*) as count,
                    SUM(CASE WHEN in_correct_range = 1 THEN 1 ELSE 0 END) as in_range,
                    SUM(CASE WHEN in_correct_range = 0 THEN 1 ELSE 0 END) as out_of_range
                FROM programs
                WHERE round_size IS NOT NULL
                GROUP BY round_size
                ORDER BY round_size
            """)
            by_size = cursor.fetchall()

            conn.close()

            # Create window
            stats_window = tk.Toplevel(self.root)
            stats_window.title("Round Size Statistics")
            stats_window.geometry("800x700")
            stats_window.configure(bg=self.bg_color)

            tk.Label(stats_window, text="📊 Round Size Detection Statistics",
                    bg=self.bg_color, fg="#9B59B6",
                    font=("Arial", 14, "bold")).pack(pady=10)

            # Create notebook for tabs
            notebook = ttk.Notebook(stats_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            # Tab 1: Overall Stats
            overall_frame = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(overall_frame, text="Overall")

            total, detected, not_detected, in_range, out_of_range = overall

            stats_text = f"""
Total Programs: {total:,}

Detection Results:
  ✅ Detected: {detected:,} ({detected/total*100:.1f}%)
  ❌ Not detected: {not_detected:,} ({not_detected/total*100:.1f}%)

Range Validation:
  ✅ In correct range: {in_range:,} ({in_range/total*100:.1f}%)
  ⚠️ Out of range: {out_of_range:,} ({out_of_range/total*100:.1f}%)
  ❓ No round size: {not_detected:,}
"""

            tk.Label(overall_frame, text=stats_text,
                    bg=self.bg_color, fg=self.fg_color,
                    font=("Consolas", 11), justify=tk.LEFT).pack(pady=20, padx=20)

            # Tab 2: By Source
            source_frame = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(source_frame, text="By Source")

            source_text = "Detection Sources:\n\n"
            for source, count in by_source:
                source_text += f"  {source or 'MANUAL'}: {count:,}\n"

            tk.Label(source_frame, text=source_text,
                    bg=self.bg_color, fg=self.fg_color,
                    font=("Consolas", 11), justify=tk.LEFT).pack(pady=20, padx=20)

            # Tab 3: By Round Size
            size_frame = tk.Frame(notebook, bg=self.bg_color)
            notebook.add(size_frame, text="By Round Size")

            # Create treeview
            tree_frame = tk.Frame(size_frame, bg=self.bg_color)
            tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

            vsb = ttk.Scrollbar(tree_frame, orient="vertical")
            vsb.pack(side=tk.RIGHT, fill=tk.Y)

            columns = ("Round Size", "Total", "In Range", "Out of Range", "% Out of Range")
            tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                               yscrollcommand=vsb.set)
            vsb.config(command=tree.yview)

            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)

            for size, count, in_range, out in by_size:
                pct_out = (out / count * 100) if count > 0 else 0
                tree.insert("", tk.END, values=(
                    f"{size:.2f}\"",
                    count,
                    in_range,
                    out,
                    f"{pct_out:.1f}%"
                ))

            tree.pack(fill=tk.BOTH, expand=True)

            tk.Button(stats_window, text="Close",
                     command=stats_window.destroy,
                     bg=self.button_bg, fg=self.fg_color,
                     font=("Arial", 10, "bold")).pack(pady=10)

        except Exception as e:
            messagebox.showerror("Statistics Error", f"Failed to get statistics:\n{str(e)}")

    def show_workflow_wizard(self):
        """
        Interactive Workflow Wizard for different database operations.
        Provides step-by-step guidance for:
        1. Fresh database from new folder
        2. Adding files to existing database
        3. Archive current and start fresh
        4. Export and backup workflows
        """
        wizard = tk.Toplevel(self.root)
        wizard.title("Workflow Wizard")
        wizard.geometry("700x600")
        wizard.configure(bg=self.bg_color)
        wizard.transient(self.root)
        wizard.grab_set()

        # Header
        header = tk.Frame(wizard, bg="#2196F3", height=60)
        header.pack(fill=tk.X)
        header.pack_propagate(False)

        tk.Label(header, text="🧙 Workflow Wizard",
                font=("Arial", 18, "bold"),
                bg="#2196F3", fg="white").pack(pady=15)

        # Main content
        content = tk.Frame(wizard, bg=self.bg_color)
        content.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

        tk.Label(content, text="What would you like to do?",
                font=("Arial", 14, "bold"),
                bg=self.bg_color, fg=self.fg_color).pack(pady=(0, 20))

        # Workflow options
        workflows = [
            {
                "title": "🆕 Fresh Start - Scan New Folder",
                "desc": "Create a new database from scratch by scanning a folder of G-code files.\nBest for: First-time setup or starting with a new file collection.",
                "color": "#4CAF50",
                "command": lambda: self.run_workflow_fresh_start(wizard)
            },
            {
                "title": "➕ Add to Existing Database",
                "desc": "Scan a folder and add new files to your current database.\nBest for: Adding new programs without losing existing data.",
                "color": "#2196F3",
                "command": lambda: self.run_workflow_add_files(wizard)
            },
            {
                "title": "📦 Archive & Start Fresh",
                "desc": "Save current database as a profile, then clear it for a fresh scan.\nBest for: Seasonal cleanup or reorganization.",
                "color": "#FF9800",
                "command": lambda: self.run_workflow_archive_fresh(wizard)
            },
            {
                "title": "💾 Export & Backup",
                "desc": "Export database to Excel/CSV and create backups.\nBest for: Data preservation and reporting.",
                "color": "#9C27B0",
                "command": lambda: self.run_workflow_export_backup(wizard)
            },
            {
                "title": "🔄 Rescan Repository",
                "desc": "Re-parse all files in the repository folder to update dimensions.\nBest for: After parser updates or to refresh validation.",
                "color": "#00BCD4",
                "command": lambda: self.run_workflow_rescan(wizard)
            }
        ]

        for wf in workflows:
            frame = tk.Frame(content, bg=self.bg_color, relief=tk.RAISED, borderwidth=1)
            frame.pack(fill=tk.X, pady=8)

            btn = tk.Button(frame, text=wf["title"],
                          font=("Arial", 12, "bold"),
                          bg=wf["color"], fg="white",
                          anchor="w", padx=15,
                          command=wf["command"])
            btn.pack(fill=tk.X, ipady=8)

            tk.Label(frame, text=wf["desc"],
                    font=("Arial", 9),
                    bg=self.bg_color, fg="#888888",
                    justify=tk.LEFT, anchor="w",
                    padx=15).pack(fill=tk.X, pady=(5, 10))

        # Close button
        tk.Button(content, text="Close", command=wizard.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=15).pack(pady=20)

    def run_workflow_fresh_start(self, wizard):
        """Workflow: Fresh database from new folder"""
        wizard.destroy()

        result = messagebox.askyesnocancel(
            "Fresh Start Workflow",
            "This workflow will:\n\n"
            "1. Clear the current database\n"
            "2. Ask you to select a folder to scan\n"
            "3. Import all G-code files found\n"
            "4. Sync the registry and detect round sizes\n\n"
            "Do you want to save the current database first?\n\n"
            "Yes = Save profile first, then proceed\n"
            "No = Clear and proceed without saving\n"
            "Cancel = Abort workflow"
        )

        if result is None:  # Cancel
            return

        if result:  # Yes - save first
            self.save_database_profile()

        # Clear database
        confirm = messagebox.askyesno(
            "Confirm Clear",
            "Are you sure you want to clear the database?\n\n"
            "This will delete all current records."
        )

        if not confirm:
            return

        # Clear the database
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM programs")
            conn.commit()
            conn.close()
            self.refresh_results()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to clear database:\n{str(e)}")
            return

        # Scan folder
        self.scan_folder()

        # After scan, offer to sync registry
        if messagebox.askyesno("Sync Registry?",
                              "Scan complete! Would you like to sync the program registry?"):
            self.sync_registry_ui()

        # Detect round sizes
        if messagebox.askyesno("Detect Round Sizes?",
                              "Would you like to auto-detect round sizes?"):
            self.detect_round_sizes_ui()

        messagebox.showinfo("Complete", "Fresh start workflow complete!")

    def run_workflow_add_files(self, wizard):
        """Workflow: Add files to existing database"""
        wizard.destroy()

        # Get current count
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM programs")
        before_count = cursor.fetchone()[0]
        conn.close()

        messagebox.showinfo(
            "Add Files Workflow",
            f"Current database has {before_count} programs.\n\n"
            "You'll be asked to select a folder to scan.\n"
            "Only NEW files (not already in DB) will be added."
        )

        # Use scan_for_new_files which only adds new ones
        self.scan_for_new_files()

        # Get new count
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM programs")
        after_count = cursor.fetchone()[0]
        conn.close()

        added = after_count - before_count
        messagebox.showinfo("Complete",
                           f"Added {added} new files.\n"
                           f"Total programs: {after_count}")

    def run_workflow_archive_fresh(self, wizard):
        """Workflow: Archive current database and start fresh"""
        wizard.destroy()

        # Get current stats
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM programs")
        count = cursor.fetchone()[0]
        conn.close()

        if count == 0:
            messagebox.showinfo("Empty Database",
                              "Database is already empty. Use 'Fresh Start' to scan files.")
            return

        confirm = messagebox.askyesno(
            "Archive & Fresh Start",
            f"This will:\n\n"
            f"1. Save current database ({count} programs) as a profile\n"
            f"2. Export to Excel as backup\n"
            f"3. Clear the database\n"
            f"4. Let you scan a new folder\n\n"
            f"Continue?"
        )

        if not confirm:
            return

        # Step 1: Save profile
        self.save_database_profile()

        # Step 2: Export CSV
        if messagebox.askyesno("Export Excel?",
                              "Would you also like to export to Excel/CSV?"):
            self.export_csv()

        # Step 3: Clear database
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("DELETE FROM programs")
            conn.commit()
            conn.close()
            self.refresh_results()
            messagebox.showinfo("Cleared", "Database cleared successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to clear: {str(e)}")
            return

        # Step 4: Ask to scan new folder
        if messagebox.askyesno("Scan New Folder?",
                              "Database is now empty.\n\nWould you like to scan a new folder?"):
            self.scan_folder()

    def run_workflow_export_backup(self, wizard):
        """Workflow: Export and backup options"""
        wizard.destroy()

        # Create export options window
        export_win = tk.Toplevel(self.root)
        export_win.title("Export & Backup Options")
        export_win.geometry("400x350")
        export_win.configure(bg=self.bg_color)
        export_win.transient(self.root)

        tk.Label(export_win, text="Export & Backup Options",
                font=("Arial", 14, "bold"),
                bg=self.bg_color, fg=self.fg_color).pack(pady=15)

        options = [
            ("📊 Export to Excel/CSV", self.export_csv),
            ("📈 Export to Google Sheets", self.export_google_sheets),
            ("💾 Create Database Backup", self.create_manual_backup),
            ("📦 Create Full Backup (DB + Files)", self.create_full_backup),
            ("💾 Save as Named Profile", self.save_database_profile),
            ("📋 Export Unused Numbers", self.export_unused_numbers),
        ]

        for text, cmd in options:
            def make_cmd(c, w):
                return lambda: (c(), None)

            tk.Button(export_win, text=text,
                     font=("Arial", 10),
                     bg=self.button_bg, fg=self.fg_color,
                     anchor="w", padx=20,
                     command=cmd).pack(fill=tk.X, padx=20, pady=5, ipady=5)

        tk.Button(export_win, text="Close", command=export_win.destroy,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10), width=15).pack(pady=20)

    def run_workflow_rescan(self, wizard):
        """Workflow: Rescan repository"""
        wizard.destroy()

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM programs WHERE is_managed = 1")
        repo_count = cursor.fetchone()[0]
        conn.close()

        if repo_count == 0:
            messagebox.showinfo("No Repository Files",
                              "No files in repository to rescan.\n\n"
                              "Use 'Add to Repository' from External tab first.")
            return

        confirm = messagebox.askyesno(
            "Rescan Repository",
            f"This will re-parse all {repo_count} files in the repository\n"
            f"to update dimensions and validation.\n\n"
            f"This is useful after parser updates.\n\n"
            f"Continue?"
        )

        if confirm:
            self.refresh_repository_scan()

    def show_workflow_guide(self):
        """Show the workflow guide"""
        try:
            # Try to open RECOMMENDED_WORKFLOW.md or DETAILED_USER_WORKFLOW.md
            workflow_files = [
                "RECOMMENDED_WORKFLOW.md",
                "DETAILED_USER_WORKFLOW.md",
                "README.md"
            ]

            for filename in workflow_files:
                if os.path.exists(filename):
                    # Open in default markdown viewer or text editor
                    if os.name == 'nt':  # Windows
                        os.startfile(filename)
                    else:  # macOS and Linux
                        import subprocess
                        subprocess.call(['open' if sys.platform == 'darwin' else 'xdg-open', filename])
                    return

            # If no file found, show a basic guide
            messagebox.showinfo(
                "Workflow Guide",
                "Recommended Workflow:\n\n"
                "1. Scan Folder (Files tab)\n"
                "   → Import G-code files from external folders\n\n"
                "2. Sync Registry (Workflow tab)\n"
                "   → Update program number registry\n\n"
                "3. Detect Round Sizes (Workflow tab)\n"
                "   → Auto-detect round sizes from titles/G-code\n\n"
                "4. Add to Repository (External tab)\n"
                "   → Move files to managed repository\n\n"
                "5. Resolve Out-of-Range (Repository tab)\n"
                "   → Batch rename programs to correct ranges\n\n"
                "6. Manage Duplicates (Repository tab)\n"
                "   → Clean up duplicate programs\n\n"
                "See RECOMMENDED_WORKFLOW.md for detailed guide."
            )

        except Exception as e:
            messagebox.showerror("Error", f"Failed to open workflow guide:\n{str(e)}")


class EditEntryWindow:
    """Window for adding/editing entries"""
    def __init__(self, parent, program_number, callback):
        self.parent = parent
        self.program_number = program_number
        self.callback = callback
        
        self.window = tk.Toplevel(parent.root)
        self.window.title("Edit Entry" if program_number else "Add Entry")
        self.window.geometry("600x700")
        self.window.configure(bg=parent.bg_color)
        
        # Load existing data if editing
        self.record = None
        if program_number:
            conn = sqlite3.connect(parent.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM programs WHERE program_number = ?", (program_number,))
            self.record = cursor.fetchone()
            conn.close()
        
        self.create_form()
        
    def create_form(self):
        """Create entry form"""
        # Container
        container = tk.Frame(self.window, bg=self.parent.bg_color)
        container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        row = 0
        
        # Program Number
        tk.Label(container, text="Program Number:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
        self.entry_program = tk.Entry(container, bg=self.parent.input_bg, 
                                     fg=self.parent.fg_color, width=30)
        self.entry_program.grid(row=row, column=1, sticky="ew", pady=5)
        if self.record:
            self.entry_program.insert(0, self.record[0])
            self.entry_program.config(state="readonly")  # Can't change primary key
        row += 1
        
        # Spacer Type
        tk.Label(container, text="Spacer Type:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
        self.entry_type = ttk.Combobox(container, values=self.parent.config["spacer_types"], 
                                      state="readonly", width=28)
        self.entry_type.grid(row=row, column=1, sticky="ew", pady=5)
        if self.record and self.record[1]:
            self.entry_type.set(self.record[1])
        row += 1
        
        # Dimensions
        dims = [
            ("Outer Diameter:", 2, "outer_diameter"),
            ("Thickness:", 3, "thickness"),
            ("Center Bore:", 4, "center_bore"),
            ("Hub Height:", 5, "hub_height"),
            ("Hub Diameter:", 6, "hub_diameter"),
            ("Counter Bore Diameter:", 7, "cb_diameter"),
            ("Counter Bore Depth:", 8, "cb_depth"),
        ]
        
        self.entries = {}
        for label, idx, key in dims:
            tk.Label(container, text=label, bg=self.parent.bg_color, 
                    fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
            entry = tk.Entry(container, bg=self.parent.input_bg, 
                           fg=self.parent.fg_color, width=30)
            entry.grid(row=row, column=1, sticky="ew", pady=5)
            if self.record and self.record[idx]:
                entry.insert(0, str(self.record[idx]))
            self.entries[key] = entry
            row += 1
        
        # Paired Program
        tk.Label(container, text="Paired Program:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
        self.entry_paired = tk.Entry(container, bg=self.parent.input_bg, 
                                     fg=self.parent.fg_color, width=30)
        self.entry_paired.grid(row=row, column=1, sticky="ew", pady=5)
        if self.record and self.record[9]:
            self.entry_paired.insert(0, self.record[9])
        row += 1
        
        # Material
        tk.Label(container, text="Material:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
        self.entry_material = ttk.Combobox(container, 
                                          values=self.parent.config["material_list"], 
                                          state="readonly", width=28)
        self.entry_material.grid(row=row, column=1, sticky="ew", pady=5)
        if self.record and self.record[10]:
            self.entry_material.set(self.record[10])
        row += 1
        
        # Notes
        tk.Label(container, text="Notes:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="nw", pady=5)
        self.entry_notes = tk.Text(container, bg=self.parent.input_bg, 
                                  fg=self.parent.fg_color, width=30, height=4)
        self.entry_notes.grid(row=row, column=1, sticky="ew", pady=5)
        if self.record and self.record[11]:
            self.entry_notes.insert("1.0", self.record[11])
        row += 1
        
        # File Path
        tk.Label(container, text="File Path:", bg=self.parent.bg_color, 
                fg=self.parent.fg_color).grid(row=row, column=0, sticky="w", pady=5)
        path_frame = tk.Frame(container, bg=self.parent.bg_color)
        path_frame.grid(row=row, column=1, sticky="ew", pady=5)
        
        self.entry_filepath = tk.Entry(path_frame, bg=self.parent.input_bg, 
                                      fg=self.parent.fg_color)
        self.entry_filepath.pack(side=tk.LEFT, fill=tk.X, expand=True)
        if self.record and self.record[14]:
            self.entry_filepath.insert(0, self.record[14])
        
        btn_browse = tk.Button(path_frame, text="Browse", command=self.browse_file,
                              bg=self.parent.button_bg, fg=self.parent.fg_color)
        btn_browse.pack(side=tk.LEFT, padx=5)
        row += 1
        
        # Buttons
        button_frame = tk.Frame(container, bg=self.parent.bg_color)
        button_frame.grid(row=row, column=0, columnspan=2, pady=20)
        
        btn_save = tk.Button(button_frame, text="💾 Save", command=self.save_entry,
                            bg=self.parent.accent_color, fg=self.parent.fg_color,
                            font=("Arial", 10, "bold"), width=15)
        btn_save.pack(side=tk.LEFT, padx=5)
        
        btn_cancel = tk.Button(button_frame, text="❌ Cancel", command=self.window.destroy,
                              bg=self.parent.button_bg, fg=self.parent.fg_color,
                              font=("Arial", 10, "bold"), width=15)
        btn_cancel.pack(side=tk.LEFT, padx=5)
        
        container.columnconfigure(1, weight=1)
        
    def browse_file(self):
        """Browse for file"""
        filepath = filedialog.askopenfilename(
            title="Select G-Code File",
            filetypes=[("G-Code files", "*.nc *.gcode *.cnc"), ("All files", "*.*")]
        )
        if filepath:
            self.entry_filepath.delete(0, tk.END)
            self.entry_filepath.insert(0, filepath)
            
    def save_entry(self):
        """Save entry to database"""
        # Validate
        program_number = self.entry_program.get().strip()
        if not program_number:
            messagebox.showerror("Error", "Program number is required")
            return
        
        spacer_type = self.entry_type.get()
        if not spacer_type:
            messagebox.showerror("Error", "Spacer type is required")
            return
        
        # Get values
        def get_float(entry):
            try:
                val = entry.get().strip()
                return float(val) if val else None
            except:
                return None
        
        outer_diameter = get_float(self.entries["outer_diameter"])
        thickness = get_float(self.entries["thickness"])
        center_bore = get_float(self.entries["center_bore"])
        hub_height = get_float(self.entries["hub_height"])
        hub_diameter = get_float(self.entries["hub_diameter"])
        cb_diameter = get_float(self.entries["cb_diameter"])
        cb_depth = get_float(self.entries["cb_depth"])
        
        paired_program = self.entry_paired.get().strip() or None
        material = self.entry_material.get() or None
        notes = self.entry_notes.get("1.0", tk.END).strip() or None
        file_path = self.entry_filepath.get().strip() or None
        
        # Save to database
        conn = sqlite3.connect(self.parent.db_path)
        cursor = conn.cursor()
        
        try:
            if self.program_number:  # Update
                cursor.execute('''
                    UPDATE programs SET
                        spacer_type = ?, outer_diameter = ?, thickness = ?,
                        center_bore = ?, hub_height = ?, hub_diameter = ?,
                        counter_bore_diameter = ?, counter_bore_depth = ?,
                        paired_program = ?, material = ?, notes = ?,
                        last_modified = ?, file_path = ?
                    WHERE program_number = ?
                ''', (spacer_type, outer_diameter, thickness, center_bore,
                     hub_height, hub_diameter, cb_diameter, cb_depth,
                     paired_program, material, notes, 
                     datetime.now().isoformat(), file_path, program_number))
            else:  # Insert
                cursor.execute('''
                    INSERT INTO programs VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (program_number, None,  # title
                     spacer_type, outer_diameter, thickness, None,  # thickness_display
                     center_bore, hub_height, hub_diameter, cb_diameter, cb_depth,
                     paired_program, material, notes, datetime.now().isoformat(),
                     datetime.now().isoformat(), file_path,
                     None, None, None, None, None,  # detection_confidence, detection_method, validation_status, validation_issues, validation_warnings
                     None, None,  # cb_from_gcode, ob_from_gcode
                     None, None, None,  # bore_warnings, dimensional_issues, lathe
                     None, None, None,  # feasibility_status, feasibility_issues, feasibility_warnings (CREATE TABLE positions 28-30)
                     None, None,  # crash_issues, crash_warnings (CREATE TABLE positions 31-32)
                     datetime.now().isoformat(),  # date_imported (CREATE TABLE position 33)
                     None, None, None,  # duplicate_type, parent_file, duplicate_group
                     1, self.parent.current_username, 0,  # current_version, modified_by, is_managed
                     None, None, None, None,  # round_size, round_size_confidence, round_size_source, in_correct_range
                     None, None, None,  # legacy_names, last_renamed_date, rename_reason
                     None, None, None, None, None, None,  # tools_used, tool_sequence, tool_validation_status, tool_validation_issues, safety_blocks_status, safety_blocks_issues
                     None,  # content_hash
                     None, None,  # tool_home_status, tool_home_issues
                     None, None,  # hub_height_display, counter_bore_depth_display
                     0, None))  # is_deleted, deleted_date
            
            conn.commit()
            messagebox.showinfo("Success", "Entry saved successfully")
            self.window.destroy()
            self.callback()
            
        except sqlite3.IntegrityError:
            messagebox.showerror("Error", "Program number already exists")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save: {e}")
        finally:
            conn.close()


class StandardsReferenceWindow:
    """Window to view verification standards reference"""
    def __init__(self, root, parent):
        self.root = root
        self.parent = parent

        self.window = tk.Toplevel(root)
        self.window.title("📋 Verification Standards Reference")
        self.window.geometry("900x700")
        self.window.configure(bg=parent.bg_color)

        self.create_view()

    def create_view(self):
        """Create standards reference view"""
        # Title
        title_label = tk.Label(self.window,
                              text="G-Code Program Verification Standards",
                              bg=self.parent.bg_color, fg=self.parent.fg_color,
                              font=("Arial", 14, "bold"))
        title_label.pack(pady=10)

        # Subtitle
        subtitle_label = tk.Label(self.window,
                                 text="Physical constraints and compatibility rules for each lathe",
                                 bg=self.parent.bg_color, fg="#888888",
                                 font=("Arial", 10))
        subtitle_label.pack(pady=5)

        # Create notebook for tabs
        notebook = ttk.Notebook(self.window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Import verification standards
        import verification_standards as vs

        # Create tab for each lathe
        for lathe_name in ['L1', 'L2', 'L3', 'L2/L3']:
            standards = vs.get_lathe_standards(lathe_name)
            if standards:
                tab = tk.Frame(notebook, bg=self.parent.input_bg)
                notebook.add(tab, text=f"  {lathe_name}  ")
                self.create_lathe_tab(tab, lathe_name, standards)

        # Close button
        btn_frame = tk.Frame(self.window, bg=self.parent.bg_color)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(btn_frame, text="Close", command=self.window.destroy,
                 bg=self.parent.button_bg, fg=self.parent.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.RIGHT)

        tk.Label(btn_frame,
                text="📄 See VERIFICATION_STANDARDS.md for detailed documentation",
                bg=self.parent.bg_color, fg="#888888",
                font=("Arial", 9)).pack(side=tk.LEFT)

    def create_lathe_tab(self, parent, lathe_name, standards):
        """Create content for a lathe standards tab"""
        # Scrolled text widget
        text = scrolledtext.ScrolledText(parent, bg=self.parent.input_bg,
                                        fg=self.parent.fg_color,
                                        font=("Courier", 9), wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Format standards information
        text.insert(tk.END, "="*80 + "\n")
        text.insert(tk.END, f"  {standards['name']} ({lathe_name})\n")
        text.insert(tk.END, "="*80 + "\n\n")

        # Physical Specifications
        text.insert(tk.END, "PHYSICAL SPECIFICATIONS\n")
        text.insert(tk.END, "-" * 40 + "\n")
        text.insert(tk.END, f"Chuck Capacity:         {standards['chuck_capacity']}\"\n")
        text.insert(tk.END, f"Z Travel Limit:         {standards['z_travel_limit']}\" (absolute minimum)\n")
        text.insert(tk.END, f"Z Home Position:        {standards['z_home_position']}\" (typical)\n")
        text.insert(tk.END, f"Drill Depth Limit:      {standards['drill_depth_limit']}\" (single operation)\n")
        text.insert(tk.END, f"Min Z Clearance (G53):  {standards['z_clearance_before_g53']}\"\n\n")

        # Supported Round Sizes
        text.insert(tk.END, "SUPPORTED ROUND SIZES\n")
        text.insert(tk.END, "-" * 40 + "\n")
        sizes_str = ', '.join([f"{s}\"" for s in standards['round_sizes']])
        text.insert(tk.END, f"{sizes_str}\n\n")

        # Thickness Range
        thickness_range = standards['thickness_range']
        text.insert(tk.END, "THICKNESS RANGE\n")
        text.insert(tk.END, "-" * 40 + "\n")
        text.insert(tk.END, f"Minimum:  {thickness_range['min']}\"\n")
        text.insert(tk.END, f"Maximum:  {thickness_range['max']}\"\n")
        text.insert(tk.END, f"P-Codes:  {thickness_range['pcodes']}\n\n")

        # Piece Type Compatibility
        text.insert(tk.END, "PIECE TYPE COMPATIBILITY\n")
        text.insert(tk.END, "=" * 80 + "\n\n")

        for piece_type, rules in standards['piece_types'].items():
            status_icon = "✅" if rules['allowed'] else "❌"
            text.insert(tk.END, f"{status_icon} {piece_type.upper().replace('_', ' ')}\n")
            text.insert(tk.END, f"   Description: {rules.get('description', 'N/A')}\n")

            min_t, max_t = rules['thickness_limits']
            text.insert(tk.END, f"   Thickness:   {min_t}\" - {max_t}\"\n")

            if 'hub_height_max' in rules:
                text.insert(tk.END, f"   Hub Height:  Max {rules['hub_height_max']}\"\n")
            if 'hub_height_typical' in rules:
                text.insert(tk.END, f"   Hub Height:  Typical {rules['hub_height_typical']}\"\n")
            if 'shelf_depth_range' in rules:
                shelf_min, shelf_max = rules['shelf_depth_range']
                text.insert(tk.END, f"   Shelf Depth: {shelf_min}\" - {shelf_max}\"\n")

            if rules.get('special_rules'):
                text.insert(tk.END, f"   Special:     {', '.join(rules['special_rules'])}\n")

            text.insert(tk.END, "\n")

        # Tool Home Rules
        text.insert(tk.END, "\nTOOL HOME POSITION RULES\n")
        text.insert(tk.END, "=" * 80 + "\n\n")
        text.insert(tk.END, "Expected Z position varies by part thickness:\n\n")

        for rule_key, rule_data in standards['tool_home_rules'].items():
            text.insert(tk.END, f"  • {rule_data['description']}:\n")
            text.insert(tk.END, f"      Expected Z: {rule_data['expected_z']}\n")
            text.insert(tk.END, f"      Min Safe Z: {rule_data['min_safe_z']}\n\n")

        # Safety Notes
        text.insert(tk.END, "\n" + "="*80 + "\n")
        text.insert(tk.END, "SAFETY NOTES\n")
        text.insert(tk.END, "="*80 + "\n\n")
        text.insert(tk.END, "⚠️  Z Clearance: Tool must be at Z ≥ 0.1 before G53 tool home\n")
        text.insert(tk.END, "⚠️  Drill Depth: Parts exceeding 4.15\" total height require OP2 flip\n")
        text.insert(tk.END, "⚠️  Chuck Capacity: Programs with OD exceeding capacity CANNOT run\n")
        text.insert(tk.END, "⚠️  Round Sizes: Only listed sizes are available for this lathe\n\n")

        # Validation Severity
        text.insert(tk.END, "VALIDATION SEVERITY LEVELS\n")
        text.insert(tk.END, "-" * 40 + "\n")
        text.insert(tk.END, "❌ CRITICAL:  Physical impossibility - program blocked\n")
        text.insert(tk.END, "⚠️  WARNING:   Potential issue - requires attention\n")
        text.insert(tk.END, "✅ PASS:      Meets all standards\n\n")

        text.config(state=tk.DISABLED)


class DetailsWindow:
    """Window to view full details of an entry"""
    def __init__(self, parent, record):
        self.parent = parent
        self.record = record
        
        self.window = tk.Toplevel(parent.root)
        self.window.title(f"Details - {record[0]}")
        self.window.geometry("500x600")
        self.window.configure(bg=parent.bg_color)
        
        self.create_view()
        
    def create_view(self):
        """Create details view"""
        # Scrolled text
        text = scrolledtext.ScrolledText(self.window, bg=self.parent.input_bg, 
                                        fg=self.parent.fg_color,
                                        font=("Courier", 10), wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Format details
        fields = [
            ("Program Number", 0),
            ("Title", 1),
            ("Spacer Type", 2),
            ("Outer Diameter", 3),
            ("Thickness", 4),
            ("Thickness Display", 5),
            ("Center Bore", 6),
            ("Hub Height", 7),
            ("Hub Diameter", 8),
            ("Counter Bore Diameter", 9),
            ("Counter Bore Depth", 10),
            ("Paired Program", 11),
            ("Material", 12),
            ("Notes", 13),
            ("Date Created", 14),
            ("Last Modified", 15),
            ("File Path", 16),
        ]

        text.insert(tk.END, "="*50 + "\n")
        text.insert(tk.END, f"  PROGRAM DETAILS - {self.record[0]}\n")
        text.insert(tk.END, "="*50 + "\n\n")

        for label, idx in fields:
            value = self.record[idx] if self.record[idx] else "-"
            text.insert(tk.END, f"{label}:\n  {value}\n\n")

        # Add validation information if available
        if len(self.record) > 18:
            text.insert(tk.END, "="*50 + "\n")
            text.insert(tk.END, "  VALIDATION RESULTS\n")
            text.insert(tk.END, "="*50 + "\n\n")

            # Detection info
            if self.record[17]:  # detection_confidence
                text.insert(tk.END, f"Detection Confidence: {self.record[17]}\n")
            if self.record[18]:  # detection_method
                text.insert(tk.END, f"Detection Method: {self.record[18]}\n")

            # Lathe assignment
            if len(self.record) > 26 and self.record[26]:  # lathe
                text.insert(tk.END, f"Lathe: {self.record[26]}\n")

            # Validation status
            status = self.record[19] if self.record[19] else "N/A"
            text.insert(tk.END, f"\nValidation Status: {status}\n")

            # If REPEAT status, show parent file information
            if status == 'REPEAT':
                text.insert(tk.END, "\n" + "="*50 + "\n")
                text.insert(tk.END, "  DUPLICATE INFORMATION\n")
                text.insert(tk.END, "="*50 + "\n\n")

                # Get parent_file and duplicate_type from record
                parent_file = self.record[28] if len(self.record) > 28 and self.record[28] else None
                duplicate_type = self.record[27] if len(self.record) > 27 and self.record[27] else None

                if duplicate_type:
                    text.insert(tk.END, f"Duplicate Type: {duplicate_type}\n")

                if parent_file:
                    text.insert(tk.END, f"Parent Program: {parent_file}\n\n")

                    # Fetch parent program details from database
                    try:
                        conn = sqlite3.connect(self.parent.db_path)
                        cursor = conn.cursor()
                        cursor.execute("""
                            SELECT program_number, title, outer_diameter, thickness, center_bore,
                                   file_path, validation_status
                            FROM programs
                            WHERE program_number = ?
                        """, (parent_file,))
                        parent_record = cursor.fetchone()
                        conn.close()

                        if parent_record:
                            text.insert(tk.END, "Parent Program Details:\n")
                            text.insert(tk.END, f"  Program: {parent_record[0]}\n")
                            if parent_record[1]:
                                text.insert(tk.END, f"  Title: {parent_record[1]}\n")
                            if parent_record[2]:
                                text.insert(tk.END, f"  OD: {parent_record[2]}in\n")
                            if parent_record[3]:
                                text.insert(tk.END, f"  Thickness: {parent_record[3]}in\n")
                            if parent_record[4]:
                                text.insert(tk.END, f"  CB: {parent_record[4]}mm\n")
                            if parent_record[5]:
                                text.insert(tk.END, f"  Location: {parent_record[5]}\n")
                            if parent_record[6]:
                                text.insert(tk.END, f"  Status: {parent_record[6]}\n")
                        else:
                            text.insert(tk.END, f"  ⚠️ Parent program not found in database\n")
                    except Exception as e:
                        text.insert(tk.END, f"  ⚠️ Error loading parent details: {e}\n")
                else:
                    text.insert(tk.END, "  ⚠️ No parent program recorded\n")

                text.insert(tk.END, "\n")
            else:
                text.insert(tk.END, "\n")

            # G-code dimensions
            if len(self.record) > 22 and self.record[22]:  # cb_from_gcode (index 22)
                text.insert(tk.END, f"CB from G-code: {self.record[22]:.1f}mm\n")
            if len(self.record) > 23 and self.record[23]:  # ob_from_gcode (index 23)
                text.insert(tk.END, f"OB from G-code: {self.record[23]:.1f}mm\n")

            # === CRASH PREVENTION (HIGHEST PRIORITY) ===
            # Get crash field indices dynamically
            try:
                conn = sqlite3.connect(self.parent.db_path)
                cursor = conn.cursor()
                cursor.execute("PRAGMA table_info(programs)")
                columns = [col[1] for col in cursor.fetchall()]
                conn.close()

                crash_issues_idx = columns.index('crash_issues') if 'crash_issues' in columns else -1
                crash_warnings_idx = columns.index('crash_warnings') if 'crash_warnings' in columns else -1
                tool_home_status_idx = columns.index('tool_home_status') if 'tool_home_status' in columns else -1
                tool_home_issues_idx = columns.index('tool_home_issues') if 'tool_home_issues' in columns else -1

                # CRASH RISKS (CRITICAL - BRIGHT RED)
                if crash_issues_idx >= 0 and len(self.record) > crash_issues_idx and self.record[crash_issues_idx]:
                    try:
                        crash_issues = json.loads(self.record[crash_issues_idx])
                    except:
                        crash_issues = [i.strip() for i in self.record[crash_issues_idx].split('|') if i.strip()]

                    if crash_issues:
                        text.insert(tk.END, "\n" + "="*50 + "\n")
                        text.insert(tk.END, "  ⛔ CRASH RISKS DETECTED ⛔\n")
                        text.insert(tk.END, "="*50 + "\n")
                        text.insert(tk.END, "CRITICAL: These patterns will cause machine crashes!\n\n")
                        for issue in crash_issues:
                            text.insert(tk.END, f"  ⛔ {issue}\n")
                        text.insert(tk.END, "\n")

                # CRASH WARNINGS (ORANGE)
                if crash_warnings_idx >= 0 and len(self.record) > crash_warnings_idx and self.record[crash_warnings_idx]:
                    try:
                        crash_warnings = json.loads(self.record[crash_warnings_idx])
                    except:
                        crash_warnings = [i.strip() for i in self.record[crash_warnings_idx].split('|') if i.strip()]

                    if crash_warnings:
                        text.insert(tk.END, "\nCRASH WARNINGS:\n")
                        for warning in crash_warnings:
                            text.insert(tk.END, f"  ⚠️  {warning}\n")

                # TOOL HOME ISSUES
                if tool_home_status_idx >= 0 and len(self.record) > tool_home_status_idx and self.record[tool_home_status_idx]:
                    tool_home_status = self.record[tool_home_status_idx]
                    if tool_home_status in ('CRITICAL', 'WARNING'):
                        if tool_home_issues_idx >= 0 and len(self.record) > tool_home_issues_idx and self.record[tool_home_issues_idx]:
                            try:
                                tool_home_issues = json.loads(self.record[tool_home_issues_idx])
                            except:
                                tool_home_issues = [i.strip() for i in self.record[tool_home_issues_idx].split('|') if i.strip()]

                            if tool_home_issues:
                                severity = "CRITICAL" if tool_home_status == "CRITICAL" else "WARNING"
                                text.insert(tk.END, f"\nTOOL HOME {severity}:\n")
                                for issue in tool_home_issues:
                                    icon = "❌" if tool_home_status == "CRITICAL" else "⚠️"
                                    text.insert(tk.END, f"  {icon} {issue}\n")

            except Exception as e:
                # Silently ignore if crash/tool_home fields don't exist yet
                pass

            # Validation issues (CRITICAL - RED)
            if self.record[20]:  # validation_issues
                try:
                    # Try JSON format first (backward compatibility)
                    issues = json.loads(self.record[20])
                except:
                    # Fall back to pipe-delimited format
                    issues = [i.strip() for i in self.record[20].split('|') if i.strip()]

                if issues:
                    text.insert(tk.END, "\nCRITICAL ISSUES:\n")
                    for issue in issues:
                        text.insert(tk.END, f"  - {issue}\n")

            # Bore warnings (ORANGE)
            if len(self.record) > 24 and self.record[24]:  # bore_warnings (index 24)
                try:
                    # Try JSON format first (backward compatibility)
                    bore_warns = json.loads(self.record[24])
                except:
                    # Fall back to pipe-delimited format
                    bore_warns = [i.strip() for i in self.record[24].split('|') if i.strip()]

                if bore_warns:
                    text.insert(tk.END, "\nBORE WARNINGS:\n")
                    for warning in bore_warns:
                        text.insert(tk.END, f"  - {warning}\n")

            # Dimensional issues (PURPLE)
            if len(self.record) > 25 and self.record[25]:  # dimensional_issues (index 25)
                try:
                    # Try JSON format first (backward compatibility)
                    dim_issues = json.loads(self.record[25])
                except:
                    # Fall back to pipe-delimited format
                    dim_issues = [i.strip() for i in self.record[25].split('|') if i.strip()]

                if dim_issues:
                    text.insert(tk.END, "\nDIMENSIONAL ISSUES:\n")
                    for issue in dim_issues:
                        text.insert(tk.END, f"  - {issue}\n")

            # Validation warnings (YELLOW)
            if self.record[21]:  # validation_warnings
                try:
                    # Try JSON format first (backward compatibility)
                    warnings = json.loads(self.record[21])
                except:
                    # Fall back to pipe-delimited format
                    warnings = [i.strip() for i in self.record[21].split('|') if i.strip()]

                if warnings:
                    # Group by keyword-derived category so each type gets
                    # its own sub-section instead of one flat list.
                    groups = {}
                    for warning in warnings:
                        cat = FileScanner._categorize_validation_warning(warning)
                        groups.setdefault(cat, []).append(warning)

                    text.insert(tk.END, "\nWARNINGS:\n")
                    for cat, cat_warnings in groups.items():
                        text.insert(tk.END, f"\n  {cat}:\n")
                        for warning in cat_warnings:
                            text.insert(tk.END, f"    - {warning}\n")

            # Feasibility validation (Standards-based)
            # feasibility_status, feasibility_issues, feasibility_warnings are at dynamic indices
            # We need to get column names to find the right indices
            try:
                conn = sqlite3.connect(self.parent.db_path)
                cursor = conn.cursor()
                cursor.execute("PRAGMA table_info(programs)")
                columns = [col[1] for col in cursor.fetchall()]
                conn.close()

                feas_status_idx = columns.index('feasibility_status') if 'feasibility_status' in columns else -1
                feas_issues_idx = columns.index('feasibility_issues') if 'feasibility_issues' in columns else -1
                feas_warnings_idx = columns.index('feasibility_warnings') if 'feasibility_warnings' in columns else -1

                # Display feasibility status if available
                if feas_status_idx >= 0 and len(self.record) > feas_status_idx and self.record[feas_status_idx]:
                    text.insert(tk.END, "\n" + "="*50 + "\n")
                    text.insert(tk.END, "  FEASIBILITY VALIDATION\n")
                    text.insert(tk.END, "="*50 + "\n\n")

                    feas_status = self.record[feas_status_idx]
                    if feas_status == 'FEASIBLE':
                        text.insert(tk.END, "Status: ✅ FEASIBLE\n")
                        text.insert(tk.END, "Program can physically run on assigned lathe.\n")
                    elif feas_status == 'NOT_FEASIBLE':
                        text.insert(tk.END, "Status: ❌ NOT FEASIBLE\n")
                        text.insert(tk.END, "Program CANNOT physically run on assigned lathe.\n")
                    elif feas_status == 'UNKNOWN':
                        text.insert(tk.END, "Status: ❓ UNKNOWN\n")
                        text.insert(tk.END, "Feasibility could not be determined (missing lathe assignment or data).\n")

                    # Feasibility issues (CRITICAL - prevent running)
                    if feas_issues_idx >= 0 and len(self.record) > feas_issues_idx and self.record[feas_issues_idx]:
                        try:
                            issues = json.loads(self.record[feas_issues_idx])
                        except:
                            issues = [i.strip() for i in self.record[feas_issues_idx].split('|') if i.strip()]

                        if issues:
                            text.insert(tk.END, "\nFEASIBILITY ISSUES (Program cannot run):\n")
                            for issue in issues:
                                text.insert(tk.END, f"  ❌ {issue}\n")

                    # Feasibility warnings (considerations)
                    if feas_warnings_idx >= 0 and len(self.record) > feas_warnings_idx and self.record[feas_warnings_idx]:
                        try:
                            warns = json.loads(self.record[feas_warnings_idx])
                        except:
                            warns = [i.strip() for i in self.record[feas_warnings_idx].split('|') if i.strip()]

                        if warns:
                            text.insert(tk.END, "\nFEASIBILITY WARNINGS:\n")
                            for warning in warns:
                                text.insert(tk.END, f"  ⚠️  {warning}\n")

            except Exception as e:
                # Silently ignore if feasibility fields don't exist yet
                pass

        text.config(state=tk.DISABLED)
        
        # Close button
        btn_close = tk.Button(self.window, text="Close", command=self.window.destroy,
                             bg=self.parent.button_bg, fg=self.parent.fg_color,
                             font=("Arial", 10, "bold"), width=15)
        btn_close.pack(pady=10)


class FileComparisonWindow:
    """Window to compare multiple files side-by-side"""
    def __init__(self, parent, files_data, bg_color, fg_color, input_bg, button_bg, refresh_callback, manager=None):
        self.parent = parent
        self.files_data = files_data
        self.bg_color = bg_color
        self.fg_color = fg_color
        self.input_bg = input_bg
        self.button_bg = button_bg
        self.refresh_callback = refresh_callback
        self.manager = manager  # Reference to GCodeDatabaseManager instance

        # Create lookup dictionary: {program_number: (all file data)}
        self.files_lookup = {file_info[0]: file_info for file_info in files_data}

        # Create window
        self.window = tk.Toplevel(parent)
        self.window.title(f"Compare {len(files_data)} Files")
        self.window.geometry("1400x900")
        self.window.configure(bg=bg_color)

        # Track actions for each file
        self.file_actions = {}  # {program_number: 'keep'/'delete'/'rename'}

        self.setup_ui()

    def setup_ui(self):
        """Setup the comparison UI"""
        # Title
        title_label = tk.Label(self.window,
                              text=f"File Comparison - {len(self.files_data)} Files Selected",
                              bg=self.bg_color, fg=self.fg_color,
                              font=("Arial", 14, "bold"))
        title_label.pack(pady=10)

        # Main comparison area with scrollbar
        main_frame = tk.Frame(self.window, bg=self.bg_color)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Canvas with scrollbar for horizontal scrolling
        canvas = tk.Canvas(main_frame, bg=self.bg_color)
        h_scrollbar = tk.Scrollbar(main_frame, orient=tk.HORIZONTAL, command=canvas.xview)
        v_scrollbar = tk.Scrollbar(main_frame, orient=tk.VERTICAL, command=canvas.yview)

        scrollable_frame = tk.Frame(canvas, bg=self.bg_color)
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(xscrollcommand=h_scrollbar.set, yscrollcommand=v_scrollbar.set)

        # Pack scrollbars and canvas
        v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Create side-by-side panels for each file
        panels_frame = tk.Frame(scrollable_frame, bg=self.bg_color)
        panels_frame.pack(fill=tk.BOTH, expand=True)

        # Load file contents
        file_contents = {}
        for file_info in self.files_data:
            prog_num = file_info[0]
            file_path = file_info[2]

            if file_path and os.path.exists(file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        file_contents[prog_num] = f.read()
                except:
                    file_contents[prog_num] = "[Error reading file]"
            else:
                file_contents[prog_num] = "[File not found]"

        # Run live scan on every file so each panel can show fresh issue badges.
        # Stored as {program_number: scan_result_dict | None}.
        self.scan_results = {}
        if self.manager and hasattr(self.manager, 'file_scanner'):
            for _fi in self.files_data:
                _pn, _fp = _fi[0], _fi[2]
                if _fp and os.path.exists(_fp):
                    try:
                        self.scan_results[_pn] = self.manager.file_scanner.scan_file_for_issues(_fp)
                    except Exception:
                        self.scan_results[_pn] = None

        # Create a panel for each file
        for idx, file_info in enumerate(self.files_data):
            self.create_file_panel(panels_frame, file_info, file_contents, idx)

        # Bottom action buttons
        bottom_frame = tk.Frame(self.window, bg=self.bg_color)
        bottom_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(bottom_frame, text="Apply Actions & Close",
                 command=self.apply_actions,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 11, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(bottom_frame, text="Cancel",
                 command=self.window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 11), width=15).pack(side=tk.LEFT, padx=5)

        # Summary label
        self.summary_label = tk.Label(bottom_frame,
                                     text="Select actions for each file",
                                     bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 10))
        self.summary_label.pack(side=tk.RIGHT, padx=10)

    def create_file_panel(self, parent, file_info, file_contents, index):
        """Create a panel for one file"""
        prog_num, title, file_path, spacer_type, od, thickness = file_info[:6]
        cb, hub_h, hub_d, cb_d, cb_dep, val_status, confidence = file_info[6:13]
        dup_type, parent_file, modified, created = file_info[13:17]

        # Panel container
        panel = tk.Frame(parent, bg=self.input_bg, relief=tk.RAISED, borderwidth=2)
        panel.grid(row=0, column=index, padx=5, pady=5, sticky="nsew")

        # Make columns expand equally
        parent.grid_columnconfigure(index, weight=1, uniform="col")

        # Header with file number and status
        header_bg = self.get_status_color(val_status)
        header = tk.Frame(panel, bg=header_bg)
        header.pack(fill=tk.X, pady=(0, 5))

        tk.Label(header, text=f"File {index + 1}: {prog_num}",
                bg=header_bg, fg="white",
                font=("Arial", 12, "bold")).pack(pady=5)

        if val_status:
            tk.Label(header, text=f"Status: {val_status}",
                    bg=header_bg, fg="white",
                    font=("Arial", 9)).pack()

        # ── Live scan badge ──────────────────────────────────────────────
        scan = self.scan_results.get(prog_num)
        if scan:
            s_crashes   = [e for e in scan.get('errors', []) if e.get('type') == 'crash']
            s_errors    = [e for e in scan.get('errors', []) if e.get('type') != 'crash']
            s_warnings  = scan.get('warnings', [])
            s_suggests  = scan.get('suggestions', [])

            if s_crashes:
                badge_bg, badge_fg = "#B71C1C", "white"
                parts = [f"🔴 {len(s_crashes)} CRASH{'ES' if len(s_crashes) > 1 else ''}"]
                if s_errors:   parts.append(f"✗ {len(s_errors)}")
                if s_warnings: parts.append(f"⚠ {len(s_warnings)}")
            elif s_errors:
                badge_bg, badge_fg = "#C62828", "white"
                parts = [f"✗ {len(s_errors)} ERROR{'S' if len(s_errors) > 1 else ''}"]
                if s_warnings: parts.append(f"⚠ {len(s_warnings)}")
            elif s_warnings:
                badge_bg, badge_fg = "#E65100", "white"
                parts = [f"⚠ {len(s_warnings)} WARNING{'S' if len(s_warnings) > 1 else ''}"]
            else:
                badge_bg, badge_fg = "#1B5E20", "#a5d6a7"
                parts = ["✓ PASS"]

            if s_suggests and not (s_crashes or s_errors or s_warnings):
                parts.append(f"💡 {len(s_suggests)}")

            badge_bar = tk.Frame(panel, bg=badge_bg)
            badge_bar.pack(fill=tk.X)
            tk.Label(badge_bar, text="  |  ".join(parts),
                     bg=badge_bg, fg=badge_fg,
                     font=("Arial", 10, "bold")).pack(pady=4)

            # Show the top 3 issues as a quick-read preview
            preview_items = (s_crashes + s_errors + s_warnings)[:3]
            if preview_items:
                preview_frame = tk.Frame(panel, bg="#212121")
                preview_frame.pack(fill=tk.X)
                for item in preview_items:
                    msg = item.get('message', '').strip()
                    if len(msg) > 72:
                        msg = msg[:69] + "..."
                    item_color = ("#ff8a80" if item.get('type') == 'crash' else
                                  "#ef9a9a" if item in (s_crashes + s_errors) else
                                  "#ffcc80")
                    tk.Label(preview_frame, text=f"  • {msg}",
                             bg="#212121", fg=item_color,
                             font=("Courier", 8), anchor='w',
                             justify=tk.LEFT, wraplength=300).pack(fill=tk.X, padx=5, pady=1)

        # Metadata section
        meta_frame = tk.Frame(panel, bg=self.input_bg)
        meta_frame.pack(fill=tk.X, padx=5, pady=5)

        metadata = [
            ("Title", title or "N/A"),
            ("Type", spacer_type or "N/A"),
            ("OD", f"{od:.3f}\"" if od else "N/A"),
            ("Thickness", f"{thickness:.3f}\"" if thickness else "N/A"),
            ("Center Bore", f"{cb:.3f}\"" if cb else "N/A"),
            ("Confidence", confidence or "N/A"),
        ]

        if dup_type:
            metadata.append(("Dup Type", dup_type))
        if parent_file:
            metadata.append(("Parent", parent_file))

        for label, value in metadata:
            row = tk.Frame(meta_frame, bg=self.input_bg)
            row.pack(fill=tk.X, pady=1)
            tk.Label(row, text=f"{label}:", bg=self.input_bg, fg=self.fg_color,
                    font=("Arial", 9, "bold"), width=12, anchor='w').pack(side=tk.LEFT)
            tk.Label(row, text=value, bg=self.input_bg, fg=self.fg_color,
                    font=("Arial", 9), anchor='w').pack(side=tk.LEFT, fill=tk.X, expand=True)

        # File content preview with syntax highlighting
        tk.Label(panel, text="G-Code Preview:", bg=self.input_bg, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(pady=(10, 5))

        content_frame = tk.Frame(panel, bg=self.input_bg)
        content_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        content_text = scrolledtext.ScrolledText(content_frame,
                                                bg="#1e1e1e", fg="#d4d4d4",
                                                font=("Courier New", 8),
                                                height=20, wrap=tk.NONE)
        content_text.pack(fill=tk.BOTH, expand=True)

        # Insert content with basic syntax highlighting
        content = file_contents.get(prog_num, "[No content]")
        self.insert_with_highlighting(content_text, content)
        content_text.config(state=tk.DISABLED)

        # Highlight differences if multiple files
        if len(self.files_data) > 1 and index > 0:
            self.highlight_differences(content_text, content, file_contents[self.files_data[0][0]])

        # Highlight lines referenced by scan issues (crash/error/warning)
        scan_for_hl = self.scan_results.get(prog_num)
        if scan_for_hl:
            diff_offset = 2 if (len(self.files_data) > 1 and index > 0 and
                                 content != file_contents.get(self.files_data[0][0], '')) else 0
            self.highlight_issue_lines(content_text, scan_for_hl, diff_offset)

        # Action buttons
        action_frame = tk.Frame(panel, bg=self.input_bg)
        action_frame.pack(fill=tk.X, padx=5, pady=10)

        tk.Label(action_frame, text="Action:", bg=self.input_bg, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=5)

        action_var = tk.StringVar(value="keep")
        self.file_actions[prog_num] = action_var

        tk.Radiobutton(action_frame, text="✓ Keep", variable=action_var, value="keep",
                      bg=self.input_bg, fg=self.fg_color, selectcolor=self.button_bg,
                      font=("Arial", 9), command=self.update_summary).pack(side=tk.LEFT, padx=3)

        tk.Radiobutton(action_frame, text="✏️ Rename", variable=action_var, value="rename",
                      bg=self.input_bg, fg=self.fg_color, selectcolor=self.button_bg,
                      font=("Arial", 9), command=self.update_summary).pack(side=tk.LEFT, padx=3)

        tk.Radiobutton(action_frame, text="🗑️ Delete", variable=action_var, value="delete",
                      bg=self.input_bg, fg=self.fg_color, selectcolor=self.button_bg,
                      font=("Arial", 9), command=self.update_summary).pack(side=tk.LEFT, padx=3)

        # Scan details button — only if scan ran and file exists
        if self.scan_results.get(prog_num) and file_path and os.path.exists(file_path):
            tk.Button(action_frame, text="🔍 Details",
                      command=lambda pn=prog_num, fp=file_path: self._open_scan_details(pn, fp),
                      bg="#4A148C", fg="white",
                      font=("Arial", 8), padx=4).pack(side=tk.RIGHT, padx=3)

    def get_status_color(self, status):
        """Get color based on validation status"""
        colors = {
            'CRITICAL': '#d32f2f',          # RED - Critical errors
            'SAFETY_ERROR': '#b71c1c',      # DARK RED - Missing safety blocks
            'TOOL_ERROR': '#ff5722',        # ORANGE-RED - Wrong/missing tools
            'DIMENSIONAL': '#7b1fa2',       # PURPLE - P-code mismatches
            'BORE_WARNING': '#f57c00',      # ORANGE - Bore warnings
            'TOOL_WARNING': '#fbc02d',      # AMBER - Tool suggestions
            'WARNING': '#fdd835',           # YELLOW - General warnings
            'PASS': '#388e3c',              # GREEN - All good
            'REPEAT': '#757575'             # GRAY - Duplicate
        }
        return colors.get(status, '#455a64')

    def insert_with_highlighting(self, text_widget, content):
        """Insert content with basic G-code syntax highlighting"""
        text_widget.tag_configure("gcode", foreground="#569cd6")  # Blue for G/M codes
        text_widget.tag_configure("comment", foreground="#6a9955")  # Green for comments
        text_widget.tag_configure("number", foreground="#b5cea8")  # Light green for numbers

        lines = content.split('\n')
        for line in lines:
            if '(' in line:
                # Line has comments
                before_comment = line.split('(')[0]
                comment_part = '(' + '('.join(line.split('(')[1:])
                text_widget.insert(tk.END, before_comment)
                text_widget.insert(tk.END, comment_part, "comment")
                text_widget.insert(tk.END, "\n")
            elif line.strip().startswith('G') or line.strip().startswith('M'):
                text_widget.insert(tk.END, line, "gcode")
                text_widget.insert(tk.END, "\n")
            else:
                text_widget.insert(tk.END, line + "\n")

    def highlight_differences(self, text_widget, content1, content2):
        """Highlight differences between two file contents with color coding"""
        import difflib

        # Configure tags for different types of changes
        text_widget.tag_configure("changed", background="#5a3a00", foreground="#ffcc80")  # Orange for changed lines
        text_widget.tag_configure("added", background="#1b5e20", foreground="#a5d6a7")     # Green for added lines
        text_widget.tag_configure("deleted", background="#7f0000", foreground="#ef9a9a")  # Red for deleted lines
        text_widget.tag_configure("diff_marker", foreground="#ff9800", font=("Arial", 9, "bold"))

        if content1 == content2:
            return  # No differences

        lines1 = content1.split('\n')
        lines2 = content2.split('\n')

        # Use SequenceMatcher to find differences
        matcher = difflib.SequenceMatcher(None, lines2, lines1)

        # Track changes by line number
        changed_lines = set()
        added_lines = set()
        deleted_lines = set()

        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'replace':
                # Lines were changed
                for line_num in range(j1, j2):
                    changed_lines.add(line_num)
            elif tag == 'insert':
                # Lines were added (exist in content1 but not content2)
                for line_num in range(j1, j2):
                    added_lines.add(line_num)
            elif tag == 'delete':
                # Lines were deleted (exist in content2 but not content1)
                # Mark where they would have been
                if j1 < len(lines1):
                    deleted_lines.add(j1)

        # Apply highlighting to the text widget
        # We need to re-enable the widget temporarily
        text_widget.config(state=tk.NORMAL)

        # Add difference summary at top
        total_changes = len(changed_lines) + len(added_lines) + len(deleted_lines)
        if total_changes > 0:
            summary = f"⚠ {total_changes} difference(s): {len(changed_lines)} changed, {len(added_lines)} added, {len(deleted_lines)} removed\n"
            text_widget.insert("1.0", summary, "diff_marker")
            text_widget.insert("1.0", "\n")  # Add blank line after summary

        # Highlight changed lines
        for line_num in changed_lines:
            start_idx = f"{line_num + 3}.0"  # +3 because we added 2 lines at top (blank + summary)
            end_idx = f"{line_num + 3}.end"
            text_widget.tag_add("changed", start_idx, end_idx)

        # Highlight added lines
        for line_num in added_lines:
            start_idx = f"{line_num + 3}.0"
            end_idx = f"{line_num + 3}.end"
            text_widget.tag_add("added", start_idx, end_idx)

        # Highlight deleted line markers
        for line_num in deleted_lines:
            start_idx = f"{line_num + 3}.0"
            end_idx = f"{line_num + 3}.end"
            text_widget.tag_add("deleted", start_idx, end_idx)

        # Re-disable the widget
        text_widget.config(state=tk.DISABLED)

    def highlight_issue_lines(self, text_widget, scan, line_offset=0):
        """Highlight G-code lines that are referenced by scan issues."""
        import re as _re

        text_widget.tag_configure("issue_crash",
                                  background="#4a0000", foreground="#ff8a80")
        text_widget.tag_configure("issue_error",
                                  background="#3e1000", foreground="#ffcc80")
        text_widget.tag_configure("issue_warning",
                                  background="#2a1800", foreground="#ffe082")

        all_issues = scan.get('errors', []) + scan.get('warnings', [])
        highlighted = False

        for item in all_issues:
            msg = item.get('message', '')
            m = _re.match(r'Line\s+(\d+):', msg)
            if not m:
                continue
            gcode_line = int(m.group(1))
            text_line  = gcode_line + line_offset
            start = f"{text_line}.0"
            end   = f"{text_line}.end"

            t = item.get('type', '')
            if t == 'crash':
                tag = "issue_crash"
            elif item.get('severity') == 'error':
                tag = "issue_error"
            else:
                tag = "issue_warning"

            if not highlighted:
                text_widget.config(state=tk.NORMAL)
                highlighted = True
            text_widget.tag_add(tag, start, end)

        if highlighted:
            text_widget.config(state=tk.DISABLED)

    def _open_scan_details(self, prog_num, file_path):
        """Open the full scan results dialog for one file in the comparison view."""
        scan = self.scan_results.get(prog_num)
        if scan and self.manager:
            self.manager.show_scan_results_dialog(scan, file_path)

    def update_summary(self):
        """Update the summary label with current action counts"""
        keep_count = sum(1 for var in self.file_actions.values() if var.get() == "keep")
        rename_count = sum(1 for var in self.file_actions.values() if var.get() == "rename")
        delete_count = sum(1 for var in self.file_actions.values() if var.get() == "delete")

        summary = f"Keep: {keep_count} | Rename: {rename_count} | Delete: {delete_count}"
        self.summary_label.config(text=summary)

    def apply_actions(self):
        """Apply the selected actions to files"""
        actions_to_apply = {prog: var.get() for prog, var in self.file_actions.items()}

        # Validate at least one file is kept
        if not any(action == "keep" for action in actions_to_apply.values()):
            messagebox.showerror("Invalid Action",
                "You must keep at least one file.\n\n"
                "Please select 'Keep' for at least one file.")
            return

        # Confirm actions
        delete_count = sum(1 for action in actions_to_apply.values() if action == "delete")
        rename_count = sum(1 for action in actions_to_apply.values() if action == "rename")

        msg = f"Apply the following actions?\n\n"
        msg += f"Delete: {delete_count} file(s)\n"
        msg += f"Rename: {rename_count} file(s)\n\n"
        msg += f"⚠️  Files will be deleted from DATABASE only (not disk)"

        result = messagebox.askyesno("Confirm Actions", msg)
        if not result:
            return

        # Apply actions
        conn = sqlite3.connect("gcode_database.db")
        cursor = conn.cursor()

        deleted = 0
        renamed = 0

        for prog_num, action in actions_to_apply.items():
            if action == "delete":
                cursor.execute("DELETE FROM programs WHERE program_number = ?", (prog_num,))
                deleted += 1
            elif action == "rename":
                # Prompt for new name
                new_name = self.prompt_rename(prog_num)
                if new_name and new_name != prog_num:
                    # Get file_path for this program
                    file_info = self.files_lookup.get(prog_num)
                    if file_info and len(file_info) > 2:
                        file_path = file_info[2]  # file_path is at index 2

                        # Update internal G-code program number if we have manager access
                        if self.manager and file_path and os.path.exists(file_path):
                            if not self.manager.update_gcode_program_number(file_path, new_name):
                                print(f"Warning: Could not update internal O-number in {file_path}")

                    # Update database
                    cursor.execute("""
                        UPDATE programs
                        SET program_number = ?
                        WHERE program_number = ?
                    """, (new_name, prog_num))
                    renamed += 1

        conn.commit()
        conn.close()

        # Show results
        messagebox.showinfo("Actions Applied",
            f"Successfully applied actions:\n\n"
            f"Deleted: {deleted} file(s)\n"
            f"Renamed: {renamed} file(s)")

        # Refresh parent and close
        if self.refresh_callback:
            self.refresh_callback()
        self.window.destroy()

    def prompt_rename(self, old_name):
        """Prompt user for new filename"""
        dialog = tk.Toplevel(self.window)
        dialog.title(f"Rename {old_name}")
        dialog.geometry("400x150")
        dialog.configure(bg=self.bg_color)
        dialog.transient(self.window)
        dialog.grab_set()

        tk.Label(dialog, text=f"Rename {old_name} to:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 11)).pack(pady=15)

        entry = tk.Entry(dialog, bg=self.input_bg, fg=self.fg_color,
                        font=("Arial", 11), width=30)
        entry.insert(0, old_name)
        entry.pack(pady=10)
        entry.focus()
        entry.select_range(0, tk.END)

        result = [old_name]

        def confirm():
            new_name = entry.get().strip()
            if new_name:
                result[0] = new_name
            dialog.destroy()

        def cancel():
            dialog.destroy()

        btn_frame = tk.Frame(dialog, bg=self.bg_color)
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="OK", command=confirm,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=10).pack(side=tk.LEFT, padx=5)

        tk.Button(btn_frame, text="Cancel", command=cancel,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=10).pack(side=tk.LEFT, padx=5)

        entry.bind('<Return>', lambda e: confirm())
        entry.bind('<Escape>', lambda e: cancel())

        self.window.wait_window(dialog)
        return result[0]

    # ===== Multi-File Comparison Tool =====

    def compare_files(self):
        """Launch multi-file comparison tool with difference highlighting"""
        import difflib

        # Get selected programs from tree
        selected_items = self.tree.selection()

        if len(selected_items) < 2:
            messagebox.showwarning("Selection Required",
                                 "Please select at least 2 files to compare.\n\n"
                                 "Tip: Hold Ctrl and click to select multiple files.")
            return

        if len(selected_items) > 10:
            messagebox.showwarning("Too Many Files",
                                 "Please select no more than 10 files to compare.\n"
                                 f"Currently selected: {len(selected_items)}")
            return

        # Get file information
        files_to_compare = []
        for item in selected_items:
            values = self.tree.item(item)['values']
            if values:
                program_number = values[0]
                title = values[1] if len(values) > 1 else ""

                # Get file path
                conn = sqlite3.connect(self.db_path)
                cursor = conn.cursor()
                cursor.execute("SELECT file_path FROM programs WHERE program_number = ?", (program_number,))
                result = cursor.fetchone()
                conn.close()

                if result and result[0] and os.path.exists(result[0]):
                    files_to_compare.append({
                        'program_number': program_number,
                        'title': title,
                        'file_path': result[0]
                    })
                else:
                    messagebox.showerror("File Not Found",
                                       f"Could not find file for {program_number}")
                    return

        # Create comparison window
        comp_window = tk.Toplevel(self.root)
        comp_window.title(f"Compare {len(files_to_compare)} Files - Difference Viewer")
        comp_window.geometry("1400x900")
        comp_window.configure(bg=self.bg_color)

        # Header frame
        header_frame = tk.Frame(comp_window, bg=self.bg_color)
        header_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Label(header_frame, text=f"Comparing {len(files_to_compare)} Files",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 14, "bold")).pack()

        # Control frame
        control_frame = tk.Frame(comp_window, bg=self.bg_color)
        control_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Label(control_frame, text="Select files to compare:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10)).pack(side=tk.LEFT, padx=5)

        # File selection dropdowns
        file1_var = tk.StringVar(value=files_to_compare[0]['program_number'])
        file2_var = tk.StringVar(value=files_to_compare[1]['program_number'] if len(files_to_compare) > 1 else files_to_compare[0]['program_number'])

        file_options = [f"{f['program_number']} - {f['title']}" for f in files_to_compare]

        tk.Label(control_frame, text="File 1:",
                bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        file1_combo = ttk.Combobox(control_frame, textvariable=file1_var,
                                  values=file_options, width=40, state='readonly')
        file1_combo.pack(side=tk.LEFT, padx=5)

        tk.Label(control_frame, text="File 2:",
                bg=self.bg_color, fg=self.fg_color).pack(side=tk.LEFT, padx=5)
        file2_combo = ttk.Combobox(control_frame, textvariable=file2_var,
                                  values=file_options, width=40, state='readonly')
        file2_combo.pack(side=tk.LEFT, padx=5)

        # Stats frame
        stats_frame = tk.Frame(comp_window, bg=self.bg_color)
        stats_frame.pack(fill=tk.X, padx=10, pady=5)

        stats_label = tk.Label(stats_frame, text="", bg=self.bg_color,
                              fg=self.accent_color, font=("Arial", 10, "bold"))
        stats_label.pack()

        # Main comparison frame (side-by-side)
        main_frame = tk.Frame(comp_window, bg=self.bg_color)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # Left panel
        left_frame = tk.LabelFrame(main_frame, text="File 1", bg=self.bg_color,
                                  fg=self.fg_color, font=("Arial", 10, "bold"))
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)

        left_text = tk.Text(left_frame, wrap=tk.NONE, bg=self.input_bg,
                           fg=self.fg_color, font=("Courier New", 9))
        left_scroll_y = tk.Scrollbar(left_frame, command=left_text.yview)
        left_scroll_x = tk.Scrollbar(left_frame, orient=tk.HORIZONTAL, command=left_text.xview)
        left_text.config(yscrollcommand=left_scroll_y.set, xscrollcommand=left_scroll_x.set)

        left_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        left_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        left_text.pack(fill=tk.BOTH, expand=True)

        # Right panel
        right_frame = tk.LabelFrame(main_frame, text="File 2", bg=self.bg_color,
                                   fg=self.fg_color, font=("Arial", 10, "bold"))
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5)

        right_text = tk.Text(right_frame, wrap=tk.NONE, bg=self.input_bg,
                            fg=self.fg_color, font=("Courier New", 9))
        right_scroll_y = tk.Scrollbar(right_frame, command=right_text.yview)
        right_scroll_x = tk.Scrollbar(right_frame, orient=tk.HORIZONTAL, command=right_text.xview)
        right_text.config(yscrollcommand=right_scroll_y.set, xscrollcommand=right_scroll_x.set)

        right_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        right_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        right_text.pack(fill=tk.BOTH, expand=True)

        # Configure tags for highlighting
        # Green for additions, Red for deletions, Yellow for changes
        left_text.tag_config("delete", background="#5D1F1A", foreground="#FF6B6B")
        left_text.tag_config("change", background="#5D4A1F", foreground="#FFD93D")
        left_text.tag_config("equal", background=self.input_bg, foreground=self.fg_color)

        right_text.tag_config("insert", background="#1F4D2A", foreground="#6BCF7F")
        right_text.tag_config("change", background="#5D4A1F", foreground="#FFD93D")
        right_text.tag_config("equal", background=self.input_bg, foreground=self.fg_color)

        # Sync scrolling
        def sync_scroll(*args):
            left_text.yview_moveto(args[0])
            right_text.yview_moveto(args[0])

        left_scroll_y.config(command=sync_scroll)
        right_scroll_y.config(command=sync_scroll)

        def perform_comparison():
            """Perform the actual file comparison"""
            # Get selected file indices
            file1_idx = file1_combo.current()
            file2_idx = file2_combo.current()

            if file1_idx == file2_idx:
                messagebox.showwarning("Same File", "Please select two different files to compare.")
                return

            file1_info = files_to_compare[file1_idx]
            file2_info = files_to_compare[file2_idx]

            # Read files
            try:
                with open(file1_info['file_path'], 'r', encoding='utf-8', errors='ignore') as f:
                    file1_lines = f.readlines()
                with open(file2_info['file_path'], 'r', encoding='utf-8', errors='ignore') as f:
                    file2_lines = f.readlines()
            except Exception as e:
                messagebox.showerror("Read Error", f"Could not read files: {e}")
                return

            # Clear previous content
            left_text.delete('1.0', tk.END)
            right_text.delete('1.0', tk.END)

            # Update labels
            left_frame.config(text=f"File 1: {file1_info['program_number']} - {file1_info['title']}")
            right_frame.config(text=f"File 2: {file2_info['program_number']} - {file2_info['title']}")

            # Generate diff using difflib
            differ = difflib.Differ()
            diff = list(differ.compare(file1_lines, file2_lines))

            # Count differences
            additions = sum(1 for line in diff if line.startswith('+ '))
            deletions = sum(1 for line in diff if line.startswith('- '))
            changes = min(additions, deletions)

            stats_label.config(text=f"Differences: {deletions} deletions, {additions} additions, ~{changes} changes")

            # Process diff and display with highlighting
            left_line_num = 0
            right_line_num = 0

            i = 0
            while i < len(diff):
                line = diff[i]

                if line.startswith('  '):  # Equal line
                    # Show in both panels
                    left_line_num += 1
                    right_line_num += 1
                    content = line[2:]
                    left_text.insert(tk.END, f"{left_line_num:4d} | {content}", "equal")
                    right_text.insert(tk.END, f"{right_line_num:4d} | {content}", "equal")
                    i += 1

                elif line.startswith('- '):  # Deletion (in file1, not in file2)
                    left_line_num += 1
                    content = line[2:]
                    left_text.insert(tk.END, f"{left_line_num:4d} - {content}", "delete")

                    # Check if next line is an addition (change)
                    if i + 1 < len(diff) and diff[i + 1].startswith('+ '):
                        right_line_num += 1
                        right_content = diff[i + 1][2:]
                        right_text.insert(tk.END, f"{right_line_num:4d} + {right_content}", "change")
                        left_text.delete(f"{left_text.index('end-1c linestart')}", f"{left_text.index('end-1c lineend')}")
                        left_text.insert(f"{left_text.index('end-1c linestart')}", f"{left_line_num:4d} ~ {content}", "change")
                        i += 2
                    else:
                        right_text.insert(tk.END, f"     | \n", "equal")
                        i += 1

                elif line.startswith('+ '):  # Addition (in file2, not in file1)
                    right_line_num += 1
                    content = line[2:]
                    right_text.insert(tk.END, f"{right_line_num:4d} + {content}", "insert")
                    left_text.insert(tk.END, f"     | \n", "equal")
                    i += 1

                elif line.startswith('? '):  # Diff hint (ignore)
                    i += 1

                else:
                    i += 1

            # Make read-only
            left_text.config(state=tk.DISABLED)
            right_text.config(state=tk.DISABLED)

            # Re-enable for next comparison
            comp_window.after(100, lambda: (left_text.config(state=tk.NORMAL), right_text.config(state=tk.NORMAL)))

        # Compare button
        tk.Button(control_frame, text="🔄 Compare", command=perform_comparison,
                 bg=self.accent_color, fg=self.fg_color,
                 font=("Arial", 10, "bold"), width=12).pack(side=tk.LEFT, padx=10)

        # Legend frame
        legend_frame = tk.Frame(comp_window, bg=self.bg_color)
        legend_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Label(legend_frame, text="Legend:", bg=self.bg_color,
                fg=self.fg_color, font=("Arial", 9, "bold")).pack(side=tk.LEFT, padx=5)
        tk.Label(legend_frame, text="  Green = Added  ", bg="#1F4D2A",
                fg="#6BCF7F", font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Label(legend_frame, text="  Red = Deleted  ", bg="#5D1F1A",
                fg="#FF6B6B", font=("Arial", 9)).pack(side=tk.LEFT, padx=2)
        tk.Label(legend_frame, text="  Yellow = Changed  ", bg="#5D4A1F",
                fg="#FFD93D", font=("Arial", 9)).pack(side=tk.LEFT, padx=2)

        # Close button
        tk.Button(comp_window, text="Close", command=comp_window.destroy,
                 bg=self.button_bg, fg=self.fg_color,
                 font=("Arial", 10), width=15).pack(pady=10)

        # Perform initial comparison
        perform_comparison()


class VersionComparisonWindow:
    """Enhanced window to compare two versions with tabbed interface"""

    def __init__(self, parent, db_manager, files_to_compare):
        """
        Initialize version comparison window.

        Args:
            parent: Parent window
            db_manager: Database manager instance
            files_to_compare: List of tuples [(label1, content1), (label2, content2)]
        """
        self.parent = parent
        self.db_manager = db_manager
        self.files_to_compare = files_to_compare

        # Get colors from db_manager
        self.bg_color = db_manager.bg_color
        self.fg_color = db_manager.fg_color
        self.input_bg = db_manager.input_bg
        self.button_bg = db_manager.button_bg
        self.accent_color = db_manager.accent_color

        # Create window
        self.window = tk.Toplevel(parent)
        self.window.title("Version Comparison")
        self.window.geometry("1400x800")
        self.window.configure(bg=self.bg_color)

        # Import diff engine
        from gcode_diff_engine import GCodeDiffEngine, DimensionExtractor
        from utils.archive_metadata_manager import ArchiveMetadataExtractor

        self.diff_engine = GCodeDiffEngine
        self.dim_extractor = DimensionExtractor
        self.meta_extractor = ArchiveMetadataExtractor

        self.setup_ui()

    def setup_ui(self):
        """Setup the tabbed UI"""
        # Title
        title_label = tk.Label(self.window,
                              text="Version Comparison",
                              font=("Arial", 14, "bold"),
                              bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=10)

        # File labels
        labels_frame = tk.Frame(self.window, bg=self.bg_color)
        labels_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Label(labels_frame,
                text=f"Old Version: {self.files_to_compare[1][0]}",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=10)

        tk.Label(labels_frame,
                text=" → ",
                bg=self.bg_color, fg=self.accent_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT)

        tk.Label(labels_frame,
                text=f"Current Version: {self.files_to_compare[0][0]}",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=10)

        # Create notebook for tabs
        notebook = ttk.Notebook(self.window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Tab 1: Summary
        summary_tab = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(summary_tab, text="📊 Summary")
        self.create_summary_tab(summary_tab)

        # Tab 2: Dimensions
        dimensions_tab = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(dimensions_tab, text="📏 Dimensions")
        self.create_dimensions_tab(dimensions_tab)

        # Tab 3: G-code Diff
        gcode_tab = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(gcode_tab, text="💻 G-code")
        self.create_gcode_tab(gcode_tab)

        # Close button
        close_btn = tk.Button(self.window, text="Close",
                             command=self.window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"), width=15)
        close_btn.pack(pady=10)

    def create_summary_tab(self, parent):
        """Create summary tab with overall statistics"""
        # Get content
        content_current = self.files_to_compare[0][1]
        content_old = self.files_to_compare[1][1]

        # Get diff stats
        stats = self.diff_engine.get_diff_stats(content_old, content_current)

        # Create text widget for summary
        text = scrolledtext.ScrolledText(parent, wrap=tk.WORD,
                                        bg=self.input_bg, fg=self.fg_color,
                                        font=("Courier New", 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Write summary
        text.insert(tk.END, "VERSION COMPARISON SUMMARY\n", "header")
        text.insert(tk.END, "=" * 60 + "\n\n", "header")

        text.insert(tk.END, f"Old Version:     {self.files_to_compare[1][0]}\n")
        text.insert(tk.END, f"Current Version: {self.files_to_compare[0][0]}\n\n")

        text.insert(tk.END, "G-CODE CHANGES:\n", "subheader")
        text.insert(tk.END, f"  Lines Added:     {stats['additions']}\n", "added")
        text.insert(tk.END, f"  Lines Deleted:   {stats['deletions']}\n", "deleted")
        text.insert(tk.END, f"  Lines Changed:   {stats['changes']}\n", "changed")
        text.insert(tk.END, f"  Lines Unchanged: {stats['equal']}\n\n")

        total_changes = stats['additions'] + stats['deletions'] + stats['changes']
        text.insert(tk.END, f"Total Changes:   {total_changes} lines\n\n")

        # Check for dimensional changes
        dims_old = self.meta_extractor.extract_dimensions_from_content(content_old) if hasattr(self.meta_extractor, 'extract_dimensions_from_content') else {}
        dims_current = self.meta_extractor.extract_dimensions_from_content(content_current) if hasattr(self.meta_extractor, 'extract_dimensions_from_content') else {}

        if dims_old or dims_current:
            dim_changes = self.dim_extractor.compare_dimensions(dims_old, dims_current)
            if dim_changes:
                text.insert(tk.END, "DIMENSIONAL CHANGES:\n", "subheader")
                for key, (old_val, new_val) in dim_changes.items():
                    change_str = self.dim_extractor.format_dimension_change(key, old_val, new_val)
                    text.insert(tk.END, f"  {change_str}\n", "dim_change")
            else:
                text.insert(tk.END, "No dimensional changes detected.\n")

        # Configure tags
        text.tag_configure("header", font=("Courier New", 12, "bold"), foreground="#6BCF7F")
        text.tag_configure("subheader", font=("Courier New", 10, "bold"), foreground="#FFD93D")
        text.tag_configure("added", foreground="#6BCF7F")
        text.tag_configure("deleted", foreground="#FF6B6B")
        text.tag_configure("changed", foreground="#FFD93D")
        text.tag_configure("dim_change", foreground="#9D7FFF")

        text.config(state=tk.DISABLED)

    def create_dimensions_tab(self, parent):
        """Create dimensions comparison tab"""
        # Create text widget
        text = scrolledtext.ScrolledText(parent, wrap=tk.WORD,
                                        bg=self.input_bg, fg=self.fg_color,
                                        font=("Courier New", 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Get dimensions from both versions (this would need proper implementation)
        text.insert(tk.END, "DIMENSIONAL COMPARISON\n", "header")
        text.insert(tk.END, "=" * 60 + "\n\n", "header")

        text.insert(tk.END, "Note: Full dimensional extraction requires parsing G-code.\n")
        text.insert(tk.END, "For now, check the G-code tab for dimensional differences.\n")

        # Configure tags
        text.tag_configure("header", font=("Courier New", 12, "bold"), foreground="#6BCF7F")

        text.config(state=tk.DISABLED)

    def create_gcode_tab(self, parent):
        """Create G-code diff tab with side-by-side highlighted comparison"""
        # Create frame for side-by-side comparison
        compare_frame = tk.Frame(parent, bg=self.bg_color)
        compare_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Left panel (old version)
        left_frame = tk.LabelFrame(compare_frame, text=f"Old: {self.files_to_compare[1][0]}",
                                   bg=self.bg_color, fg=self.fg_color,
                                   font=("Arial", 9, "bold"))
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))

        left_text = tk.Text(left_frame, wrap=tk.NONE,
                           bg=self.input_bg, fg=self.fg_color,
                           font=("Courier New", 9))
        left_scroll_y = tk.Scrollbar(left_frame, orient=tk.VERTICAL, command=left_text.yview)
        left_scroll_x = tk.Scrollbar(left_frame, orient=tk.HORIZONTAL, command=left_text.xview)
        left_text.config(yscrollcommand=left_scroll_y.set, xscrollcommand=left_scroll_x.set)

        left_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        left_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        left_text.pack(fill=tk.BOTH, expand=True)

        # Right panel (current version)
        right_frame = tk.LabelFrame(compare_frame, text=f"Current: {self.files_to_compare[0][0]}",
                                    bg=self.bg_color, fg=self.fg_color,
                                    font=("Arial", 9, "bold"))
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))

        right_text = tk.Text(right_frame, wrap=tk.NONE,
                            bg=self.input_bg, fg=self.fg_color,
                            font=("Courier New", 9))
        right_scroll_y = tk.Scrollbar(right_frame, orient=tk.VERTICAL, command=right_text.yview)
        right_scroll_x = tk.Scrollbar(right_frame, orient=tk.HORIZONTAL, command=right_text.xview)
        right_text.config(yscrollcommand=right_scroll_y.set, xscrollcommand=right_scroll_x.set)

        right_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        right_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        right_text.pack(fill=tk.BOTH, expand=True)

        # Sync scrolling
        def sync_scroll(*args):
            left_text.yview(*args)
            right_text.yview(*args)

        left_scroll_y.config(command=sync_scroll)
        right_scroll_y.config(command=sync_scroll)

        # Apply highlighting using diff engine
        content_old = self.files_to_compare[1][1]
        content_current = self.files_to_compare[0][1]

        stats = self.diff_engine.highlight_changes(left_text, right_text,
                                                   content_old, content_current)

        # Stats label at bottom
        stats_label = tk.Label(parent,
                              text=f"📊 {stats['additions']} added, {stats['deletions']} deleted, {stats['changes']} changed",
                              bg=self.bg_color, fg=self.fg_color,
                              font=("Arial", 9))
        stats_label.pack(pady=5)


class VersionHistoryWindow:
    """Window to display and compare version history of a program"""

    def __init__(self, parent, db_manager, program_number, current_file_path):
        self.window = tk.Toplevel(parent)
        self.db_manager = db_manager
        self.program_number = program_number
        self.current_file_path = current_file_path

        # Get colors from parent
        self.bg_color = db_manager.bg_color
        self.fg_color = db_manager.fg_color
        self.input_bg = db_manager.input_bg
        self.button_bg = db_manager.button_bg
        self.accent_color = db_manager.accent_color

        self.window.title(f"Version History - {program_number}")
        self.window.geometry("1200x600")
        self.window.configure(bg=self.bg_color)

        self.setup_ui()
        self.load_versions()

    def setup_ui(self):
        """Setup the UI components"""
        # Title
        title_label = tk.Label(self.window,
                              text=f"Version History for {self.program_number}",
                              font=("Arial", 14, "bold"),
                              bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=10)

        # Info label
        info_label = tk.Label(self.window,
                             text="Unified view showing versions from both database (🗄️ DB) and archive (📦 Archive)",
                             font=("Arial", 9, "italic"),
                             bg=self.bg_color, fg="#888888")
        info_label.pack(pady=(0, 10))

        # Frame for treeview
        tree_frame = tk.Frame(self.window, bg=self.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Scrollbars
        vsb = tk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        hsb = tk.Scrollbar(tree_frame, orient="horizontal")
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        # Treeview for versions
        columns = ("source", "version", "date", "created_by", "file_size", "compressed", "metadata_quality", "summary")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                                yscrollcommand=vsb.set, xscrollcommand=hsb.set)

        vsb.config(command=self.tree.yview)
        hsb.config(command=self.tree.xview)

        # Configure columns
        self.tree.heading("source", text="Source")
        self.tree.heading("version", text="Version")
        self.tree.heading("date", text="Date Created/Archived")
        self.tree.heading("created_by", text="Created By")
        self.tree.heading("file_size", text="File Size")
        self.tree.heading("compressed", text="Compressed")
        self.tree.heading("metadata_quality", text="Metadata")
        self.tree.heading("summary", text="Change Summary")

        self.tree.column("source", width=90, anchor="center")
        self.tree.column("version", width=70, anchor="center")
        self.tree.column("date", width=140)
        self.tree.column("created_by", width=100)
        self.tree.column("file_size", width=80, anchor="center")
        self.tree.column("compressed", width=85, anchor="center")
        self.tree.column("metadata_quality", width=80, anchor="center")
        self.tree.column("summary", width=250)

        self.tree.pack(fill=tk.BOTH, expand=True)

        # Button frame
        btn_frame = tk.Frame(self.window, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, pady=10, padx=10)

        # Compare button
        compare_btn = tk.Button(btn_frame, text="Compare to Current",
                               command=self.compare_to_current,
                               bg=self.accent_color, fg=self.fg_color,
                               font=("Arial", 10, "bold"), width=20)
        compare_btn.pack(side=tk.LEFT, padx=5)

        # Restore version button
        restore_btn = tk.Button(btn_frame, text="Restore This Version",
                               command=self.restore_version,
                               bg=self.button_bg, fg=self.fg_color,
                               font=("Arial", 10, "bold"), width=20)
        restore_btn.pack(side=tk.LEFT, padx=5)

        # Close button
        close_btn = tk.Button(btn_frame, text="Close",
                             command=self.window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"), width=15)
        close_btn.pack(side=tk.RIGHT, padx=5)

    def load_versions(self):
        """Load unified version history from both database and archive into the treeview"""
        # Clear existing items
        for item in self.tree.get_children():
            self.tree.delete(item)

        # Get unified versions from both database and archive
        versions = self.db_manager.get_unified_version_history(self.program_number)

        if not versions:
            # Show message if no versions found
            self.tree.insert("", tk.END, values=("No versions found", "", "", "", "", "", "", ""))
            return

        # Insert versions into tree
        for version in versions:
            source = version.get('source', 'unknown')
            version_number = version.get('version_number')
            date_created = version.get('date_created')
            created_by = version.get('created_by')
            change_summary = version.get('change_summary')
            file_size = version.get('file_size')
            is_compressed = version.get('is_compressed', False)
            metadata_quality = version.get('metadata_quality', 'unknown')

            # Format source with badge emoji
            if source == 'database':
                source_display = "🗄️ DB"
            elif source == 'archive':
                source_display = "📦 Archive"
            else:
                source_display = source

            # Format version number
            version_display = f"v{version_number}" if version_number else "N/A"

            # Format date
            if date_created:
                try:
                    from datetime import datetime
                    date_obj = datetime.fromisoformat(date_created)
                    date_str = date_obj.strftime("%Y-%m-%d %H:%M")
                except:
                    date_str = date_created
            else:
                date_str = ""

            # Format file size
            if file_size:
                if file_size < 1024:
                    size_str = f"{file_size} B"
                elif file_size < 1024 * 1024:
                    size_str = f"{file_size / 1024:.1f} KB"
                else:
                    size_str = f"{file_size / (1024 * 1024):.1f} MB"
            else:
                size_str = "-"

            # Format compression status
            compressed_str = "Yes" if is_compressed else "-"

            # Format metadata quality
            if metadata_quality == 'full':
                quality_str = "✓ Full"
            elif metadata_quality == 'extracted':
                quality_str = "~ Basic"
            elif metadata_quality == 'inferred':
                quality_str = "? Low"
            else:
                quality_str = metadata_quality

            # Insert into tree
            self.tree.insert("", tk.END,
                           values=(source_display,
                                  version_display,
                                  date_str,
                                  created_by or "",
                                  size_str,
                                  compressed_str,
                                  quality_str,
                                  change_summary or ""),
                           tags=(source, version_number))

    def compare_to_current(self):
        """Compare selected version to current file"""
        # Get selected item
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a version to compare.")
            return

        # Get source and version_number from tags
        item = selection[0]
        tags = self.tree.item(item, "tags")
        if not tags or len(tags) < 2:
            messagebox.showerror("Error", "No version data found.")
            return

        source = tags[0]  # 'database' or 'archive'
        version_number = tags[1]
        version_display = self.tree.item(item, "values")[1]  # Display string like "v1.0"

        try:
            version_content = None

            # Get version content based on source
            if source == 'database':
                # Get from program_versions table
                conn = sqlite3.connect(self.db_manager.db_path, timeout=30.0)
                cursor = conn.cursor()

                cursor.execute("""
                    SELECT file_content FROM program_versions
                    WHERE program_number = ? AND version_number = ?
                """, (self.program_number, version_number))
                result = cursor.fetchone()
                conn.close()

                if not result or not result[0]:
                    messagebox.showerror("Error", "Version content not found in database.")
                    return

                version_content = result[0]

            elif source == 'archive':
                # Get from archive files
                # Find archive path
                from pathlib import Path

                # Get repository path
                repo_path = Path(self.current_file_path).parent
                archive_path = repo_path.parent / 'archive'

                if not archive_path.exists():
                    messagebox.showerror("Error",
                        f"Archive folder not found:\n{archive_path}\n\n"
                        "Archive versions are stored in archive/ folder next to repository/")
                    return

                # Look for the version file in all date folders
                # Format: o#####_v1.0.nc or o#####_v1.0.nc.gz
                version_file = None
                for date_folder in archive_path.iterdir():
                    if date_folder.is_dir():
                        # Try uncompressed
                        candidate = date_folder / f"{self.program_number}_v{version_number}.nc"
                        if candidate.exists():
                            version_file = candidate
                            break

                        # Try compressed
                        candidate_gz = date_folder / f"{self.program_number}_v{version_number}.nc.gz"
                        if candidate_gz.exists():
                            version_file = candidate_gz
                            break

                if not version_file:
                    messagebox.showerror("Error",
                        f"Archive file not found for version {version_number}\n\n"
                        f"Expected location: {archive_path}/YYYY-MM-DD/\n"
                        f"Filename: {self.program_number}_v{version_number}.nc")
                    return

                # Read the file (handle compression)
                import gzip
                if str(version_file).endswith('.gz'):
                    with gzip.open(version_file, 'rt', encoding='utf-8', errors='ignore') as f:
                        version_content = f.read()
                else:
                    with open(version_file, 'r', encoding='utf-8', errors='ignore') as f:
                        version_content = f.read()

            else:
                messagebox.showerror("Error", f"Unknown version source: {source}")
                return

            # Read current file content
            if not os.path.exists(self.current_file_path):
                messagebox.showerror("Error",
                    f"Current file not found:\n{self.current_file_path}")
                return

            with open(self.current_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                current_content = f.read()

            # Create comparison data structure
            files_to_compare = [
                (f"{self.program_number} (Current)", current_content),
                (f"{self.program_number} ({version_display})", version_content)
            ]

            # Open version comparison window with enhanced tabbed interface
            VersionComparisonWindow(self.window, self.db_manager, files_to_compare)

        except Exception as e:
            import traceback
            messagebox.showerror("Error",
                f"Failed to compare versions:\n{str(e)}\n\n{traceback.format_exc()}")

    def restore_version(self):
        """Restore selected version as current file"""
        # Get selected item
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a version to restore.")
            return

        # Get source and version_number from tags
        item = selection[0]
        tags = self.tree.item(item, "tags")
        if not tags or len(tags) < 2:
            messagebox.showerror("Error", "No version data found.")
            return

        source = tags[0]  # 'database' or 'archive'
        version_number = tags[1]
        version_display = self.tree.item(item, "values")[1]  # Display string like "v1.0"

        # Confirm restoration
        confirm = messagebox.askyesno("Confirm Restore",
            f"Are you sure you want to restore {version_display}?\n\n"
            f"This will:\n"
            f"1. Create a backup of the current file as a new version\n"
            f"2. Replace the current file with {version_display}\n\n"
            f"This action cannot be undone.",
            icon='warning')

        if not confirm:
            return

        try:
            version_content = None

            # Get version content based on source
            if source == 'database':
                # Get from program_versions table
                conn = sqlite3.connect(self.db_manager.db_path, timeout=30.0)
                cursor = conn.cursor()

                cursor.execute("""
                    SELECT file_content FROM program_versions
                    WHERE program_number = ? AND version_number = ?
                """, (self.program_number, version_number))
                result = cursor.fetchone()
                conn.close()

                if not result or not result[0]:
                    messagebox.showerror("Error", "Version content not found in database.")
                    return

                version_content = result[0]

            elif source == 'archive':
                # Get from archive files
                from pathlib import Path
                import gzip

                # Get repository path
                repo_path = Path(self.current_file_path).parent
                archive_path = repo_path.parent / 'archive'

                if not archive_path.exists():
                    messagebox.showerror("Error",
                        f"Archive folder not found:\n{archive_path}\n\n"
                        "Archive versions are stored in archive/ folder next to repository/")
                    return

                # Look for the version file in all date folders
                version_file = None
                for date_folder in archive_path.iterdir():
                    if date_folder.is_dir():
                        # Try uncompressed
                        candidate = date_folder / f"{self.program_number}_v{version_number}.nc"
                        if candidate.exists():
                            version_file = candidate
                            break

                        # Try compressed
                        candidate_gz = date_folder / f"{self.program_number}_v{version_number}.nc.gz"
                        if candidate_gz.exists():
                            version_file = candidate_gz
                            break

                if not version_file:
                    messagebox.showerror("Error",
                        f"Archive file not found for version {version_number}\n\n"
                        f"Expected location: {archive_path}/YYYY-MM-DD/\n"
                        f"Filename: {self.program_number}_v{version_number}.nc")
                    return

                # Read the file (handle compression)
                if str(version_file).endswith('.gz'):
                    with gzip.open(version_file, 'rt', encoding='utf-8', errors='ignore') as f:
                        version_content = f.read()
                else:
                    with open(version_file, 'r', encoding='utf-8', errors='ignore') as f:
                        version_content = f.read()

            else:
                messagebox.showerror("Error", f"Unknown version source: {source}")
                return

            # Create backup of current file first
            self.db_manager.create_version(self.program_number,
                                          f"Backup before restoring {version_display}")

            # Write restored content to current file
            with open(self.current_file_path, 'w', encoding='utf-8') as f:
                f.write(version_content)

            messagebox.showinfo("Success",
                f"Successfully restored {version_display}\n\n"
                f"A backup of the previous version has been saved.")

            # Reload versions to show the new backup
            self.load_versions()

        except Exception as e:
            import traceback
            messagebox.showerror("Error",
                f"Failed to restore version:\n{str(e)}\n\n{traceback.format_exc()}")


class RegistryStatisticsWindow:
    """Window to display program number registry statistics"""

    def __init__(self, parent, db_manager):
        self.window = tk.Toplevel(parent)
        self.db_manager = db_manager
        self.window.title("Program Number Registry Statistics")
        self.window.geometry("900x700")
        self.window.configure(bg=db_manager.bg_color)

        # Title
        tk.Label(self.window, text="📋 Program Number Registry Statistics",
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 14, "bold")).pack(pady=10)

        # Get registry statistics
        stats = db_manager.get_registry_statistics()

        if not stats:
            tk.Label(self.window, text="Failed to load registry statistics",
                    bg=db_manager.bg_color, fg="red",
                    font=("Arial", 12)).pack(pady=20)
            return

        # Overall statistics frame
        overall_frame = tk.LabelFrame(self.window, text="Overall Statistics",
                                     bg=db_manager.bg_color, fg=db_manager.fg_color,
                                     font=("Arial", 11, "bold"))
        overall_frame.pack(fill=tk.X, padx=20, pady=10)

        stats_text = f"""
Total Program Numbers: {stats['total_numbers']:,}
In Use: {stats['in_use']:,} ({stats['in_use']/stats['total_numbers']*100:.2f}%)
Available: {stats['available']:,} ({stats['available']/stats['total_numbers']*100:.2f}%)
Reserved: {stats['reserved']:,}
Duplicates: {stats['duplicates']:,}
"""

        tk.Label(overall_frame, text=stats_text,
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 10), justify=tk.LEFT).pack(padx=10, pady=10)

        # Range statistics
        range_frame = tk.LabelFrame(self.window, text="Range Statistics",
                                   bg=db_manager.bg_color, fg=db_manager.fg_color,
                                   font=("Arial", 11, "bold"))
        range_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Create treeview for ranges
        tree_frame = tk.Frame(range_frame, bg=db_manager.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Create treeview
        columns = ("Range", "Round Size", "Total", "In Use", "Available", "Usage %", "Duplicates")
        tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                           yscrollcommand=vsb.set, height=15)
        vsb.config(command=tree.yview)

        # Configure columns
        tree.heading("Range", text="Range")
        tree.heading("Round Size", text="Round Size")
        tree.heading("Total", text="Total")
        tree.heading("In Use", text="In Use")
        tree.heading("Available", text="Available")
        tree.heading("Usage %", text="Usage %")
        tree.heading("Duplicates", text="Duplicates")

        tree.column("Range", width=150)
        tree.column("Round Size", width=80)
        tree.column("Total", width=80)
        tree.column("In Use", width=80)
        tree.column("Available", width=100)
        tree.column("Usage %", width=80)
        tree.column("Duplicates", width=80)

        # Populate tree
        for range_name, range_stats in stats['by_range'].items():
            values = (
                range_stats['range'],
                range_stats['round_size'],
                f"{range_stats['total']:,}",
                f"{range_stats['in_use']:,}",
                f"{range_stats['available']:,}",
                f"{range_stats['usage_percent']:.1f}%",
                range_stats['duplicates']
            )
            tree.insert("", tk.END, values=values)

        tree.pack(fill=tk.BOTH, expand=True)

        # Buttons
        button_frame = tk.Frame(self.window, bg=db_manager.bg_color)
        button_frame.pack(fill=tk.X, padx=20, pady=10)

        tk.Button(button_frame, text="Refresh",
                 command=lambda: self.refresh_stats(),
                 bg=db_manager.accent_color, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="Close",
                 command=self.window.destroy,
                 bg=db_manager.button_bg, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.RIGHT, padx=5)

    def refresh_stats(self):
        """Refresh the statistics display"""
        self.window.destroy()
        RegistryStatisticsWindow(self.window.master, self.db_manager)


class OutOfRangeWindow:
    """Window to display programs that are in wrong ranges for their round size"""

    def __init__(self, parent, db_manager):
        self.window = tk.Toplevel(parent)
        self.db_manager = db_manager
        self.window.title("Out-of-Range Programs")
        self.window.geometry("1100x700")
        self.window.configure(bg=db_manager.bg_color)

        # Title
        tk.Label(self.window, text="⚠️ Programs in Wrong Ranges",
                bg=db_manager.bg_color, fg="#FF6B6B",
                font=("Arial", 14, "bold")).pack(pady=10)

        # Info
        info_text = """These programs have a detected round size but their program number
is in the wrong range. They should be renamed to match their round size."""

        tk.Label(self.window, text=info_text,
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 10), justify=tk.CENTER).pack(pady=5)

        # Get out-of-range programs
        out_of_range = db_manager.get_out_of_range_programs()

        # Count label
        tk.Label(self.window, text=f"Found {len(out_of_range):,} programs in wrong ranges",
                bg=db_manager.bg_color, fg="#FFA500",
                font=("Arial", 11, "bold")).pack(pady=5)

        # Create treeview
        tree_frame = tk.Frame(self.window, bg=db_manager.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        hsb = ttk.Scrollbar(tree_frame, orient="horizontal")
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        # Create treeview
        columns = ("Program #", "Round Size", "Current Range", "Correct Range", "Title")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                                yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.config(command=self.tree.yview)
        hsb.config(command=self.tree.xview)

        # Configure columns
        self.tree.heading("Program #", text="Program #")
        self.tree.heading("Round Size", text="Round Size")
        self.tree.heading("Current Range", text="Current Range")
        self.tree.heading("Correct Range", text="Correct Range")
        self.tree.heading("Title", text="Title")

        self.tree.column("Program #", width=100)
        self.tree.column("Round Size", width=100)
        self.tree.column("Current Range", width=200)
        self.tree.column("Correct Range", width=150)
        self.tree.column("Title", width=400)

        # Populate tree
        for prog_num, round_size, current_range, correct_range, title in out_of_range:
            values = (
                prog_num,
                round_size,
                current_range,
                correct_range,
                title or "(No title)"
            )
            self.tree.insert("", tk.END, values=values)

        self.tree.pack(fill=tk.BOTH, expand=True)

        # Buttons
        button_frame = tk.Frame(self.window, bg=db_manager.bg_color)
        button_frame.pack(fill=tk.X, padx=20, pady=10)

        tk.Button(button_frame, text="Export to CSV",
                 command=lambda: self.export_to_csv(out_of_range),
                 bg=db_manager.accent_color, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="Refresh",
                 command=lambda: self.refresh_data(),
                 bg=db_manager.accent_color, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="Close",
                 command=self.window.destroy,
                 bg=db_manager.button_bg, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.RIGHT, padx=5)

    def export_to_csv(self, data):
        """Export out-of-range programs to CSV"""
        try:
            filepath = filedialog.asksaveasfilename(
                title="Export Out-of-Range Programs",
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
            )

            if filepath:
                import csv
                with open(filepath, 'w', newline='', encoding='utf-8') as f:
                    writer = csv.writer(f)
                    writer.writerow(["Program Number", "Round Size", "Current Range", "Correct Range", "Title"])
                    for row in data:
                        writer.writerow(row)

                messagebox.showinfo("Success", f"Exported {len(data):,} programs to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export:\n{str(e)}")

    def refresh_data(self):
        """Refresh the display"""
        self.window.destroy()
        OutOfRangeWindow(self.window.master, self.db_manager)


class BatchRenameWindow:
    """Window to preview and execute batch rename of out-of-range programs"""

    def __init__(self, parent, db_manager):
        self.window = tk.Toplevel(parent)
        self.db_manager = db_manager
        self.window.title("Batch Rename Out-of-Range Programs")
        self.window.geometry("1200x800")
        self.window.configure(bg=db_manager.bg_color)

        # Title
        tk.Label(self.window, text="🔧 Batch Rename Resolution - Type 1 Duplicates",
                bg=db_manager.bg_color, fg="#9B59B6",
                font=("Arial", 14, "bold")).pack(pady=10)

        # Info
        info_frame = tk.Frame(self.window, bg=db_manager.bg_color)
        info_frame.pack(fill=tk.X, padx=20, pady=5)

        info_text = """This will rename programs that are in wrong ranges to match their round size.
Each program will be renamed to the next available number in the correct range.
Legacy names will be tracked in the database and added as comments in the files."""

        tk.Label(info_frame, text=info_text,
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 10), justify=tk.LEFT).pack()

        # Preview section
        preview_frame = tk.LabelFrame(self.window, text="Rename Preview",
                                     bg=db_manager.bg_color, fg=db_manager.fg_color,
                                     font=("Arial", 11, "bold"))
        preview_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Generate preview button
        preview_button_frame = tk.Frame(preview_frame, bg=db_manager.bg_color)
        preview_button_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Button(preview_button_frame, text="Generate Preview",
                 command=self.generate_preview,
                 bg=db_manager.accent_color, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        self.preview_limit_var = tk.StringVar(value="50")
        tk.Label(preview_button_frame, text="Limit:",
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 9)).pack(side=tk.LEFT, padx=5)
        tk.Entry(preview_button_frame, textvariable=self.preview_limit_var,
                font=("Arial", 9), width=8).pack(side=tk.LEFT)

        tk.Label(preview_button_frame, text="(use 'all' for no limit)",
                bg=db_manager.bg_color, fg=db_manager.fg_color,
                font=("Arial", 8, "italic")).pack(side=tk.LEFT, padx=5)

        # Create treeview for preview
        tree_frame = tk.Frame(preview_frame, bg=db_manager.bg_color)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Scrollbars
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        hsb = ttk.Scrollbar(tree_frame, orient="horizontal")
        hsb.pack(side=tk.BOTTOM, fill=tk.X)

        # Create treeview
        columns = ("Old #", "New #", "Round Size", "Current Range", "Correct Range", "Title", "Status")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings",
                                yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.config(command=self.tree.yview)
        hsb.config(command=self.tree.xview)

        # Configure columns
        self.tree.heading("Old #", text="Old #")
        self.tree.heading("New #", text="New #")
        self.tree.heading("Round Size", text="Round Size")
        self.tree.heading("Current Range", text="Current Range")
        self.tree.heading("Correct Range", text="Correct Range")
        self.tree.heading("Title", text="Title")
        self.tree.heading("Status", text="Status")

        self.tree.column("Old #", width=80)
        self.tree.column("New #", width=80)
        self.tree.column("Round Size", width=90)
        self.tree.column("Current Range", width=150)
        self.tree.column("Correct Range", width=120)
        self.tree.column("Title", width=350)
        self.tree.column("Status", width=100)

        self.tree.pack(fill=tk.BOTH, expand=True)

        # Stats label
        self.stats_label = tk.Label(self.window, text="No preview generated yet",
                                   bg=db_manager.bg_color, fg="#FFA500",
                                   font=("Arial", 10, "bold"))
        self.stats_label.pack(pady=5)

        # Action buttons
        button_frame = tk.Frame(self.window, bg=db_manager.bg_color)
        button_frame.pack(fill=tk.X, padx=20, pady=10)

        self.execute_button = tk.Button(button_frame, text="⚠️ EXECUTE BATCH RENAME ⚠️",
                                        command=self.execute_batch_rename,
                                        bg="#C41E3A", fg="white",
                                        font=("Arial", 11, "bold"), width=30,
                                        state=tk.DISABLED)
        self.execute_button.pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="Export Preview to CSV",
                 command=self.export_preview,
                 bg=db_manager.accent_color, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=20).pack(side=tk.LEFT, padx=5)

        tk.Button(button_frame, text="Close",
                 command=self.window.destroy,
                 bg=db_manager.button_bg, fg=db_manager.fg_color,
                 font=("Arial", 10, "bold"), width=15).pack(side=tk.RIGHT, padx=5)

        # Store preview data
        self.preview_data = []

    def generate_preview(self):
        """Generate preview of what will be renamed"""
        try:
            # Clear existing tree
            for item in self.tree.get_children():
                self.tree.delete(item)

            # Get limit
            limit_str = self.preview_limit_var.get().strip().lower()
            limit = None if limit_str == 'all' else int(limit_str)

            # Generate preview
            self.stats_label.config(text="Generating preview...", fg="orange")
            self.window.update()

            self.preview_data = self.db_manager.preview_rename_plan(limit=limit)

            # Populate tree
            for item in self.preview_data:
                values = (
                    item['old_number'],
                    item['new_number'],
                    item['round_size'],
                    item['current_range'],
                    item['correct_range'],
                    item['title'] or "(No title)",
                    item['status']
                )
                self.tree.insert("", tk.END, values=values)

            # Update stats
            total = len(self.preview_data)
            ready = sum(1 for item in self.preview_data if item['status'] == 'Ready')
            errors = total - ready

            self.stats_label.config(
                text=f"Preview: {total:,} programs | {ready:,} ready | {errors} errors",
                fg="green" if errors == 0 else "orange"
            )

            # Enable execute button if we have valid renames
            if ready > 0:
                self.execute_button.config(state=tk.NORMAL)
            else:
                self.execute_button.config(state=tk.DISABLED)

        except ValueError:
            messagebox.showerror("Invalid Input", "Limit must be a number or 'all'")
        except Exception as e:
            messagebox.showerror("Preview Error", f"Failed to generate preview:\n{str(e)}")
            self.stats_label.config(text="Preview generation failed", fg="red")

    def execute_batch_rename(self):
        """Execute the batch rename operation"""
        if not self.preview_data:
            messagebox.showwarning("No Preview", "Please generate a preview first")
            return

        # Count how many will be renamed
        ready_count = sum(1 for item in self.preview_data if item['status'] == 'Ready')

        # Confirm with user
        confirm = messagebox.askyesno(
            "Confirm Batch Rename",
            f"This will rename {ready_count:,} programs.\n\n"
            "Each program will:\n"
            "  - Get a new number in the correct range\n"
            "  - Have legacy name added to database\n"
            "  - Have comment added to file\n"
            "  - Be logged in resolution audit table\n\n"
            "This operation cannot be easily undone.\n\n"
            "Do you want to proceed?",
            icon='warning'
        )

        if not confirm:
            return

        # Create auto-backup before this destructive operation
        backup_path = self.db_manager.create_auto_backup("batch_rename")
        if backup_path:
            logger.info("Auto-backup created before batch rename")

        # Create progress window
        progress_window = tk.Toplevel(self.window)
        progress_window.title("Batch Rename Progress")
        progress_window.geometry("600x400")
        progress_window.configure(bg=self.db_manager.bg_color)

        tk.Label(progress_window, text="🔧 Renaming Programs...",
                bg=self.db_manager.bg_color, fg=self.db_manager.fg_color,
                font=("Arial", 12, "bold")).pack(pady=10)

        # Progress bar
        progress_var = tk.DoubleVar()
        progress_bar = ttk.Progressbar(progress_window, variable=progress_var,
                                      maximum=100, length=500)
        progress_bar.pack(pady=10, padx=20)

        # Status label
        status_label = tk.Label(progress_window, text="Starting...",
                               bg=self.db_manager.bg_color, fg=self.db_manager.fg_color,
                               font=("Arial", 10))
        status_label.pack(pady=5)

        # Log text
        log_frame = tk.Frame(progress_window, bg=self.db_manager.bg_color)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        log_scroll = ttk.Scrollbar(log_frame)
        log_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        log_text = tk.Text(log_frame, height=15, yscrollcommand=log_scroll.set,
                          bg="#2B2B2B", fg="#FFFFFF", font=("Consolas", 9))
        log_scroll.config(command=log_text.yview)
        log_text.pack(fill=tk.BOTH, expand=True)

        def log(message):
            try:
                if log_text.winfo_exists():
                    log_text.insert(tk.END, message + "\n")
                    log_text.see(tk.END)
                    progress_window.update()
            except tk.TclError:
                pass

        # Progress callback
        def progress_callback(current, total, prog_num):
            progress_var.set((current / total) * 100)
            status_label.config(text=f"Processing {current}/{total}: {prog_num}")
            log(f"[{current}/{total}] Processing {prog_num}...")

        # Get programs to rename (only those with 'Ready' status)
        programs_to_rename = [item['old_number'] for item in self.preview_data if item['status'] == 'Ready']

        log(f"Starting batch rename of {len(programs_to_rename):,} programs...")
        log("-" * 60)

        # Execute batch rename
        stats = self.db_manager.batch_resolve_out_of_range(
            program_numbers=programs_to_rename,
            dry_run=False,
            progress_callback=progress_callback
        )

        # Show results
        log("-" * 60)
        log("BATCH RENAME COMPLETE")
        log(f"Total: {stats['total']}")
        log(f"Successful: {stats['successful']}")
        log(f"Failed: {stats['failed']}")
        log(f"Skipped: {stats['skipped']}")

        if stats['errors']:
            log("\nErrors:")
            for error in stats['errors'][:10]:  # Show first 10 errors
                log(f"  - {error['program']}: {error['error']}")
            if len(stats['errors']) > 10:
                log(f"  ... and {len(stats['errors']) - 10} more errors")

        status_label.config(text="Complete!")
        progress_var.set(100)

        # Add close button
        tk.Button(progress_window, text="Close",
                 command=progress_window.destroy,
                 bg=self.db_manager.button_bg, fg=self.db_manager.fg_color,
                 font=("Arial", 10, "bold")).pack(pady=10)

        # Show summary message
        messagebox.showinfo(
            "Batch Rename Complete",
            f"Batch rename completed!\n\n"
            f"Successful: {stats['successful']:,}\n"
            f"Failed: {stats['failed']}\n"
            f"Skipped: {stats['skipped']}\n\n"
            f"Check the log for details."
        )

        # Refresh preview
        self.generate_preview()

    def export_preview(self):
        """Export preview data to CSV"""
        if not self.preview_data:
            messagebox.showwarning("No Preview", "Please generate a preview first")
            return

        try:
            filepath = filedialog.asksaveasfilename(
                title="Export Rename Preview",
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
            )

            if filepath:
                import csv
                with open(filepath, 'w', newline='', encoding='utf-8') as f:
                    writer = csv.writer(f)
                    writer.writerow(["Old Number", "New Number", "Round Size",
                                   "Current Range", "Correct Range", "Title", "Status"])
                    for item in self.preview_data:
                        writer.writerow([
                            item['old_number'],
                            item['new_number'],
                            item['round_size'],
                            item['current_range'],
                            item['correct_range'],
                            item['title'] or "(No title)",
                            item['status']
                        ])

                messagebox.showinfo("Success", f"Exported {len(self.preview_data):,} items to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export:\n{str(e)}")


def main():
    logger.info("Starting G-Code Database Manager...")

    # Try to use TkinterDnD for drag & drop support, fallback to regular Tk
    try:
        from tkinterdnd2 import TkinterDnD
        root = TkinterDnD.Tk()
        logger.info("Using TkinterDnD for drag & drop support")
    except ImportError:
        root = tk.Tk()
        logger.info("TkinterDnD not available, using standard Tk")

    try:
        app = GCodeDatabaseGUI(root)
        root.mainloop()
    except Exception as e:
        logger.critical(f"Application crashed: {e}", exc_info=True)
        import traceback
        traceback.print_exc()
        # Show error dialog
        import tkinter.messagebox as mb
        mb.showerror("Fatal Error", f"Application crashed:\n\n{e}\n\nCheck logs/gcode_database.log for details")
        raise


class ArchiveCleanupWindow:
    """Window for managing archive compression and cleanup"""

    def __init__(self, parent):
        """
        Initialize archive cleanup window.

        Args:
            parent: Parent GCodeDatabaseManager instance
        """
        self.parent = parent
        self.window = tk.Toplevel(parent.root)
        self.window.title("Archive Cleanup & Compression")
        self.window.geometry("700x600")
        self.window.configure(bg=parent.bg_color)

        # Get colors from parent
        self.bg_color = parent.bg_color
        self.fg_color = parent.fg_color
        self.input_bg = parent.input_bg
        self.button_bg = parent.button_bg
        self.accent_color = parent.accent_color

        # Get paths
        from pathlib import Path
        repo_path = Path(parent.repository_path)
        self.archive_path = str(repo_path.parent / 'archive')

        # Import cleanup manager
        from utils.archive_cleanup_manager import ArchiveCleanupManager
        self.cleanup_manager = ArchiveCleanupManager(parent.db_path, self.archive_path)

        self.setup_ui()
        self.load_statistics()

    def setup_ui(self):
        """Setup the UI components"""
        # Title
        title_label = tk.Label(self.window,
                              text="Archive Cleanup & Compression",
                              font=("Arial", 14, "bold"),
                              bg=self.bg_color, fg=self.fg_color)
        title_label.pack(pady=10)

        # Statistics frame
        stats_frame = tk.LabelFrame(self.window,
                                   text="Archive Statistics",
                                   bg=self.bg_color, fg=self.fg_color,
                                   font=("Arial", 10, "bold"))
        stats_frame.pack(fill=tk.X, padx=20, pady=10)

        self.stats_labels = {}
        for key in ['total', 'compressed', 'uncompressed', 'size', 'v1_protected', 'ratio']:
            label = tk.Label(stats_frame,
                           text="Loading...",
                           bg=self.bg_color, fg=self.fg_color,
                           font=("Arial", 9))
            label.pack(anchor=tk.W, padx=10, pady=2)
            self.stats_labels[key] = label

        # Settings frame
        settings_frame = tk.LabelFrame(self.window,
                                      text="Compression Settings",
                                      bg=self.bg_color, fg=self.fg_color,
                                      font=("Arial", 10, "bold"))
        settings_frame.pack(fill=tk.X, padx=20, pady=10)

        # Threshold setting
        threshold_frame = tk.Frame(settings_frame, bg=self.bg_color)
        threshold_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Label(threshold_frame,
                text="Compress files older than:",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9)).pack(side=tk.LEFT, padx=5)

        self.threshold_var = tk.StringVar(value="90")
        threshold_entry = tk.Entry(threshold_frame,
                                  textvariable=self.threshold_var,
                                  bg=self.input_bg, fg=self.fg_color,
                                  width=10,
                                  font=("Arial", 9))
        threshold_entry.pack(side=tk.LEFT, padx=5)

        tk.Label(threshold_frame,
                text="days",
                bg=self.bg_color, fg=self.fg_color,
                font=("Arial", 9)).pack(side=tk.LEFT, padx=5)

        # Info label
        info_label = tk.Label(settings_frame,
                            text="Note: Version 1.0 files are always protected from compression",
                            bg=self.bg_color, fg="#888888",
                            font=("Arial", 8, "italic"))
        info_label.pack(padx=10, pady=5)

        # Actions frame
        actions_frame = tk.LabelFrame(self.window,
                                     text="Actions",
                                     bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 10, "bold"))
        actions_frame.pack(fill=tk.X, padx=20, pady=10)

        button_frame = tk.Frame(actions_frame, bg=self.bg_color)
        button_frame.pack(pady=10)

        # Preview button
        preview_btn = tk.Button(button_frame,
                               text="🔍 Preview",
                               command=self.preview_compression,
                               bg=self.button_bg, fg=self.fg_color,
                               font=("Arial", 10, "bold"),
                               width=15)
        preview_btn.pack(side=tk.LEFT, padx=5)

        # Compress button
        compress_btn = tk.Button(button_frame,
                                text="🗜️ Compress",
                                command=self.compress_archives,
                                bg=self.accent_color, fg=self.fg_color,
                                font=("Arial", 10, "bold"),
                                width=15)
        compress_btn.pack(side=tk.LEFT, padx=5)

        # Refresh stats button
        refresh_btn = tk.Button(button_frame,
                               text="🔄 Refresh Stats",
                               command=self.load_statistics,
                               bg=self.button_bg, fg=self.fg_color,
                               font=("Arial", 10, "bold"),
                               width=15)
        refresh_btn.pack(side=tk.LEFT, padx=5)

        # Results frame
        results_frame = tk.LabelFrame(self.window,
                                     text="Results",
                                     bg=self.bg_color, fg=self.fg_color,
                                     font=("Arial", 10, "bold"))
        results_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        self.results_text = scrolledtext.ScrolledText(results_frame,
                                                     wrap=tk.WORD,
                                                     bg=self.input_bg,
                                                     fg=self.fg_color,
                                                     font=("Courier New", 9))
        self.results_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Close button
        close_btn = tk.Button(self.window,
                             text="Close",
                             command=self.window.destroy,
                             bg=self.button_bg, fg=self.fg_color,
                             font=("Arial", 10, "bold"),
                             width=15)
        close_btn.pack(pady=10)

    def load_statistics(self):
        """Load and display compression statistics"""
        stats = self.cleanup_manager.get_compression_statistics()

        self.stats_labels['total'].config(
            text=f"Total Archives: {stats['total_archives']}")
        self.stats_labels['compressed'].config(
            text=f"Compressed: {stats['compressed']} ({stats['compression_ratio']:.1f}%)")
        self.stats_labels['uncompressed'].config(
            text=f"Uncompressed: {stats['uncompressed']}")
        self.stats_labels['size'].config(
            text=f"Uncompressed Size: {stats['uncompressed_size_mb']:.2f} MB")
        self.stats_labels['v1_protected'].config(
            text=f"Version 1.0 Protected: {stats['version_1_protected']}")

        # Calculate potential savings (assuming 70% compression ratio for text files)
        potential_savings = stats['uncompressed_size_mb'] * 0.7
        self.stats_labels['ratio'].config(
            text=f"Potential Savings: ~{potential_savings:.2f} MB")

    def preview_compression(self):
        """Preview what files would be compressed"""
        try:
            threshold = int(self.threshold_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid number of days")
            return

        self.results_text.delete('1.0', tk.END)
        self.results_text.insert(tk.END, f"Preview: Files older than {threshold} days\n")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n")

        # Run dry run
        compressed, errors, error_msgs = self.cleanup_manager.compress_old_archives(
            days_threshold=threshold,
            dry_run=True
        )

        self.results_text.insert(tk.END, f"Found {compressed} files eligible for compression\n\n")

        if compressed == 0:
            self.results_text.insert(tk.END, "No files found matching criteria.\n")
        else:
            self.results_text.insert(tk.END, f"Click 'Compress' to compress {compressed} files.\n")

        self.results_text.see(tk.END)

    def compress_archives(self):
        """Compress old archive files"""
        try:
            threshold = int(self.threshold_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid number of days")
            return

        # Confirm action
        response = messagebox.askyesno(
            "Confirm Compression",
            f"This will compress all archive files older than {threshold} days.\n\n"
            "Version 1.0 files will be protected.\n"
            "Original files will be replaced with compressed (.gz) versions.\n\n"
            "Continue?"
        )

        if not response:
            return

        self.results_text.delete('1.0', tk.END)
        self.results_text.insert(tk.END, f"Compressing files older than {threshold} days...\n")
        self.results_text.insert(tk.END, "=" * 60 + "\n\n")
        self.window.update()

        # Run compression
        compressed, errors, error_msgs = self.cleanup_manager.compress_old_archives(
            days_threshold=threshold,
            dry_run=False
        )

        # Display results
        self.results_text.insert(tk.END, "\n" + "=" * 60 + "\n")
        self.results_text.insert(tk.END, "COMPRESSION COMPLETE\n")
        self.results_text.insert(tk.END, "=" * 60 + "\n")
        self.results_text.insert(tk.END, f"Successfully compressed: {compressed} files\n")
        self.results_text.insert(tk.END, f"Errors: {errors}\n")

        if error_msgs:
            self.results_text.insert(tk.END, "\nErrors:\n")
            for msg in error_msgs:
                self.results_text.insert(tk.END, f"  - {msg}\n")

        self.results_text.see(tk.END)

        # Refresh statistics
        self.load_statistics()

        if errors == 0:
            messagebox.showinfo("Success", f"Successfully compressed {compressed} archive files!")
        else:
            messagebox.showwarning("Completed with Errors",
                                  f"Compressed {compressed} files with {errors} errors.\n"
                                  f"See results for details.")


if __name__ == "__main__":
    main()
